//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.8
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from PlPgSqlParser.g4 by ANTLR 4.8

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

using System;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.8")]
[System.CLSCompliant(false)]
public partial class PlPgSqlParser : Parser {
	protected static DFA[] decisionToDFA;
	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
	public const int
		ABORT=1, ABSOLUTE=2, ACCESS=3, ACTION=4, ADD=5, ADMIN=6, AFTER=7, AGGREGATE=8, 
		ALSO=9, ALTER=10, ALWAYS=11, ASSERTION=12, ASSIGNMENT=13, AT=14, ATTACH=15, 
		ATTRIBUTE=16, BACKWARD=17, BEFORE=18, BEGIN=19, BY=20, CACHE=21, CALL=22, 
		CALLED=23, CASCADE=24, CASCADED=25, CATALOG=26, CHAIN=27, CHARACTERISTICS=28, 
		CHECKPOINT=29, CLASS=30, CLOSE=31, CLUSTER=32, COLUMNS=33, COMMENT=34, 
		COMMENTS=35, COMMIT=36, COMMITTED=37, CONFIGURATION=38, CONFLICT=39, CONNECTION=40, 
		CONSTRAINTS=41, CONTENT=42, CONTINUE=43, CONVERSION=44, COPY=45, COST=46, 
		CSV=47, CUBE=48, CURRENT=49, CURSOR=50, CYCLE=51, DATA=52, DATABASE=53, 
		DAY=54, DEALLOCATE=55, DECLARE=56, DEFAULTS=57, DEFERRED=58, DEFINER=59, 
		DELETE=60, DELIMITER=61, DELIMITERS=62, DEPENDS=63, DETACH=64, DICTIONARY=65, 
		DISABLE=66, DISCARD=67, DOCUMENT=68, DOMAIN=69, DOUBLE=70, DROP=71, EACH=72, 
		ENABLE=73, ENCODING=74, ENCRYPTED=75, ENUM=76, ESCAPE=77, EVENT=78, EXCLUDE=79, 
		EXCLUDING=80, EXCLUSIVE=81, EXECUTE=82, EXPLAIN=83, EXTENSION=84, EXTERNAL=85, 
		FAMILY=86, FILTER=87, FIRST=88, FOLLOWING=89, FORCE=90, FORWARD=91, FUNCTION=92, 
		FUNCTIONS=93, GENERATED=94, GLOBAL=95, GRANTED=96, GROUPS=97, HANDLER=98, 
		HEADER=99, HOLD=100, HOUR=101, IDENTITY=102, IF=103, IMMEDIATE=104, IMMUTABLE=105, 
		IMPLICIT=106, IMPORT=107, INCLUDE=108, INCLUDING=109, INCREMENT=110, INDEX=111, 
		INDEXES=112, INHERIT=113, INHERITS=114, INLINE=115, INPUT=116, INSENSITIVE=117, 
		INSERT=118, INSTEAD=119, INVOKER=120, ISOLATION=121, KEY=122, LABEL=123, 
		LANGUAGE=124, LARGE=125, LAST=126, LEAKPROOF=127, LEVEL=128, LISTEN=129, 
		LOAD=130, LOCAL=131, LOCATION=132, LOCK=133, LOCKED=134, LOGGED=135, MAPPING=136, 
		MATCH=137, MATERIALIZED=138, MAXVALUE=139, METHOD=140, MINUTE=141, MINVALUE=142, 
		MODE=143, MONTH=144, MOVE=145, NAME=146, NAMES=147, NEW=148, NEXT=149, 
		NO=150, NOTHING=151, NOTIFY=152, NOWAIT=153, NULLS=154, OBJECT=155, OF=156, 
		OFF=157, OIDS=158, OLD=159, OPERATOR=160, OPTION=161, OPTIONS=162, ORDINALITY=163, 
		OTHERS=164, OVER=165, OVERRIDING=166, OWNED=167, OWNER=168, PARALLEL=169, 
		PARSER=170, PARTIAL=171, PARTITION=172, PASSING=173, PASSWORD=174, PLANS=175, 
		POLICY=176, PRECEDING=177, PREPARE=178, PREPARED=179, PRESERVE=180, PRIOR=181, 
		PRIVILEGES=182, PROCEDURAL=183, PROCEDURE=184, PROCEDURES=185, PROGRAM=186, 
		PUBLICATION=187, QUOTE=188, RANGE=189, READ=190, REASSIGN=191, RECHECK=192, 
		RECURSIVE=193, REF=194, REFERENCING=195, REFRESH=196, REINDEX=197, RELATIVE=198, 
		RELEASE=199, RENAME=200, REPEATABLE=201, REPLACE=202, REPLICA=203, RESET=204, 
		RESTART=205, RESTRICT=206, RETURNS=207, REVOKE=208, ROLE=209, ROLLBACK=210, 
		ROLLUP=211, ROUTINE=212, ROUTINES=213, ROWS=214, RULE=215, SAVEPOINT=216, 
		SCHEMA=217, SCHEMAS=218, SCROLL=219, SEARCH=220, SECOND=221, SECURITY=222, 
		SEQUENCE=223, SEQUENCES=224, SERIALIZABLE=225, SERVER=226, SESSION=227, 
		SET=228, SETS=229, SHARE=230, SHOW=231, SIMPLE=232, SKIP_=233, SNAPSHOT=234, 
		SQL=235, STABLE=236, STANDALONE=237, START=238, STATEMENT=239, STATISTICS=240, 
		STDIN=241, STDOUT=242, STORAGE=243, STORED=244, STRICT=245, STRIP=246, 
		SUBSCRIPTION=247, SUPPORT=248, SYSID=249, SYSTEM=250, TABLES=251, TABLESPACE=252, 
		TEMP=253, TEMPLATE=254, TEMPORARY=255, TEXT=256, TIES=257, TRANSACTION=258, 
		TRANSFORM=259, TRIGGER=260, TRUNCATE=261, TRUSTED=262, TYPE=263, TYPES=264, 
		UNBOUNDED=265, UNCOMMITTED=266, UNENCRYPTED=267, UNKNOWN=268, UNLISTEN=269, 
		UNLOGGED=270, UNTIL=271, UPDATE=272, VACUUM=273, VALID=274, VALIDATE=275, 
		VALIDATOR=276, VALUE=277, VARYING=278, VERSION=279, VIEW=280, VIEWS=281, 
		VOLATILE=282, WHITESPACE=283, WITHIN=284, WITHOUT=285, WORK=286, WRAPPER=287, 
		WRITE=288, XML=289, YEAR=290, YES=291, ZONE=292, BETWEEN=293, BIGINT=294, 
		BIT=295, BOOLEAN=296, CHAR=297, CHARACTER=298, COALESCE=299, DEC=300, 
		DECIMAL=301, EXISTS=302, EXTRACT=303, FLOAT=304, GREATEST=305, GROUPING=306, 
		INOUT=307, INT=308, INTEGER=309, INTERVAL=310, LEAST=311, NATIONAL=312, 
		NCHAR=313, NONE=314, NULLIF=315, NUMERIC=316, OUT=317, OVERLAY=318, POSITION=319, 
		PRECISION=320, REAL=321, ROW=322, SETOF=323, SMALLINT=324, SUBSTRING=325, 
		TIME=326, TIMESTAMP=327, TREAT=328, TRIM=329, VALUES=330, VARCHAR=331, 
		XMLATTRIBUTES=332, XMLCONCAT=333, XMLELEMENT=334, XMLEXISTS=335, XMLFOREST=336, 
		XMLNAMESPACES=337, XMLPARSE=338, XMLPI=339, XMLROOT=340, XMLSERIALIZE=341, 
		XMLTABLE=342, AUTHORIZATION=343, BINARY=344, COLLATION=345, CONCURRENTLY=346, 
		CROSS=347, CURRENT_SCHEMA=348, FREEZE=349, FULL=350, ILIKE=351, INNER=352, 
		IS=353, ISNULL=354, JOIN=355, LEFT=356, LIKE=357, NATURAL=358, NOTNULL=359, 
		OUTER=360, OVERLAPS=361, RIGHT=362, SIMILAR=363, TABLESAMPLE=364, VERBOSE=365, 
		ALL=366, ANALYSE=367, ANALYZE=368, AND=369, ANY=370, ARRAY=371, AS=372, 
		ASC=373, ASYMMETRIC=374, BOTH=375, CASE=376, CAST=377, CHECK=378, COLLATE=379, 
		COLUMN=380, CONSTRAINT=381, CREATE=382, CURRENT_CATALOG=383, CURRENT_DATE=384, 
		CURRENT_ROLE=385, CURRENT_TIME=386, CURRENT_TIMESTAMP=387, CURRENT_USER=388, 
		DEFAULT=389, DEFERRABLE=390, DESC=391, DISTINCT=392, DO=393, ELSE=394, 
		END=395, EXCEPT=396, FALSE=397, FETCH=398, FOR=399, FOREIGN=400, FROM=401, 
		GRANT=402, GROUP=403, HAVING=404, IN=405, INITIALLY=406, INTERSECT=407, 
		INTO=408, LATERAL=409, LEADING=410, LIMIT=411, LOCALTIME=412, LOCALTIMESTAMP=413, 
		NOT=414, NULL=415, OFFSET=416, ON=417, ONLY=418, OR=419, ORDER=420, PLACING=421, 
		PRIMARY=422, REFERENCES=423, RETURNING=424, SELECT=425, SESSION_USER=426, 
		SOME=427, SYMMETRIC=428, TABLE=429, THEN=430, TO=431, TRAILING=432, TRUE=433, 
		UNION=434, UNIQUE=435, USER=436, USING=437, VARIADIC=438, WHEN=439, WHERE=440, 
		WINDOW=441, WITH=442, ALIGNMENT=443, BASETYPE=444, BUFFERS=445, BYPASSRLS=446, 
		CANONICAL=447, CATEGORY=448, COLLATABLE=449, COMBINEFUNC=450, COMMUTATOR=451, 
		CONNECT=452, COSTS=453, CREATEDB=454, CREATEROLE=455, DESERIALFUNC=456, 
		DETERMINISTIC=457, DISABLE_PAGE_SKIPPING=458, ELEMENT=459, EXTENDED=460, 
		FINALFUNC=461, FINALFUNC_EXTRA=462, FINALFUNC_MODIFY=463, FORCE_NOT_NULL=464, 
		FORCE_NULL=465, FORCE_QUOTE=466, FORMAT=467, GETTOKEN=468, HASH=469, HASHES=470, 
		HEADLINE=471, HYPOTHETICAL=472, INDEX_CLEANUP=473, INIT=474, INITCOND=475, 
		INTERNALLENGTH=476, JSON=477, LC_COLLATE=478, LC_CTYPE=479, LEFTARG=480, 
		LEXIZE=481, LEXTYPES=482, LIST=483, LOCALE=484, LOGIN=485, MAIN=486, MERGES=487, 
		MFINALFUNC=488, MFINALFUNC_EXTRA=489, MFINALFUNC_MODIFY=490, MINITCOND=491, 
		MINVFUNC=492, MODULUS=493, MSFUNC=494, MSSPACE=495, MSTYPE=496, NEGATOR=497, 
		NOBYPASSRLS=498, NOCREATEDB=499, NOCREATEROLE=500, NOINHERIT=501, NOLOGIN=502, 
		NOREPLICATION=503, NOSUPERUSER=504, OUTPUT=505, PASSEDBYVALUE=506, PATH=507, 
		PERMISSIVE=508, PLAIN=509, PREFERRED=510, PROVIDER=511, READ_ONLY=512, 
		READ_WRITE=513, RECEIVE=514, REMAINDER=515, REPLICATION=516, RESTRICTED=517, 
		RESTRICTIVE=518, RIGHTARG=519, SAFE=520, SEND=521, SERIALFUNC=522, SETTINGS=523, 
		SFUNC=524, SHAREABLE=525, SKIP_LOCKED=526, SORTOP=527, SSPACE=528, STYPE=529, 
		SUBTYPE_DIFF=530, SUBTYPE_OPCLASS=531, SUBTYPE=532, SUMMARY=533, SUPERUSER=534, 
		TIMING=535, TYPMOD_IN=536, TYPMOD_OUT=537, UNSAFE=538, USAGE=539, VARIABLE=540, 
		YAML=541, ALIAS=542, ASSERT=543, CONSTANT=544, DATATYPE=545, DEBUG=546, 
		DETAIL=547, DIAGNOSTICS=548, ELSEIF=549, ELSIF=550, ERRCODE=551, EXIT=552, 
		EXCEPTION=553, FOREACH=554, GET=555, HINT=556, INFO=557, LOG=558, LOOP=559, 
		MESSAGE=560, NOTICE=561, OPEN=562, PERFORM=563, QUERY=564, RAISE=565, 
		RECORD=566, RETURN=567, REVERSE=568, ROWTYPE=569, SLICE=570, SQLSTATE=571, 
		STACKED=572, WARNING=573, WHILE=574, CAST_EXPRESSION=575, EQUAL=576, COLON=577, 
		SEMI_COLON=578, COMMA=579, NOT_EQUAL=580, LTH=581, LEQ=582, GTH=583, GEQ=584, 
		LEFT_PAREN=585, RIGHT_PAREN=586, PLUS=587, MINUS=588, MULTIPLY=589, DIVIDE=590, 
		MODULAR=591, EXP=592, DOT=593, QUOTE_CHAR=594, DOUBLE_QUOTE=595, DOLLAR=596, 
		LEFT_BRACKET=597, RIGHT_BRACKET=598, EQUAL_GTH=599, COLON_EQUAL=600, LESS_LESS=601, 
		GREATER_GREATER=602, DOUBLE_DOT=603, HASH_SIGN=604, BlockComment=605, 
		LineComment=606, OP_CHARS=607, NUMBER_LITERAL=608, REAL_NUMBER=609, DOLLAR_NUMBER=610, 
		Identifier=611, QuotedIdentifier=612, Character_String_Literal=613, BeginDollarStringConstant=614, 
		Space=615, White_Space=616, New_Line=617, Tab=618, BOM=619, BAD=620, Text_between_Dollar=621, 
		EndDollarStringConstant=622;
	public const int
		RULE_function_body = 0, RULE_function_block = 1, RULE_id_token = 2, RULE_identifier = 3, 
		RULE_start_label = 4, RULE_declarations = 5, RULE_declaration = 6, RULE_type_declaration = 7, 
		RULE_select_stmt = 8, RULE_select_ops = 9, RULE_select_primary = 10, RULE_window_definition = 11, 
		RULE_frame_clause = 12, RULE_frame_bound = 13, RULE_orderby_clause = 14, 
		RULE_sort_specifier_list = 15, RULE_sort_specifier = 16, RULE_null_ordering = 17, 
		RULE_order_specification = 18, RULE_all_op_ref = 19, RULE_all_simple_op = 20, 
		RULE_op_chars = 21, RULE_values_stmt = 22, RULE_values_values = 23, RULE_partition_by_columns = 24, 
		RULE_schema_qualified_name = 25, RULE_select_list = 26, RULE_select_sublist = 27, 
		RULE_col_label = 28, RULE_groupby_clause = 29, RULE_grouping_element_list = 30, 
		RULE_grouping_element = 31, RULE_from_item = 32, RULE_from_primary = 33, 
		RULE_from_function_column_def = 34, RULE_data_type = 35, RULE_array_type = 36, 
		RULE_predefined_type = 37, RULE_schema_qualified_name_nontype = 38, RULE_identifier_nontype = 39, 
		RULE_interval_field = 40, RULE_type_length = 41, RULE_precision_param = 42, 
		RULE_function_call = 43, RULE_xml_function = 44, RULE_xml_table_column = 45, 
		RULE_string_value_function = 46, RULE_date_time_function = 47, RULE_system_function = 48, 
		RULE_cast_specification = 49, RULE_extract_function = 50, RULE_character_string = 51, 
		RULE_function_construct = 52, RULE_filter_clause = 53, RULE_vex_or_named_notation = 54, 
		RULE_pointer = 55, RULE_table_subquery = 56, RULE_names_in_parens = 57, 
		RULE_names_references = 58, RULE_alias_clause = 59, RULE_into_table = 60, 
		RULE_set_qualifier = 61, RULE_with_clause = 62, RULE_with_query = 63, 
		RULE_delete_stmt_for_psql = 64, RULE_update_stmt_for_psql = 65, RULE_update_set = 66, 
		RULE_indirection_identifier = 67, RULE_indirection_list = 68, RULE_indirection = 69, 
		RULE_insert_stmt_for_psql = 70, RULE_conflict_action = 71, RULE_conflict_object = 72, 
		RULE_index_where = 73, RULE_index_sort = 74, RULE_insert_columns = 75, 
		RULE_after_ops = 76, RULE_arguments_list = 77, RULE_collate_identifier = 78, 
		RULE_data_type_dec = 79, RULE_exception_statement = 80, RULE_function_statements = 81, 
		RULE_function_statement = 82, RULE_base_statement = 83, RULE_diagnostic_option = 84, 
		RULE_var = 85, RULE_perform_stmt = 86, RULE_control_statement = 87, RULE_return_stmt = 88, 
		RULE_explain_statement = 89, RULE_explain_query = 90, RULE_create_table_as_statement = 91, 
		RULE_storage_parameter_oid = 92, RULE_with_storage_parameter = 93, RULE_storage_parameter = 94, 
		RULE_storage_parameter_option = 95, RULE_on_commit = 96, RULE_table_space = 97, 
		RULE_if_not_exists = 98, RULE_create_view_statement = 99, RULE_view_columns = 100, 
		RULE_with_check_option = 101, RULE_execute_statement = 102, RULE_declare_statement = 103, 
		RULE_explain_option = 104, RULE_boolean_value = 105, RULE_show_statement = 106, 
		RULE_execute_stmt = 107, RULE_if_statement = 108, RULE_case_statement = 109, 
		RULE_loop_statement = 110, RULE_loop_start = 111, RULE_option = 112, RULE_identifier_list = 113, 
		RULE_transaction_statement = 114, RULE_lock_table = 115, RULE_lock_mode = 116, 
		RULE_only_table_multiply = 117, RULE_cursor_statement = 118, RULE_fetch_move_direction = 119, 
		RULE_signed_number_literal = 120, RULE_sign = 121, RULE_message_statement = 122, 
		RULE_raise_using = 123, RULE_raise_param = 124, RULE_log_level = 125, 
		RULE_data_statement = 126, RULE_notify_stmt = 127, RULE_truncate_stmt = 128, 
		RULE_cascade_restrict = 129, RULE_additional_statement = 130, RULE_copy_statement = 131, 
		RULE_copy_from_statement = 132, RULE_copy_to_statement = 133, RULE_user_name = 134, 
		RULE_copy_option_list = 135, RULE_copy_option = 136, RULE_truth_value = 137, 
		RULE_table_cols_list = 138, RULE_table_cols = 139, RULE_anonymous_block = 140, 
		RULE_analyze_mode = 141, RULE_using_vex = 142, RULE_assign_stmt = 143, 
		RULE_select_stmt_no_parens = 144, RULE_select_ops_no_parens = 145, RULE_vex_b = 146, 
		RULE_op = 147, RULE_value_expression_primary = 148, RULE_datetime_overlaps = 149, 
		RULE_type_coercion = 150, RULE_array_expression = 151, RULE_array_elements = 152, 
		RULE_indirection_var = 153, RULE_dollar_number = 154, RULE_comparison_mod = 155, 
		RULE_case_expression = 156, RULE_unsigned_value_specification = 157, RULE_unsigned_numeric_literal = 158, 
		RULE_type_list = 159, RULE_vex = 160, RULE_tokens_nonreserved = 161, RULE_tokens_nonreserved_except_function_type = 162, 
		RULE_tokens_reserved_except_function_type = 163, RULE_tokens_reserved = 164, 
		RULE_tokens_nonkeyword = 165;
	public static readonly string[] ruleNames = {
		"function_body", "function_block", "id_token", "identifier", "start_label", 
		"declarations", "declaration", "type_declaration", "select_stmt", "select_ops", 
		"select_primary", "window_definition", "frame_clause", "frame_bound", 
		"orderby_clause", "sort_specifier_list", "sort_specifier", "null_ordering", 
		"order_specification", "all_op_ref", "all_simple_op", "op_chars", "values_stmt", 
		"values_values", "partition_by_columns", "schema_qualified_name", "select_list", 
		"select_sublist", "col_label", "groupby_clause", "grouping_element_list", 
		"grouping_element", "from_item", "from_primary", "from_function_column_def", 
		"data_type", "array_type", "predefined_type", "schema_qualified_name_nontype", 
		"identifier_nontype", "interval_field", "type_length", "precision_param", 
		"function_call", "xml_function", "xml_table_column", "string_value_function", 
		"date_time_function", "system_function", "cast_specification", "extract_function", 
		"character_string", "function_construct", "filter_clause", "vex_or_named_notation", 
		"pointer", "table_subquery", "names_in_parens", "names_references", "alias_clause", 
		"into_table", "set_qualifier", "with_clause", "with_query", "delete_stmt_for_psql", 
		"update_stmt_for_psql", "update_set", "indirection_identifier", "indirection_list", 
		"indirection", "insert_stmt_for_psql", "conflict_action", "conflict_object", 
		"index_where", "index_sort", "insert_columns", "after_ops", "arguments_list", 
		"collate_identifier", "data_type_dec", "exception_statement", "function_statements", 
		"function_statement", "base_statement", "diagnostic_option", "var", "perform_stmt", 
		"control_statement", "return_stmt", "explain_statement", "explain_query", 
		"create_table_as_statement", "storage_parameter_oid", "with_storage_parameter", 
		"storage_parameter", "storage_parameter_option", "on_commit", "table_space", 
		"if_not_exists", "create_view_statement", "view_columns", "with_check_option", 
		"execute_statement", "declare_statement", "explain_option", "boolean_value", 
		"show_statement", "execute_stmt", "if_statement", "case_statement", "loop_statement", 
		"loop_start", "option", "identifier_list", "transaction_statement", "lock_table", 
		"lock_mode", "only_table_multiply", "cursor_statement", "fetch_move_direction", 
		"signed_number_literal", "sign", "message_statement", "raise_using", "raise_param", 
		"log_level", "data_statement", "notify_stmt", "truncate_stmt", "cascade_restrict", 
		"additional_statement", "copy_statement", "copy_from_statement", "copy_to_statement", 
		"user_name", "copy_option_list", "copy_option", "truth_value", "table_cols_list", 
		"table_cols", "anonymous_block", "analyze_mode", "using_vex", "assign_stmt", 
		"select_stmt_no_parens", "select_ops_no_parens", "vex_b", "op", "value_expression_primary", 
		"datetime_overlaps", "type_coercion", "array_expression", "array_elements", 
		"indirection_var", "dollar_number", "comparison_mod", "case_expression", 
		"unsigned_value_specification", "unsigned_numeric_literal", "type_list", 
		"vex", "tokens_nonreserved", "tokens_nonreserved_except_function_type", 
		"tokens_reserved_except_function_type", "tokens_reserved", "tokens_nonkeyword"
	};

	private static readonly string[] _LiteralNames = {
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		"'='", "':'", "';'", "','", null, "'<'", "'<='", "'>'", "'>='", "'('", 
		"')'", "'+'", "'-'", "'*'", "'/'", "'%'", "'^'", "'.'", "'''", "'\"'", 
		"'$'", "'['", "']'", "'=>'", "':='", "'<<'", "'>>'", "'..'", "'#'", null, 
		null, null, null, null, null, null, null, null, null, "' '", null, null, 
		"'\u0009'", "'\uFEFF'"
	};
	private static readonly string[] _SymbolicNames = {
		null, "ABORT", "ABSOLUTE", "ACCESS", "ACTION", "ADD", "ADMIN", "AFTER", 
		"AGGREGATE", "ALSO", "ALTER", "ALWAYS", "ASSERTION", "ASSIGNMENT", "AT", 
		"ATTACH", "ATTRIBUTE", "BACKWARD", "BEFORE", "BEGIN", "BY", "CACHE", "CALL", 
		"CALLED", "CASCADE", "CASCADED", "CATALOG", "CHAIN", "CHARACTERISTICS", 
		"CHECKPOINT", "CLASS", "CLOSE", "CLUSTER", "COLUMNS", "COMMENT", "COMMENTS", 
		"COMMIT", "COMMITTED", "CONFIGURATION", "CONFLICT", "CONNECTION", "CONSTRAINTS", 
		"CONTENT", "CONTINUE", "CONVERSION", "COPY", "COST", "CSV", "CUBE", "CURRENT", 
		"CURSOR", "CYCLE", "DATA", "DATABASE", "DAY", "DEALLOCATE", "DECLARE", 
		"DEFAULTS", "DEFERRED", "DEFINER", "DELETE", "DELIMITER", "DELIMITERS", 
		"DEPENDS", "DETACH", "DICTIONARY", "DISABLE", "DISCARD", "DOCUMENT", "DOMAIN", 
		"DOUBLE", "DROP", "EACH", "ENABLE", "ENCODING", "ENCRYPTED", "ENUM", "ESCAPE", 
		"EVENT", "EXCLUDE", "EXCLUDING", "EXCLUSIVE", "EXECUTE", "EXPLAIN", "EXTENSION", 
		"EXTERNAL", "FAMILY", "FILTER", "FIRST", "FOLLOWING", "FORCE", "FORWARD", 
		"FUNCTION", "FUNCTIONS", "GENERATED", "GLOBAL", "GRANTED", "GROUPS", "HANDLER", 
		"HEADER", "HOLD", "HOUR", "IDENTITY", "IF", "IMMEDIATE", "IMMUTABLE", 
		"IMPLICIT", "IMPORT", "INCLUDE", "INCLUDING", "INCREMENT", "INDEX", "INDEXES", 
		"INHERIT", "INHERITS", "INLINE", "INPUT", "INSENSITIVE", "INSERT", "INSTEAD", 
		"INVOKER", "ISOLATION", "KEY", "LABEL", "LANGUAGE", "LARGE", "LAST", "LEAKPROOF", 
		"LEVEL", "LISTEN", "LOAD", "LOCAL", "LOCATION", "LOCK", "LOCKED", "LOGGED", 
		"MAPPING", "MATCH", "MATERIALIZED", "MAXVALUE", "METHOD", "MINUTE", "MINVALUE", 
		"MODE", "MONTH", "MOVE", "NAME", "NAMES", "NEW", "NEXT", "NO", "NOTHING", 
		"NOTIFY", "NOWAIT", "NULLS", "OBJECT", "OF", "OFF", "OIDS", "OLD", "OPERATOR", 
		"OPTION", "OPTIONS", "ORDINALITY", "OTHERS", "OVER", "OVERRIDING", "OWNED", 
		"OWNER", "PARALLEL", "PARSER", "PARTIAL", "PARTITION", "PASSING", "PASSWORD", 
		"PLANS", "POLICY", "PRECEDING", "PREPARE", "PREPARED", "PRESERVE", "PRIOR", 
		"PRIVILEGES", "PROCEDURAL", "PROCEDURE", "PROCEDURES", "PROGRAM", "PUBLICATION", 
		"QUOTE", "RANGE", "READ", "REASSIGN", "RECHECK", "RECURSIVE", "REF", "REFERENCING", 
		"REFRESH", "REINDEX", "RELATIVE", "RELEASE", "RENAME", "REPEATABLE", "REPLACE", 
		"REPLICA", "RESET", "RESTART", "RESTRICT", "RETURNS", "REVOKE", "ROLE", 
		"ROLLBACK", "ROLLUP", "ROUTINE", "ROUTINES", "ROWS", "RULE", "SAVEPOINT", 
		"SCHEMA", "SCHEMAS", "SCROLL", "SEARCH", "SECOND", "SECURITY", "SEQUENCE", 
		"SEQUENCES", "SERIALIZABLE", "SERVER", "SESSION", "SET", "SETS", "SHARE", 
		"SHOW", "SIMPLE", "SKIP_", "SNAPSHOT", "SQL", "STABLE", "STANDALONE", 
		"START", "STATEMENT", "STATISTICS", "STDIN", "STDOUT", "STORAGE", "STORED", 
		"STRICT", "STRIP", "SUBSCRIPTION", "SUPPORT", "SYSID", "SYSTEM", "TABLES", 
		"TABLESPACE", "TEMP", "TEMPLATE", "TEMPORARY", "TEXT", "TIES", "TRANSACTION", 
		"TRANSFORM", "TRIGGER", "TRUNCATE", "TRUSTED", "TYPE", "TYPES", "UNBOUNDED", 
		"UNCOMMITTED", "UNENCRYPTED", "UNKNOWN", "UNLISTEN", "UNLOGGED", "UNTIL", 
		"UPDATE", "VACUUM", "VALID", "VALIDATE", "VALIDATOR", "VALUE", "VARYING", 
		"VERSION", "VIEW", "VIEWS", "VOLATILE", "WHITESPACE", "WITHIN", "WITHOUT", 
		"WORK", "WRAPPER", "WRITE", "XML", "YEAR", "YES", "ZONE", "BETWEEN", "BIGINT", 
		"BIT", "BOOLEAN", "CHAR", "CHARACTER", "COALESCE", "DEC", "DECIMAL", "EXISTS", 
		"EXTRACT", "FLOAT", "GREATEST", "GROUPING", "INOUT", "INT", "INTEGER", 
		"INTERVAL", "LEAST", "NATIONAL", "NCHAR", "NONE", "NULLIF", "NUMERIC", 
		"OUT", "OVERLAY", "POSITION", "PRECISION", "REAL", "ROW", "SETOF", "SMALLINT", 
		"SUBSTRING", "TIME", "TIMESTAMP", "TREAT", "TRIM", "VALUES", "VARCHAR", 
		"XMLATTRIBUTES", "XMLCONCAT", "XMLELEMENT", "XMLEXISTS", "XMLFOREST", 
		"XMLNAMESPACES", "XMLPARSE", "XMLPI", "XMLROOT", "XMLSERIALIZE", "XMLTABLE", 
		"AUTHORIZATION", "BINARY", "COLLATION", "CONCURRENTLY", "CROSS", "CURRENT_SCHEMA", 
		"FREEZE", "FULL", "ILIKE", "INNER", "IS", "ISNULL", "JOIN", "LEFT", "LIKE", 
		"NATURAL", "NOTNULL", "OUTER", "OVERLAPS", "RIGHT", "SIMILAR", "TABLESAMPLE", 
		"VERBOSE", "ALL", "ANALYSE", "ANALYZE", "AND", "ANY", "ARRAY", "AS", "ASC", 
		"ASYMMETRIC", "BOTH", "CASE", "CAST", "CHECK", "COLLATE", "COLUMN", "CONSTRAINT", 
		"CREATE", "CURRENT_CATALOG", "CURRENT_DATE", "CURRENT_ROLE", "CURRENT_TIME", 
		"CURRENT_TIMESTAMP", "CURRENT_USER", "DEFAULT", "DEFERRABLE", "DESC", 
		"DISTINCT", "DO", "ELSE", "END", "EXCEPT", "FALSE", "FETCH", "FOR", "FOREIGN", 
		"FROM", "GRANT", "GROUP", "HAVING", "IN", "INITIALLY", "INTERSECT", "INTO", 
		"LATERAL", "LEADING", "LIMIT", "LOCALTIME", "LOCALTIMESTAMP", "NOT", "NULL", 
		"OFFSET", "ON", "ONLY", "OR", "ORDER", "PLACING", "PRIMARY", "REFERENCES", 
		"RETURNING", "SELECT", "SESSION_USER", "SOME", "SYMMETRIC", "TABLE", "THEN", 
		"TO", "TRAILING", "TRUE", "UNION", "UNIQUE", "USER", "USING", "VARIADIC", 
		"WHEN", "WHERE", "WINDOW", "WITH", "ALIGNMENT", "BASETYPE", "BUFFERS", 
		"BYPASSRLS", "CANONICAL", "CATEGORY", "COLLATABLE", "COMBINEFUNC", "COMMUTATOR", 
		"CONNECT", "COSTS", "CREATEDB", "CREATEROLE", "DESERIALFUNC", "DETERMINISTIC", 
		"DISABLE_PAGE_SKIPPING", "ELEMENT", "EXTENDED", "FINALFUNC", "FINALFUNC_EXTRA", 
		"FINALFUNC_MODIFY", "FORCE_NOT_NULL", "FORCE_NULL", "FORCE_QUOTE", "FORMAT", 
		"GETTOKEN", "HASH", "HASHES", "HEADLINE", "HYPOTHETICAL", "INDEX_CLEANUP", 
		"INIT", "INITCOND", "INTERNALLENGTH", "JSON", "LC_COLLATE", "LC_CTYPE", 
		"LEFTARG", "LEXIZE", "LEXTYPES", "LIST", "LOCALE", "LOGIN", "MAIN", "MERGES", 
		"MFINALFUNC", "MFINALFUNC_EXTRA", "MFINALFUNC_MODIFY", "MINITCOND", "MINVFUNC", 
		"MODULUS", "MSFUNC", "MSSPACE", "MSTYPE", "NEGATOR", "NOBYPASSRLS", "NOCREATEDB", 
		"NOCREATEROLE", "NOINHERIT", "NOLOGIN", "NOREPLICATION", "NOSUPERUSER", 
		"OUTPUT", "PASSEDBYVALUE", "PATH", "PERMISSIVE", "PLAIN", "PREFERRED", 
		"PROVIDER", "READ_ONLY", "READ_WRITE", "RECEIVE", "REMAINDER", "REPLICATION", 
		"RESTRICTED", "RESTRICTIVE", "RIGHTARG", "SAFE", "SEND", "SERIALFUNC", 
		"SETTINGS", "SFUNC", "SHAREABLE", "SKIP_LOCKED", "SORTOP", "SSPACE", "STYPE", 
		"SUBTYPE_DIFF", "SUBTYPE_OPCLASS", "SUBTYPE", "SUMMARY", "SUPERUSER", 
		"TIMING", "TYPMOD_IN", "TYPMOD_OUT", "UNSAFE", "USAGE", "VARIABLE", "YAML", 
		"ALIAS", "ASSERT", "CONSTANT", "DATATYPE", "DEBUG", "DETAIL", "DIAGNOSTICS", 
		"ELSEIF", "ELSIF", "ERRCODE", "EXIT", "EXCEPTION", "FOREACH", "GET", "HINT", 
		"INFO", "LOG", "LOOP", "MESSAGE", "NOTICE", "OPEN", "PERFORM", "QUERY", 
		"RAISE", "RECORD", "RETURN", "REVERSE", "ROWTYPE", "SLICE", "SQLSTATE", 
		"STACKED", "WARNING", "WHILE", "CAST_EXPRESSION", "EQUAL", "COLON", "SEMI_COLON", 
		"COMMA", "NOT_EQUAL", "LTH", "LEQ", "GTH", "GEQ", "LEFT_PAREN", "RIGHT_PAREN", 
		"PLUS", "MINUS", "MULTIPLY", "DIVIDE", "MODULAR", "EXP", "DOT", "QUOTE_CHAR", 
		"DOUBLE_QUOTE", "DOLLAR", "LEFT_BRACKET", "RIGHT_BRACKET", "EQUAL_GTH", 
		"COLON_EQUAL", "LESS_LESS", "GREATER_GREATER", "DOUBLE_DOT", "HASH_SIGN", 
		"BlockComment", "LineComment", "OP_CHARS", "NUMBER_LITERAL", "REAL_NUMBER", 
		"DOLLAR_NUMBER", "Identifier", "QuotedIdentifier", "Character_String_Literal", 
		"BeginDollarStringConstant", "Space", "White_Space", "New_Line", "Tab", 
		"BOM", "BAD", "Text_between_Dollar", "EndDollarStringConstant"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "PlPgSqlParser.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return new string(_serializedATN); } }

	static PlPgSqlParser() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}

		public PlPgSqlParser(ITokenStream input) : this(input, Console.Out, Console.Error) { }

		public PlPgSqlParser(ITokenStream input, TextWriter output, TextWriter errorOutput)
		: base(input, output, errorOutput)
	{
		Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}

	public partial class Function_bodyContext : ParserRuleContext {
		public Function_blockContext function_block() {
			return GetRuleContext<Function_blockContext>(0);
		}
		public ITerminalNode Eof() { return GetToken(PlPgSqlParser.Eof, 0); }
		public ITerminalNode SEMI_COLON() { return GetToken(PlPgSqlParser.SEMI_COLON, 0); }
		public Function_bodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_function_body; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunction_body(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Function_bodyContext function_body() {
		Function_bodyContext _localctx = new Function_bodyContext(Context, State);
		EnterRule(_localctx, 0, RULE_function_body);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 332; function_block();
			State = 334;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==SEMI_COLON) {
				{
				State = 333; Match(SEMI_COLON);
				}
			}

			State = 336; Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Function_blockContext : ParserRuleContext {
		public IdentifierContext end_label;
		public ITerminalNode BEGIN() { return GetToken(PlPgSqlParser.BEGIN, 0); }
		public Function_statementsContext function_statements() {
			return GetRuleContext<Function_statementsContext>(0);
		}
		public Start_labelContext start_label() {
			return GetRuleContext<Start_labelContext>(0);
		}
		public DeclarationsContext declarations() {
			return GetRuleContext<DeclarationsContext>(0);
		}
		public Exception_statementContext exception_statement() {
			return GetRuleContext<Exception_statementContext>(0);
		}
		public ITerminalNode END() { return GetToken(PlPgSqlParser.END, 0); }
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Function_blockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_function_block; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunction_block(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Function_blockContext function_block() {
		Function_blockContext _localctx = new Function_blockContext(Context, State);
		EnterRule(_localctx, 2, RULE_function_block);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 339;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LESS_LESS) {
				{
				State = 338; start_label();
				}
			}

			State = 342;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DECLARE) {
				{
				State = 341; declarations();
				}
			}

			State = 344; Match(BEGIN);
			State = 345; function_statements();
			State = 347;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,3,Context) ) {
			case 1:
				{
				State = 346; exception_statement();
				}
				break;
			}
			State = 350;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,4,Context) ) {
			case 1:
				{
				State = 349; Match(END);
				}
				break;
			}
			State = 353;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,5,Context) ) {
			case 1:
				{
				State = 352; _localctx.end_label = identifier();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Id_tokenContext : ParserRuleContext {
		public ITerminalNode Identifier() { return GetToken(PlPgSqlParser.Identifier, 0); }
		public ITerminalNode QuotedIdentifier() { return GetToken(PlPgSqlParser.QuotedIdentifier, 0); }
		public Tokens_nonkeywordContext tokens_nonkeyword() {
			return GetRuleContext<Tokens_nonkeywordContext>(0);
		}
		public Id_tokenContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_id_token; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitId_token(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Id_tokenContext id_token() {
		Id_tokenContext _localctx = new Id_tokenContext(Context, State);
		EnterRule(_localctx, 4, RULE_id_token);
		try {
			State = 358;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Identifier:
				EnterOuterAlt(_localctx, 1);
				{
				State = 355; Match(Identifier);
				}
				break;
			case QuotedIdentifier:
				EnterOuterAlt(_localctx, 2);
				{
				State = 356; Match(QuotedIdentifier);
				}
				break;
			case ALIGNMENT:
			case BASETYPE:
			case BUFFERS:
			case BYPASSRLS:
			case CANONICAL:
			case CATEGORY:
			case COLLATABLE:
			case COMBINEFUNC:
			case COMMUTATOR:
			case CONNECT:
			case COSTS:
			case CREATEDB:
			case CREATEROLE:
			case DESERIALFUNC:
			case DETERMINISTIC:
			case DISABLE_PAGE_SKIPPING:
			case ELEMENT:
			case EXTENDED:
			case FINALFUNC:
			case FINALFUNC_EXTRA:
			case FINALFUNC_MODIFY:
			case FORCE_NOT_NULL:
			case FORCE_NULL:
			case FORCE_QUOTE:
			case FORMAT:
			case GETTOKEN:
			case HASH:
			case HASHES:
			case HEADLINE:
			case HYPOTHETICAL:
			case INDEX_CLEANUP:
			case INIT:
			case INITCOND:
			case INTERNALLENGTH:
			case JSON:
			case LC_COLLATE:
			case LC_CTYPE:
			case LEFTARG:
			case LEXIZE:
			case LEXTYPES:
			case LIST:
			case LOCALE:
			case LOGIN:
			case MAIN:
			case MERGES:
			case MFINALFUNC:
			case MFINALFUNC_EXTRA:
			case MFINALFUNC_MODIFY:
			case MINITCOND:
			case MINVFUNC:
			case MODULUS:
			case MSFUNC:
			case MSSPACE:
			case MSTYPE:
			case NEGATOR:
			case NOBYPASSRLS:
			case NOCREATEDB:
			case NOCREATEROLE:
			case NOINHERIT:
			case NOLOGIN:
			case NOREPLICATION:
			case NOSUPERUSER:
			case OUTPUT:
			case PASSEDBYVALUE:
			case PATH:
			case PERMISSIVE:
			case PLAIN:
			case PREFERRED:
			case PROVIDER:
			case READ_ONLY:
			case READ_WRITE:
			case RECEIVE:
			case REMAINDER:
			case REPLICATION:
			case RESTRICTED:
			case RESTRICTIVE:
			case RIGHTARG:
			case SAFE:
			case SEND:
			case SERIALFUNC:
			case SETTINGS:
			case SFUNC:
			case SHAREABLE:
			case SKIP_LOCKED:
			case SORTOP:
			case SSPACE:
			case STYPE:
			case SUBTYPE_DIFF:
			case SUBTYPE_OPCLASS:
			case SUBTYPE:
			case SUMMARY:
			case SUPERUSER:
			case TIMING:
			case TYPMOD_IN:
			case TYPMOD_OUT:
			case UNSAFE:
			case USAGE:
			case VARIABLE:
			case YAML:
			case ALIAS:
			case ASSERT:
			case CONSTANT:
			case DATATYPE:
			case DEBUG:
			case DETAIL:
			case DIAGNOSTICS:
			case ELSEIF:
			case ELSIF:
			case ERRCODE:
			case EXIT:
			case EXCEPTION:
			case FOREACH:
			case GET:
			case HINT:
			case INFO:
			case LOG:
			case LOOP:
			case MESSAGE:
			case NOTICE:
			case OPEN:
			case PERFORM:
			case QUERY:
			case RAISE:
			case RECORD:
			case RETURN:
			case REVERSE:
			case ROWTYPE:
			case SLICE:
			case SQLSTATE:
			case STACKED:
			case WARNING:
			case WHILE:
				EnterOuterAlt(_localctx, 3);
				{
				State = 357; tokens_nonkeyword();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierContext : ParserRuleContext {
		public Id_tokenContext id_token() {
			return GetRuleContext<Id_tokenContext>(0);
		}
		public Tokens_nonreservedContext tokens_nonreserved() {
			return GetRuleContext<Tokens_nonreservedContext>(0);
		}
		public Tokens_nonreserved_except_function_typeContext tokens_nonreserved_except_function_type() {
			return GetRuleContext<Tokens_nonreserved_except_function_typeContext>(0);
		}
		public IdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifier; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierContext identifier() {
		IdentifierContext _localctx = new IdentifierContext(Context, State);
		EnterRule(_localctx, 6, RULE_identifier);
		try {
			State = 363;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ALIGNMENT:
			case BASETYPE:
			case BUFFERS:
			case BYPASSRLS:
			case CANONICAL:
			case CATEGORY:
			case COLLATABLE:
			case COMBINEFUNC:
			case COMMUTATOR:
			case CONNECT:
			case COSTS:
			case CREATEDB:
			case CREATEROLE:
			case DESERIALFUNC:
			case DETERMINISTIC:
			case DISABLE_PAGE_SKIPPING:
			case ELEMENT:
			case EXTENDED:
			case FINALFUNC:
			case FINALFUNC_EXTRA:
			case FINALFUNC_MODIFY:
			case FORCE_NOT_NULL:
			case FORCE_NULL:
			case FORCE_QUOTE:
			case FORMAT:
			case GETTOKEN:
			case HASH:
			case HASHES:
			case HEADLINE:
			case HYPOTHETICAL:
			case INDEX_CLEANUP:
			case INIT:
			case INITCOND:
			case INTERNALLENGTH:
			case JSON:
			case LC_COLLATE:
			case LC_CTYPE:
			case LEFTARG:
			case LEXIZE:
			case LEXTYPES:
			case LIST:
			case LOCALE:
			case LOGIN:
			case MAIN:
			case MERGES:
			case MFINALFUNC:
			case MFINALFUNC_EXTRA:
			case MFINALFUNC_MODIFY:
			case MINITCOND:
			case MINVFUNC:
			case MODULUS:
			case MSFUNC:
			case MSSPACE:
			case MSTYPE:
			case NEGATOR:
			case NOBYPASSRLS:
			case NOCREATEDB:
			case NOCREATEROLE:
			case NOINHERIT:
			case NOLOGIN:
			case NOREPLICATION:
			case NOSUPERUSER:
			case OUTPUT:
			case PASSEDBYVALUE:
			case PATH:
			case PERMISSIVE:
			case PLAIN:
			case PREFERRED:
			case PROVIDER:
			case READ_ONLY:
			case READ_WRITE:
			case RECEIVE:
			case REMAINDER:
			case REPLICATION:
			case RESTRICTED:
			case RESTRICTIVE:
			case RIGHTARG:
			case SAFE:
			case SEND:
			case SERIALFUNC:
			case SETTINGS:
			case SFUNC:
			case SHAREABLE:
			case SKIP_LOCKED:
			case SORTOP:
			case SSPACE:
			case STYPE:
			case SUBTYPE_DIFF:
			case SUBTYPE_OPCLASS:
			case SUBTYPE:
			case SUMMARY:
			case SUPERUSER:
			case TIMING:
			case TYPMOD_IN:
			case TYPMOD_OUT:
			case UNSAFE:
			case USAGE:
			case VARIABLE:
			case YAML:
			case ALIAS:
			case ASSERT:
			case CONSTANT:
			case DATATYPE:
			case DEBUG:
			case DETAIL:
			case DIAGNOSTICS:
			case ELSEIF:
			case ELSIF:
			case ERRCODE:
			case EXIT:
			case EXCEPTION:
			case FOREACH:
			case GET:
			case HINT:
			case INFO:
			case LOG:
			case LOOP:
			case MESSAGE:
			case NOTICE:
			case OPEN:
			case PERFORM:
			case QUERY:
			case RAISE:
			case RECORD:
			case RETURN:
			case REVERSE:
			case ROWTYPE:
			case SLICE:
			case SQLSTATE:
			case STACKED:
			case WARNING:
			case WHILE:
			case Identifier:
			case QuotedIdentifier:
				EnterOuterAlt(_localctx, 1);
				{
				State = 360; id_token();
				}
				break;
			case ABORT:
			case ABSOLUTE:
			case ACCESS:
			case ACTION:
			case ADD:
			case ADMIN:
			case AFTER:
			case AGGREGATE:
			case ALSO:
			case ALTER:
			case ALWAYS:
			case ASSERTION:
			case ASSIGNMENT:
			case AT:
			case ATTACH:
			case ATTRIBUTE:
			case BACKWARD:
			case BEFORE:
			case BEGIN:
			case BY:
			case CACHE:
			case CALL:
			case CALLED:
			case CASCADE:
			case CASCADED:
			case CATALOG:
			case CHAIN:
			case CHARACTERISTICS:
			case CHECKPOINT:
			case CLASS:
			case CLOSE:
			case CLUSTER:
			case COLUMNS:
			case COMMENT:
			case COMMENTS:
			case COMMIT:
			case COMMITTED:
			case CONFIGURATION:
			case CONFLICT:
			case CONNECTION:
			case CONSTRAINTS:
			case CONTENT:
			case CONTINUE:
			case CONVERSION:
			case COPY:
			case COST:
			case CSV:
			case CUBE:
			case CURRENT:
			case CURSOR:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DAY:
			case DEALLOCATE:
			case DECLARE:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DELIMITER:
			case DELIMITERS:
			case DEPENDS:
			case DETACH:
			case DICTIONARY:
			case DISABLE:
			case DISCARD:
			case DOCUMENT:
			case DOMAIN:
			case DOUBLE:
			case DROP:
			case EACH:
			case ENABLE:
			case ENCODING:
			case ENCRYPTED:
			case ENUM:
			case ESCAPE:
			case EVENT:
			case EXCLUDE:
			case EXCLUDING:
			case EXCLUSIVE:
			case EXECUTE:
			case EXPLAIN:
			case EXTENSION:
			case EXTERNAL:
			case FAMILY:
			case FILTER:
			case FIRST:
			case FOLLOWING:
			case FORCE:
			case FORWARD:
			case FUNCTION:
			case FUNCTIONS:
			case GENERATED:
			case GLOBAL:
			case GRANTED:
			case GROUPS:
			case HANDLER:
			case HEADER:
			case HOLD:
			case HOUR:
			case IDENTITY:
			case IF:
			case IMMEDIATE:
			case IMMUTABLE:
			case IMPLICIT:
			case IMPORT:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDEX:
			case INDEXES:
			case INHERIT:
			case INHERITS:
			case INLINE:
			case INPUT:
			case INSENSITIVE:
			case INSERT:
			case INSTEAD:
			case INVOKER:
			case ISOLATION:
			case KEY:
			case LABEL:
			case LANGUAGE:
			case LARGE:
			case LAST:
			case LEAKPROOF:
			case LEVEL:
			case LISTEN:
			case LOAD:
			case LOCAL:
			case LOCATION:
			case LOCK:
			case LOCKED:
			case LOGGED:
			case MAPPING:
			case MATCH:
			case MATERIALIZED:
			case MAXVALUE:
			case METHOD:
			case MINUTE:
			case MINVALUE:
			case MODE:
			case MONTH:
			case MOVE:
			case NAME:
			case NAMES:
			case NEW:
			case NEXT:
			case NO:
			case NOTHING:
			case NOTIFY:
			case NOWAIT:
			case NULLS:
			case OBJECT:
			case OF:
			case OFF:
			case OIDS:
			case OLD:
			case OPERATOR:
			case OPTION:
			case OPTIONS:
			case ORDINALITY:
			case OTHERS:
			case OVER:
			case OVERRIDING:
			case OWNED:
			case OWNER:
			case PARALLEL:
			case PARSER:
			case PARTIAL:
			case PARTITION:
			case PASSING:
			case PASSWORD:
			case PLANS:
			case POLICY:
			case PRECEDING:
			case PREPARE:
			case PREPARED:
			case PRESERVE:
			case PRIOR:
			case PRIVILEGES:
			case PROCEDURAL:
			case PROCEDURE:
			case PROCEDURES:
			case PROGRAM:
			case PUBLICATION:
			case QUOTE:
			case RANGE:
			case READ:
			case REASSIGN:
			case RECHECK:
			case RECURSIVE:
			case REF:
			case REFERENCING:
			case REFRESH:
			case REINDEX:
			case RELATIVE:
			case RELEASE:
			case RENAME:
			case REPEATABLE:
			case REPLACE:
			case REPLICA:
			case RESET:
			case RESTART:
			case RESTRICT:
			case RETURNS:
			case REVOKE:
			case ROLE:
			case ROLLBACK:
			case ROLLUP:
			case ROUTINE:
			case ROUTINES:
			case ROWS:
			case RULE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMAS:
			case SCROLL:
			case SEARCH:
			case SECOND:
			case SECURITY:
			case SEQUENCE:
			case SEQUENCES:
			case SERIALIZABLE:
			case SERVER:
			case SESSION:
			case SET:
			case SETS:
			case SHARE:
			case SHOW:
			case SIMPLE:
			case SKIP_:
			case SNAPSHOT:
			case SQL:
			case STABLE:
			case STANDALONE:
			case START:
			case STATEMENT:
			case STATISTICS:
			case STDIN:
			case STDOUT:
			case STORAGE:
			case STORED:
			case STRICT:
			case STRIP:
			case SUBSCRIPTION:
			case SUPPORT:
			case SYSID:
			case SYSTEM:
			case TABLES:
			case TABLESPACE:
			case TEMP:
			case TEMPLATE:
			case TEMPORARY:
			case TEXT:
			case TIES:
			case TRANSACTION:
			case TRANSFORM:
			case TRIGGER:
			case TRUNCATE:
			case TRUSTED:
			case TYPE:
			case TYPES:
			case UNBOUNDED:
			case UNCOMMITTED:
			case UNENCRYPTED:
			case UNKNOWN:
			case UNLISTEN:
			case UNLOGGED:
			case UNTIL:
			case UPDATE:
			case VACUUM:
			case VALID:
			case VALIDATE:
			case VALIDATOR:
			case VALUE:
			case VARYING:
			case VERSION:
			case VIEW:
			case VIEWS:
			case VOLATILE:
			case WHITESPACE:
			case WITHIN:
			case WITHOUT:
			case WORK:
			case WRAPPER:
			case WRITE:
			case XML:
			case YEAR:
			case YES:
			case ZONE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 361; tokens_nonreserved();
				}
				break;
			case BETWEEN:
			case BIGINT:
			case BIT:
			case BOOLEAN:
			case CHAR:
			case CHARACTER:
			case COALESCE:
			case DEC:
			case DECIMAL:
			case EXISTS:
			case EXTRACT:
			case FLOAT:
			case GREATEST:
			case GROUPING:
			case INOUT:
			case INT:
			case INTEGER:
			case INTERVAL:
			case LEAST:
			case NATIONAL:
			case NCHAR:
			case NONE:
			case NULLIF:
			case NUMERIC:
			case OUT:
			case OVERLAY:
			case POSITION:
			case PRECISION:
			case REAL:
			case ROW:
			case SETOF:
			case SMALLINT:
			case SUBSTRING:
			case TIME:
			case TIMESTAMP:
			case TREAT:
			case TRIM:
			case VALUES:
			case VARCHAR:
			case XMLATTRIBUTES:
			case XMLCONCAT:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
				EnterOuterAlt(_localctx, 3);
				{
				State = 362; tokens_nonreserved_except_function_type();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Start_labelContext : ParserRuleContext {
		public ITerminalNode LESS_LESS() { return GetToken(PlPgSqlParser.LESS_LESS, 0); }
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ITerminalNode GREATER_GREATER() { return GetToken(PlPgSqlParser.GREATER_GREATER, 0); }
		public Start_labelContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_start_label; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStart_label(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Start_labelContext start_label() {
		Start_labelContext _localctx = new Start_labelContext(Context, State);
		EnterRule(_localctx, 8, RULE_start_label);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 365; Match(LESS_LESS);
			State = 366; identifier();
			State = 367; Match(GREATER_GREATER);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeclarationsContext : ParserRuleContext {
		public ITerminalNode DECLARE() { return GetToken(PlPgSqlParser.DECLARE, 0); }
		public DeclarationContext[] declaration() {
			return GetRuleContexts<DeclarationContext>();
		}
		public DeclarationContext declaration(int i) {
			return GetRuleContext<DeclarationContext>(i);
		}
		public DeclarationsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_declarations; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeclarations(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DeclarationsContext declarations() {
		DeclarationsContext _localctx = new DeclarationsContext(Context, State);
		EnterRule(_localctx, 10, RULE_declarations);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 369; Match(DECLARE);
			State = 373;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,8,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 370; declaration();
					}
					} 
				}
				State = 375;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,8,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeclarationContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Type_declarationContext type_declaration() {
			return GetRuleContext<Type_declarationContext>(0);
		}
		public ITerminalNode SEMI_COLON() { return GetToken(PlPgSqlParser.SEMI_COLON, 0); }
		public ITerminalNode[] DECLARE() { return GetTokens(PlPgSqlParser.DECLARE); }
		public ITerminalNode DECLARE(int i) {
			return GetToken(PlPgSqlParser.DECLARE, i);
		}
		public DeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_declaration; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeclaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DeclarationContext declaration() {
		DeclarationContext _localctx = new DeclarationContext(Context, State);
		EnterRule(_localctx, 12, RULE_declaration);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 379;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,9,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 376; Match(DECLARE);
					}
					} 
				}
				State = 381;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,9,Context);
			}
			State = 382; identifier();
			State = 383; type_declaration();
			State = 384; Match(SEMI_COLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Type_declarationContext : ParserRuleContext {
		public Data_type_decContext data_type_dec() {
			return GetRuleContext<Data_type_decContext>(0);
		}
		public ITerminalNode CONSTANT() { return GetToken(PlPgSqlParser.CONSTANT, 0); }
		public Collate_identifierContext collate_identifier() {
			return GetRuleContext<Collate_identifierContext>(0);
		}
		public ITerminalNode NOT() { return GetToken(PlPgSqlParser.NOT, 0); }
		public ITerminalNode NULL() { return GetToken(PlPgSqlParser.NULL, 0); }
		public VexContext vex() {
			return GetRuleContext<VexContext>(0);
		}
		public ITerminalNode DEFAULT() { return GetToken(PlPgSqlParser.DEFAULT, 0); }
		public ITerminalNode COLON_EQUAL() { return GetToken(PlPgSqlParser.COLON_EQUAL, 0); }
		public ITerminalNode EQUAL() { return GetToken(PlPgSqlParser.EQUAL, 0); }
		public ITerminalNode ALIAS() { return GetToken(PlPgSqlParser.ALIAS, 0); }
		public ITerminalNode FOR() { return GetToken(PlPgSqlParser.FOR, 0); }
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ITerminalNode DOLLAR_NUMBER() { return GetToken(PlPgSqlParser.DOLLAR_NUMBER, 0); }
		public ITerminalNode CURSOR() { return GetToken(PlPgSqlParser.CURSOR, 0); }
		public Select_stmtContext select_stmt() {
			return GetRuleContext<Select_stmtContext>(0);
		}
		public ITerminalNode IS() { return GetToken(PlPgSqlParser.IS, 0); }
		public ITerminalNode SCROLL() { return GetToken(PlPgSqlParser.SCROLL, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlPgSqlParser.LEFT_PAREN, 0); }
		public Arguments_listContext arguments_list() {
			return GetRuleContext<Arguments_listContext>(0);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlPgSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode NO() { return GetToken(PlPgSqlParser.NO, 0); }
		public Type_declarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type_declaration; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType_declaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Type_declarationContext type_declaration() {
		Type_declarationContext _localctx = new Type_declarationContext(Context, State);
		EnterRule(_localctx, 14, RULE_type_declaration);
		int _la;
		try {
			State = 422;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,18,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 387;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,10,Context) ) {
				case 1:
					{
					State = 386; Match(CONSTANT);
					}
					break;
				}
				State = 389; data_type_dec();
				State = 391;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COLLATE) {
					{
					State = 390; collate_identifier();
					}
				}

				State = 395;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==NOT) {
					{
					State = 393; Match(NOT);
					State = 394; Match(NULL);
					}
				}

				State = 399;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DEFAULT || _la==EQUAL || _la==COLON_EQUAL) {
					{
					State = 397;
					_la = TokenStream.LA(1);
					if ( !(_la==DEFAULT || _la==EQUAL || _la==COLON_EQUAL) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					State = 398; vex(0);
					}
				}

				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 401; Match(ALIAS);
				State = 402; Match(FOR);
				State = 405;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case ABORT:
				case ABSOLUTE:
				case ACCESS:
				case ACTION:
				case ADD:
				case ADMIN:
				case AFTER:
				case AGGREGATE:
				case ALSO:
				case ALTER:
				case ALWAYS:
				case ASSERTION:
				case ASSIGNMENT:
				case AT:
				case ATTACH:
				case ATTRIBUTE:
				case BACKWARD:
				case BEFORE:
				case BEGIN:
				case BY:
				case CACHE:
				case CALL:
				case CALLED:
				case CASCADE:
				case CASCADED:
				case CATALOG:
				case CHAIN:
				case CHARACTERISTICS:
				case CHECKPOINT:
				case CLASS:
				case CLOSE:
				case CLUSTER:
				case COLUMNS:
				case COMMENT:
				case COMMENTS:
				case COMMIT:
				case COMMITTED:
				case CONFIGURATION:
				case CONFLICT:
				case CONNECTION:
				case CONSTRAINTS:
				case CONTENT:
				case CONTINUE:
				case CONVERSION:
				case COPY:
				case COST:
				case CSV:
				case CUBE:
				case CURRENT:
				case CURSOR:
				case CYCLE:
				case DATA:
				case DATABASE:
				case DAY:
				case DEALLOCATE:
				case DECLARE:
				case DEFAULTS:
				case DEFERRED:
				case DEFINER:
				case DELETE:
				case DELIMITER:
				case DELIMITERS:
				case DEPENDS:
				case DETACH:
				case DICTIONARY:
				case DISABLE:
				case DISCARD:
				case DOCUMENT:
				case DOMAIN:
				case DOUBLE:
				case DROP:
				case EACH:
				case ENABLE:
				case ENCODING:
				case ENCRYPTED:
				case ENUM:
				case ESCAPE:
				case EVENT:
				case EXCLUDE:
				case EXCLUDING:
				case EXCLUSIVE:
				case EXECUTE:
				case EXPLAIN:
				case EXTENSION:
				case EXTERNAL:
				case FAMILY:
				case FILTER:
				case FIRST:
				case FOLLOWING:
				case FORCE:
				case FORWARD:
				case FUNCTION:
				case FUNCTIONS:
				case GENERATED:
				case GLOBAL:
				case GRANTED:
				case GROUPS:
				case HANDLER:
				case HEADER:
				case HOLD:
				case HOUR:
				case IDENTITY:
				case IF:
				case IMMEDIATE:
				case IMMUTABLE:
				case IMPLICIT:
				case IMPORT:
				case INCLUDE:
				case INCLUDING:
				case INCREMENT:
				case INDEX:
				case INDEXES:
				case INHERIT:
				case INHERITS:
				case INLINE:
				case INPUT:
				case INSENSITIVE:
				case INSERT:
				case INSTEAD:
				case INVOKER:
				case ISOLATION:
				case KEY:
				case LABEL:
				case LANGUAGE:
				case LARGE:
				case LAST:
				case LEAKPROOF:
				case LEVEL:
				case LISTEN:
				case LOAD:
				case LOCAL:
				case LOCATION:
				case LOCK:
				case LOCKED:
				case LOGGED:
				case MAPPING:
				case MATCH:
				case MATERIALIZED:
				case MAXVALUE:
				case METHOD:
				case MINUTE:
				case MINVALUE:
				case MODE:
				case MONTH:
				case MOVE:
				case NAME:
				case NAMES:
				case NEW:
				case NEXT:
				case NO:
				case NOTHING:
				case NOTIFY:
				case NOWAIT:
				case NULLS:
				case OBJECT:
				case OF:
				case OFF:
				case OIDS:
				case OLD:
				case OPERATOR:
				case OPTION:
				case OPTIONS:
				case ORDINALITY:
				case OTHERS:
				case OVER:
				case OVERRIDING:
				case OWNED:
				case OWNER:
				case PARALLEL:
				case PARSER:
				case PARTIAL:
				case PARTITION:
				case PASSING:
				case PASSWORD:
				case PLANS:
				case POLICY:
				case PRECEDING:
				case PREPARE:
				case PREPARED:
				case PRESERVE:
				case PRIOR:
				case PRIVILEGES:
				case PROCEDURAL:
				case PROCEDURE:
				case PROCEDURES:
				case PROGRAM:
				case PUBLICATION:
				case QUOTE:
				case RANGE:
				case READ:
				case REASSIGN:
				case RECHECK:
				case RECURSIVE:
				case REF:
				case REFERENCING:
				case REFRESH:
				case REINDEX:
				case RELATIVE:
				case RELEASE:
				case RENAME:
				case REPEATABLE:
				case REPLACE:
				case REPLICA:
				case RESET:
				case RESTART:
				case RESTRICT:
				case RETURNS:
				case REVOKE:
				case ROLE:
				case ROLLBACK:
				case ROLLUP:
				case ROUTINE:
				case ROUTINES:
				case ROWS:
				case RULE:
				case SAVEPOINT:
				case SCHEMA:
				case SCHEMAS:
				case SCROLL:
				case SEARCH:
				case SECOND:
				case SECURITY:
				case SEQUENCE:
				case SEQUENCES:
				case SERIALIZABLE:
				case SERVER:
				case SESSION:
				case SET:
				case SETS:
				case SHARE:
				case SHOW:
				case SIMPLE:
				case SKIP_:
				case SNAPSHOT:
				case SQL:
				case STABLE:
				case STANDALONE:
				case START:
				case STATEMENT:
				case STATISTICS:
				case STDIN:
				case STDOUT:
				case STORAGE:
				case STORED:
				case STRICT:
				case STRIP:
				case SUBSCRIPTION:
				case SUPPORT:
				case SYSID:
				case SYSTEM:
				case TABLES:
				case TABLESPACE:
				case TEMP:
				case TEMPLATE:
				case TEMPORARY:
				case TEXT:
				case TIES:
				case TRANSACTION:
				case TRANSFORM:
				case TRIGGER:
				case TRUNCATE:
				case TRUSTED:
				case TYPE:
				case TYPES:
				case UNBOUNDED:
				case UNCOMMITTED:
				case UNENCRYPTED:
				case UNKNOWN:
				case UNLISTEN:
				case UNLOGGED:
				case UNTIL:
				case UPDATE:
				case VACUUM:
				case VALID:
				case VALIDATE:
				case VALIDATOR:
				case VALUE:
				case VARYING:
				case VERSION:
				case VIEW:
				case VIEWS:
				case VOLATILE:
				case WHITESPACE:
				case WITHIN:
				case WITHOUT:
				case WORK:
				case WRAPPER:
				case WRITE:
				case XML:
				case YEAR:
				case YES:
				case ZONE:
				case BETWEEN:
				case BIGINT:
				case BIT:
				case BOOLEAN:
				case CHAR:
				case CHARACTER:
				case COALESCE:
				case DEC:
				case DECIMAL:
				case EXISTS:
				case EXTRACT:
				case FLOAT:
				case GREATEST:
				case GROUPING:
				case INOUT:
				case INT:
				case INTEGER:
				case INTERVAL:
				case LEAST:
				case NATIONAL:
				case NCHAR:
				case NONE:
				case NULLIF:
				case NUMERIC:
				case OUT:
				case OVERLAY:
				case POSITION:
				case PRECISION:
				case REAL:
				case ROW:
				case SETOF:
				case SMALLINT:
				case SUBSTRING:
				case TIME:
				case TIMESTAMP:
				case TREAT:
				case TRIM:
				case VALUES:
				case VARCHAR:
				case XMLATTRIBUTES:
				case XMLCONCAT:
				case XMLELEMENT:
				case XMLEXISTS:
				case XMLFOREST:
				case XMLNAMESPACES:
				case XMLPARSE:
				case XMLPI:
				case XMLROOT:
				case XMLSERIALIZE:
				case XMLTABLE:
				case ALIGNMENT:
				case BASETYPE:
				case BUFFERS:
				case BYPASSRLS:
				case CANONICAL:
				case CATEGORY:
				case COLLATABLE:
				case COMBINEFUNC:
				case COMMUTATOR:
				case CONNECT:
				case COSTS:
				case CREATEDB:
				case CREATEROLE:
				case DESERIALFUNC:
				case DETERMINISTIC:
				case DISABLE_PAGE_SKIPPING:
				case ELEMENT:
				case EXTENDED:
				case FINALFUNC:
				case FINALFUNC_EXTRA:
				case FINALFUNC_MODIFY:
				case FORCE_NOT_NULL:
				case FORCE_NULL:
				case FORCE_QUOTE:
				case FORMAT:
				case GETTOKEN:
				case HASH:
				case HASHES:
				case HEADLINE:
				case HYPOTHETICAL:
				case INDEX_CLEANUP:
				case INIT:
				case INITCOND:
				case INTERNALLENGTH:
				case JSON:
				case LC_COLLATE:
				case LC_CTYPE:
				case LEFTARG:
				case LEXIZE:
				case LEXTYPES:
				case LIST:
				case LOCALE:
				case LOGIN:
				case MAIN:
				case MERGES:
				case MFINALFUNC:
				case MFINALFUNC_EXTRA:
				case MFINALFUNC_MODIFY:
				case MINITCOND:
				case MINVFUNC:
				case MODULUS:
				case MSFUNC:
				case MSSPACE:
				case MSTYPE:
				case NEGATOR:
				case NOBYPASSRLS:
				case NOCREATEDB:
				case NOCREATEROLE:
				case NOINHERIT:
				case NOLOGIN:
				case NOREPLICATION:
				case NOSUPERUSER:
				case OUTPUT:
				case PASSEDBYVALUE:
				case PATH:
				case PERMISSIVE:
				case PLAIN:
				case PREFERRED:
				case PROVIDER:
				case READ_ONLY:
				case READ_WRITE:
				case RECEIVE:
				case REMAINDER:
				case REPLICATION:
				case RESTRICTED:
				case RESTRICTIVE:
				case RIGHTARG:
				case SAFE:
				case SEND:
				case SERIALFUNC:
				case SETTINGS:
				case SFUNC:
				case SHAREABLE:
				case SKIP_LOCKED:
				case SORTOP:
				case SSPACE:
				case STYPE:
				case SUBTYPE_DIFF:
				case SUBTYPE_OPCLASS:
				case SUBTYPE:
				case SUMMARY:
				case SUPERUSER:
				case TIMING:
				case TYPMOD_IN:
				case TYPMOD_OUT:
				case UNSAFE:
				case USAGE:
				case VARIABLE:
				case YAML:
				case ALIAS:
				case ASSERT:
				case CONSTANT:
				case DATATYPE:
				case DEBUG:
				case DETAIL:
				case DIAGNOSTICS:
				case ELSEIF:
				case ELSIF:
				case ERRCODE:
				case EXIT:
				case EXCEPTION:
				case FOREACH:
				case GET:
				case HINT:
				case INFO:
				case LOG:
				case LOOP:
				case MESSAGE:
				case NOTICE:
				case OPEN:
				case PERFORM:
				case QUERY:
				case RAISE:
				case RECORD:
				case RETURN:
				case REVERSE:
				case ROWTYPE:
				case SLICE:
				case SQLSTATE:
				case STACKED:
				case WARNING:
				case WHILE:
				case Identifier:
				case QuotedIdentifier:
					{
					State = 403; identifier();
					}
					break;
				case DOLLAR_NUMBER:
					{
					State = 404; Match(DOLLAR_NUMBER);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 411;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==NO || _la==SCROLL) {
					{
					State = 408;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==NO) {
						{
						State = 407; Match(NO);
						}
					}

					State = 410; Match(SCROLL);
					}
				}

				State = 413; Match(CURSOR);
				State = 418;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LEFT_PAREN) {
					{
					State = 414; Match(LEFT_PAREN);
					State = 415; arguments_list();
					State = 416; Match(RIGHT_PAREN);
					}
				}

				State = 420;
				_la = TokenStream.LA(1);
				if ( !(_la==IS || _la==FOR) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 421; select_stmt();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Select_stmtContext : ParserRuleContext {
		public Select_opsContext select_ops() {
			return GetRuleContext<Select_opsContext>(0);
		}
		public With_clauseContext with_clause() {
			return GetRuleContext<With_clauseContext>(0);
		}
		public After_opsContext[] after_ops() {
			return GetRuleContexts<After_opsContext>();
		}
		public After_opsContext after_ops(int i) {
			return GetRuleContext<After_opsContext>(i);
		}
		public Select_stmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_select_stmt; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSelect_stmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Select_stmtContext select_stmt() {
		Select_stmtContext _localctx = new Select_stmtContext(Context, State);
		EnterRule(_localctx, 16, RULE_select_stmt);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 425;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WITH) {
				{
				State = 424; with_clause();
				}
			}

			State = 427; select_ops(0);
			State = 431;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,20,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 428; after_ops();
					}
					} 
				}
				State = 433;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,20,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Select_opsContext : ParserRuleContext {
		public ITerminalNode LEFT_PAREN() { return GetToken(PlPgSqlParser.LEFT_PAREN, 0); }
		public Select_stmtContext select_stmt() {
			return GetRuleContext<Select_stmtContext>(0);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlPgSqlParser.RIGHT_PAREN, 0); }
		public Select_primaryContext select_primary() {
			return GetRuleContext<Select_primaryContext>(0);
		}
		public Select_opsContext[] select_ops() {
			return GetRuleContexts<Select_opsContext>();
		}
		public Select_opsContext select_ops(int i) {
			return GetRuleContext<Select_opsContext>(i);
		}
		public ITerminalNode INTERSECT() { return GetToken(PlPgSqlParser.INTERSECT, 0); }
		public ITerminalNode UNION() { return GetToken(PlPgSqlParser.UNION, 0); }
		public ITerminalNode EXCEPT() { return GetToken(PlPgSqlParser.EXCEPT, 0); }
		public Set_qualifierContext set_qualifier() {
			return GetRuleContext<Set_qualifierContext>(0);
		}
		public Select_opsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_select_ops; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSelect_ops(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Select_opsContext select_ops() {
		return select_ops(0);
	}

	private Select_opsContext select_ops(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		Select_opsContext _localctx = new Select_opsContext(Context, _parentState);
		Select_opsContext _prevctx = _localctx;
		int _startState = 18;
		EnterRecursionRule(_localctx, 18, RULE_select_ops, _p);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 440;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LEFT_PAREN:
				{
				State = 435; Match(LEFT_PAREN);
				State = 436; select_stmt();
				State = 437; Match(RIGHT_PAREN);
				}
				break;
			case VALUES:
			case SELECT:
			case TABLE:
				{
				State = 439; select_primary();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			Context.Stop = TokenStream.LT(-1);
			State = 450;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,23,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new Select_opsContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_select_ops);
					State = 442;
					if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
					State = 443;
					_la = TokenStream.LA(1);
					if ( !(((((_la - 396)) & ~0x3f) == 0 && ((1L << (_la - 396)) & ((1L << (EXCEPT - 396)) | (1L << (INTERSECT - 396)) | (1L << (UNION - 396)))) != 0)) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					State = 445;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==ALL || _la==DISTINCT) {
						{
						State = 444; set_qualifier();
						}
					}

					State = 447; select_ops(3);
					}
					} 
				}
				State = 452;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,23,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class Select_primaryContext : ParserRuleContext {
		public ITerminalNode SELECT() { return GetToken(PlPgSqlParser.SELECT, 0); }
		public Set_qualifierContext set_qualifier() {
			return GetRuleContext<Set_qualifierContext>(0);
		}
		public Select_listContext select_list() {
			return GetRuleContext<Select_listContext>(0);
		}
		public Into_tableContext into_table() {
			return GetRuleContext<Into_tableContext>(0);
		}
		public ITerminalNode FROM() { return GetToken(PlPgSqlParser.FROM, 0); }
		public From_itemContext[] from_item() {
			return GetRuleContexts<From_itemContext>();
		}
		public From_itemContext from_item(int i) {
			return GetRuleContext<From_itemContext>(i);
		}
		public ITerminalNode WHERE() { return GetToken(PlPgSqlParser.WHERE, 0); }
		public VexContext[] vex() {
			return GetRuleContexts<VexContext>();
		}
		public VexContext vex(int i) {
			return GetRuleContext<VexContext>(i);
		}
		public Groupby_clauseContext groupby_clause() {
			return GetRuleContext<Groupby_clauseContext>(0);
		}
		public ITerminalNode HAVING() { return GetToken(PlPgSqlParser.HAVING, 0); }
		public ITerminalNode WINDOW() { return GetToken(PlPgSqlParser.WINDOW, 0); }
		public IdentifierContext[] identifier() {
			return GetRuleContexts<IdentifierContext>();
		}
		public IdentifierContext identifier(int i) {
			return GetRuleContext<IdentifierContext>(i);
		}
		public ITerminalNode[] AS() { return GetTokens(PlPgSqlParser.AS); }
		public ITerminalNode AS(int i) {
			return GetToken(PlPgSqlParser.AS, i);
		}
		public Window_definitionContext[] window_definition() {
			return GetRuleContexts<Window_definitionContext>();
		}
		public Window_definitionContext window_definition(int i) {
			return GetRuleContext<Window_definitionContext>(i);
		}
		public ITerminalNode ON() { return GetToken(PlPgSqlParser.ON, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlPgSqlParser.LEFT_PAREN, 0); }
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlPgSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(PlPgSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlPgSqlParser.COMMA, i);
		}
		public ITerminalNode TABLE() { return GetToken(PlPgSqlParser.TABLE, 0); }
		public Schema_qualified_nameContext schema_qualified_name() {
			return GetRuleContext<Schema_qualified_nameContext>(0);
		}
		public ITerminalNode ONLY() { return GetToken(PlPgSqlParser.ONLY, 0); }
		public ITerminalNode MULTIPLY() { return GetToken(PlPgSqlParser.MULTIPLY, 0); }
		public Values_stmtContext values_stmt() {
			return GetRuleContext<Values_stmtContext>(0);
		}
		public Select_primaryContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_select_primary; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSelect_primary(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Select_primaryContext select_primary() {
		Select_primaryContext _localctx = new Select_primaryContext(Context, State);
		EnterRule(_localctx, 20, RULE_select_primary);
		int _la;
		try {
			int _alt;
			State = 524;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case SELECT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 453; Match(SELECT);
				State = 469;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,26,Context) ) {
				case 1:
					{
					State = 454; set_qualifier();
					State = 467;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,25,Context) ) {
					case 1:
						{
						State = 455; Match(ON);
						State = 456; Match(LEFT_PAREN);
						State = 457; vex(0);
						State = 462;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						while (_la==COMMA) {
							{
							{
							State = 458; Match(COMMA);
							State = 459; vex(0);
							}
							}
							State = 464;
							ErrorHandler.Sync(this);
							_la = TokenStream.LA(1);
						}
						State = 465; Match(RIGHT_PAREN);
						}
						break;
					}
					}
					break;
				}
				State = 472;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,27,Context) ) {
				case 1:
					{
					State = 471; select_list();
					}
					break;
				}
				State = 475;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,28,Context) ) {
				case 1:
					{
					State = 474; into_table();
					}
					break;
				}
				State = 486;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,30,Context) ) {
				case 1:
					{
					State = 477; Match(FROM);
					State = 478; from_item(0);
					State = 483;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,29,Context);
					while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
						if ( _alt==1 ) {
							{
							{
							State = 479; Match(COMMA);
							State = 480; from_item(0);
							}
							} 
						}
						State = 485;
						ErrorHandler.Sync(this);
						_alt = Interpreter.AdaptivePredict(TokenStream,29,Context);
					}
					}
					break;
				}
				State = 490;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,31,Context) ) {
				case 1:
					{
					State = 488; Match(WHERE);
					State = 489; vex(0);
					}
					break;
				}
				State = 493;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,32,Context) ) {
				case 1:
					{
					State = 492; groupby_clause();
					}
					break;
				}
				State = 497;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,33,Context) ) {
				case 1:
					{
					State = 495; Match(HAVING);
					State = 496; vex(0);
					}
					break;
				}
				State = 513;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,35,Context) ) {
				case 1:
					{
					State = 499; Match(WINDOW);
					State = 500; identifier();
					State = 501; Match(AS);
					State = 502; window_definition();
					State = 510;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,34,Context);
					while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
						if ( _alt==1 ) {
							{
							{
							State = 503; Match(COMMA);
							State = 504; identifier();
							State = 505; Match(AS);
							State = 506; window_definition();
							}
							} 
						}
						State = 512;
						ErrorHandler.Sync(this);
						_alt = Interpreter.AdaptivePredict(TokenStream,34,Context);
					}
					}
					break;
				}
				}
				break;
			case TABLE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 515; Match(TABLE);
				State = 517;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ONLY) {
					{
					State = 516; Match(ONLY);
					}
				}

				State = 519; schema_qualified_name();
				State = 521;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,37,Context) ) {
				case 1:
					{
					State = 520; Match(MULTIPLY);
					}
					break;
				}
				}
				break;
			case VALUES:
				EnterOuterAlt(_localctx, 3);
				{
				State = 523; values_stmt();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Window_definitionContext : ParserRuleContext {
		public ITerminalNode LEFT_PAREN() { return GetToken(PlPgSqlParser.LEFT_PAREN, 0); }
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlPgSqlParser.RIGHT_PAREN, 0); }
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Partition_by_columnsContext partition_by_columns() {
			return GetRuleContext<Partition_by_columnsContext>(0);
		}
		public Orderby_clauseContext orderby_clause() {
			return GetRuleContext<Orderby_clauseContext>(0);
		}
		public Frame_clauseContext frame_clause() {
			return GetRuleContext<Frame_clauseContext>(0);
		}
		public Window_definitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_window_definition; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWindow_definition(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Window_definitionContext window_definition() {
		Window_definitionContext _localctx = new Window_definitionContext(Context, State);
		EnterRule(_localctx, 22, RULE_window_definition);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 526; Match(LEFT_PAREN);
			State = 528;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,39,Context) ) {
			case 1:
				{
				State = 527; identifier();
				}
				break;
			}
			State = 531;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PARTITION) {
				{
				State = 530; partition_by_columns();
				}
			}

			State = 534;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ORDER) {
				{
				State = 533; orderby_clause();
				}
			}

			State = 537;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==GROUPS || _la==RANGE || _la==ROWS) {
				{
				State = 536; frame_clause();
				}
			}

			State = 539; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Frame_clauseContext : ParserRuleContext {
		public ITerminalNode RANGE() { return GetToken(PlPgSqlParser.RANGE, 0); }
		public ITerminalNode ROWS() { return GetToken(PlPgSqlParser.ROWS, 0); }
		public ITerminalNode GROUPS() { return GetToken(PlPgSqlParser.GROUPS, 0); }
		public Frame_boundContext[] frame_bound() {
			return GetRuleContexts<Frame_boundContext>();
		}
		public Frame_boundContext frame_bound(int i) {
			return GetRuleContext<Frame_boundContext>(i);
		}
		public ITerminalNode BETWEEN() { return GetToken(PlPgSqlParser.BETWEEN, 0); }
		public ITerminalNode AND() { return GetToken(PlPgSqlParser.AND, 0); }
		public ITerminalNode EXCLUDE() { return GetToken(PlPgSqlParser.EXCLUDE, 0); }
		public ITerminalNode CURRENT() { return GetToken(PlPgSqlParser.CURRENT, 0); }
		public ITerminalNode ROW() { return GetToken(PlPgSqlParser.ROW, 0); }
		public ITerminalNode GROUP() { return GetToken(PlPgSqlParser.GROUP, 0); }
		public ITerminalNode TIES() { return GetToken(PlPgSqlParser.TIES, 0); }
		public ITerminalNode NO() { return GetToken(PlPgSqlParser.NO, 0); }
		public ITerminalNode OTHERS() { return GetToken(PlPgSqlParser.OTHERS, 0); }
		public Frame_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_frame_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFrame_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Frame_clauseContext frame_clause() {
		Frame_clauseContext _localctx = new Frame_clauseContext(Context, State);
		EnterRule(_localctx, 24, RULE_frame_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 541;
			_la = TokenStream.LA(1);
			if ( !(_la==GROUPS || _la==RANGE || _la==ROWS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 548;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,43,Context) ) {
			case 1:
				{
				State = 542; frame_bound();
				}
				break;
			case 2:
				{
				State = 543; Match(BETWEEN);
				State = 544; frame_bound();
				State = 545; Match(AND);
				State = 546; frame_bound();
				}
				break;
			}
			State = 559;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==EXCLUDE) {
				{
				State = 550; Match(EXCLUDE);
				State = 557;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case CURRENT:
					{
					State = 551; Match(CURRENT);
					State = 552; Match(ROW);
					}
					break;
				case GROUP:
					{
					State = 553; Match(GROUP);
					}
					break;
				case TIES:
					{
					State = 554; Match(TIES);
					}
					break;
				case NO:
					{
					State = 555; Match(NO);
					State = 556; Match(OTHERS);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Frame_boundContext : ParserRuleContext {
		public VexContext vex() {
			return GetRuleContext<VexContext>(0);
		}
		public ITerminalNode PRECEDING() { return GetToken(PlPgSqlParser.PRECEDING, 0); }
		public ITerminalNode FOLLOWING() { return GetToken(PlPgSqlParser.FOLLOWING, 0); }
		public ITerminalNode CURRENT() { return GetToken(PlPgSqlParser.CURRENT, 0); }
		public ITerminalNode ROW() { return GetToken(PlPgSqlParser.ROW, 0); }
		public Frame_boundContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_frame_bound; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFrame_bound(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Frame_boundContext frame_bound() {
		Frame_boundContext _localctx = new Frame_boundContext(Context, State);
		EnterRule(_localctx, 26, RULE_frame_bound);
		int _la;
		try {
			State = 566;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,46,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 561; vex(0);
				State = 562;
				_la = TokenStream.LA(1);
				if ( !(_la==FOLLOWING || _la==PRECEDING) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 564; Match(CURRENT);
				State = 565; Match(ROW);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Orderby_clauseContext : ParserRuleContext {
		public ITerminalNode ORDER() { return GetToken(PlPgSqlParser.ORDER, 0); }
		public ITerminalNode BY() { return GetToken(PlPgSqlParser.BY, 0); }
		public Sort_specifier_listContext sort_specifier_list() {
			return GetRuleContext<Sort_specifier_listContext>(0);
		}
		public Orderby_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_orderby_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOrderby_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Orderby_clauseContext orderby_clause() {
		Orderby_clauseContext _localctx = new Orderby_clauseContext(Context, State);
		EnterRule(_localctx, 28, RULE_orderby_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 568; Match(ORDER);
			State = 569; Match(BY);
			State = 570; sort_specifier_list();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Sort_specifier_listContext : ParserRuleContext {
		public Sort_specifierContext[] sort_specifier() {
			return GetRuleContexts<Sort_specifierContext>();
		}
		public Sort_specifierContext sort_specifier(int i) {
			return GetRuleContext<Sort_specifierContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlPgSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlPgSqlParser.COMMA, i);
		}
		public Sort_specifier_listContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sort_specifier_list; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSort_specifier_list(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Sort_specifier_listContext sort_specifier_list() {
		Sort_specifier_listContext _localctx = new Sort_specifier_listContext(Context, State);
		EnterRule(_localctx, 30, RULE_sort_specifier_list);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 572; sort_specifier();
			State = 577;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 573; Match(COMMA);
				State = 574; sort_specifier();
				}
				}
				State = 579;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Sort_specifierContext : ParserRuleContext {
		public VexContext key;
		public Schema_qualified_nameContext opclass;
		public Order_specificationContext order;
		public Null_orderingContext null_order;
		public VexContext vex() {
			return GetRuleContext<VexContext>(0);
		}
		public Schema_qualified_nameContext schema_qualified_name() {
			return GetRuleContext<Schema_qualified_nameContext>(0);
		}
		public Order_specificationContext order_specification() {
			return GetRuleContext<Order_specificationContext>(0);
		}
		public Null_orderingContext null_ordering() {
			return GetRuleContext<Null_orderingContext>(0);
		}
		public Sort_specifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sort_specifier; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSort_specifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Sort_specifierContext sort_specifier() {
		Sort_specifierContext _localctx = new Sort_specifierContext(Context, State);
		EnterRule(_localctx, 32, RULE_sort_specifier);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 580; _localctx.key = vex(0);
			State = 582;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,48,Context) ) {
			case 1:
				{
				State = 581; _localctx.opclass = schema_qualified_name();
				}
				break;
			}
			State = 585;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ASC || _la==DESC || _la==USING) {
				{
				State = 584; _localctx.order = order_specification();
				}
			}

			State = 588;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,50,Context) ) {
			case 1:
				{
				State = 587; _localctx.null_order = null_ordering();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Null_orderingContext : ParserRuleContext {
		public ITerminalNode NULLS() { return GetToken(PlPgSqlParser.NULLS, 0); }
		public ITerminalNode FIRST() { return GetToken(PlPgSqlParser.FIRST, 0); }
		public ITerminalNode LAST() { return GetToken(PlPgSqlParser.LAST, 0); }
		public Null_orderingContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_null_ordering; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNull_ordering(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Null_orderingContext null_ordering() {
		Null_orderingContext _localctx = new Null_orderingContext(Context, State);
		EnterRule(_localctx, 34, RULE_null_ordering);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 590; Match(NULLS);
			State = 591;
			_la = TokenStream.LA(1);
			if ( !(_la==FIRST || _la==LAST) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Order_specificationContext : ParserRuleContext {
		public ITerminalNode ASC() { return GetToken(PlPgSqlParser.ASC, 0); }
		public ITerminalNode DESC() { return GetToken(PlPgSqlParser.DESC, 0); }
		public ITerminalNode USING() { return GetToken(PlPgSqlParser.USING, 0); }
		public All_op_refContext all_op_ref() {
			return GetRuleContext<All_op_refContext>(0);
		}
		public Order_specificationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_order_specification; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOrder_specification(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Order_specificationContext order_specification() {
		Order_specificationContext _localctx = new Order_specificationContext(Context, State);
		EnterRule(_localctx, 36, RULE_order_specification);
		try {
			State = 597;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ASC:
				EnterOuterAlt(_localctx, 1);
				{
				State = 593; Match(ASC);
				}
				break;
			case DESC:
				EnterOuterAlt(_localctx, 2);
				{
				State = 594; Match(DESC);
				}
				break;
			case USING:
				EnterOuterAlt(_localctx, 3);
				{
				State = 595; Match(USING);
				State = 596; all_op_ref();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class All_op_refContext : ParserRuleContext {
		public All_simple_opContext all_simple_op() {
			return GetRuleContext<All_simple_opContext>(0);
		}
		public ITerminalNode OPERATOR() { return GetToken(PlPgSqlParser.OPERATOR, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlPgSqlParser.LEFT_PAREN, 0); }
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ITerminalNode DOT() { return GetToken(PlPgSqlParser.DOT, 0); }
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlPgSqlParser.RIGHT_PAREN, 0); }
		public All_op_refContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_all_op_ref; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAll_op_ref(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public All_op_refContext all_op_ref() {
		All_op_refContext _localctx = new All_op_refContext(Context, State);
		EnterRule(_localctx, 38, RULE_all_op_ref);
		try {
			State = 607;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case EQUAL:
			case NOT_EQUAL:
			case LTH:
			case LEQ:
			case GTH:
			case GEQ:
			case PLUS:
			case MINUS:
			case MULTIPLY:
			case DIVIDE:
			case MODULAR:
			case EXP:
			case LESS_LESS:
			case GREATER_GREATER:
			case HASH_SIGN:
			case OP_CHARS:
				EnterOuterAlt(_localctx, 1);
				{
				State = 599; all_simple_op();
				}
				break;
			case OPERATOR:
				EnterOuterAlt(_localctx, 2);
				{
				State = 600; Match(OPERATOR);
				State = 601; Match(LEFT_PAREN);
				State = 602; identifier();
				State = 603; Match(DOT);
				State = 604; all_simple_op();
				State = 605; Match(RIGHT_PAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class All_simple_opContext : ParserRuleContext {
		public Op_charsContext op_chars() {
			return GetRuleContext<Op_charsContext>(0);
		}
		public ITerminalNode EQUAL() { return GetToken(PlPgSqlParser.EQUAL, 0); }
		public ITerminalNode NOT_EQUAL() { return GetToken(PlPgSqlParser.NOT_EQUAL, 0); }
		public ITerminalNode LTH() { return GetToken(PlPgSqlParser.LTH, 0); }
		public ITerminalNode LEQ() { return GetToken(PlPgSqlParser.LEQ, 0); }
		public ITerminalNode GTH() { return GetToken(PlPgSqlParser.GTH, 0); }
		public ITerminalNode GEQ() { return GetToken(PlPgSqlParser.GEQ, 0); }
		public ITerminalNode PLUS() { return GetToken(PlPgSqlParser.PLUS, 0); }
		public ITerminalNode MINUS() { return GetToken(PlPgSqlParser.MINUS, 0); }
		public ITerminalNode MULTIPLY() { return GetToken(PlPgSqlParser.MULTIPLY, 0); }
		public ITerminalNode DIVIDE() { return GetToken(PlPgSqlParser.DIVIDE, 0); }
		public ITerminalNode MODULAR() { return GetToken(PlPgSqlParser.MODULAR, 0); }
		public ITerminalNode EXP() { return GetToken(PlPgSqlParser.EXP, 0); }
		public All_simple_opContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_all_simple_op; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAll_simple_op(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public All_simple_opContext all_simple_op() {
		All_simple_opContext _localctx = new All_simple_opContext(Context, State);
		EnterRule(_localctx, 40, RULE_all_simple_op);
		try {
			State = 622;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LESS_LESS:
			case GREATER_GREATER:
			case HASH_SIGN:
			case OP_CHARS:
				EnterOuterAlt(_localctx, 1);
				{
				State = 609; op_chars();
				}
				break;
			case EQUAL:
				EnterOuterAlt(_localctx, 2);
				{
				State = 610; Match(EQUAL);
				}
				break;
			case NOT_EQUAL:
				EnterOuterAlt(_localctx, 3);
				{
				State = 611; Match(NOT_EQUAL);
				}
				break;
			case LTH:
				EnterOuterAlt(_localctx, 4);
				{
				State = 612; Match(LTH);
				}
				break;
			case LEQ:
				EnterOuterAlt(_localctx, 5);
				{
				State = 613; Match(LEQ);
				}
				break;
			case GTH:
				EnterOuterAlt(_localctx, 6);
				{
				State = 614; Match(GTH);
				}
				break;
			case GEQ:
				EnterOuterAlt(_localctx, 7);
				{
				State = 615; Match(GEQ);
				}
				break;
			case PLUS:
				EnterOuterAlt(_localctx, 8);
				{
				State = 616; Match(PLUS);
				}
				break;
			case MINUS:
				EnterOuterAlt(_localctx, 9);
				{
				State = 617; Match(MINUS);
				}
				break;
			case MULTIPLY:
				EnterOuterAlt(_localctx, 10);
				{
				State = 618; Match(MULTIPLY);
				}
				break;
			case DIVIDE:
				EnterOuterAlt(_localctx, 11);
				{
				State = 619; Match(DIVIDE);
				}
				break;
			case MODULAR:
				EnterOuterAlt(_localctx, 12);
				{
				State = 620; Match(MODULAR);
				}
				break;
			case EXP:
				EnterOuterAlt(_localctx, 13);
				{
				State = 621; Match(EXP);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Op_charsContext : ParserRuleContext {
		public ITerminalNode OP_CHARS() { return GetToken(PlPgSqlParser.OP_CHARS, 0); }
		public ITerminalNode LESS_LESS() { return GetToken(PlPgSqlParser.LESS_LESS, 0); }
		public ITerminalNode GREATER_GREATER() { return GetToken(PlPgSqlParser.GREATER_GREATER, 0); }
		public ITerminalNode HASH_SIGN() { return GetToken(PlPgSqlParser.HASH_SIGN, 0); }
		public Op_charsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_op_chars; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOp_chars(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Op_charsContext op_chars() {
		Op_charsContext _localctx = new Op_charsContext(Context, State);
		EnterRule(_localctx, 42, RULE_op_chars);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 624;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 601)) & ~0x3f) == 0 && ((1L << (_la - 601)) & ((1L << (LESS_LESS - 601)) | (1L << (GREATER_GREATER - 601)) | (1L << (HASH_SIGN - 601)) | (1L << (OP_CHARS - 601)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Values_stmtContext : ParserRuleContext {
		public ITerminalNode VALUES() { return GetToken(PlPgSqlParser.VALUES, 0); }
		public Values_valuesContext[] values_values() {
			return GetRuleContexts<Values_valuesContext>();
		}
		public Values_valuesContext values_values(int i) {
			return GetRuleContext<Values_valuesContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlPgSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlPgSqlParser.COMMA, i);
		}
		public Values_stmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_values_stmt; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitValues_stmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Values_stmtContext values_stmt() {
		Values_stmtContext _localctx = new Values_stmtContext(Context, State);
		EnterRule(_localctx, 44, RULE_values_stmt);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 626; Match(VALUES);
			State = 627; values_values();
			State = 632;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,54,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 628; Match(COMMA);
					State = 629; values_values();
					}
					} 
				}
				State = 634;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,54,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Values_valuesContext : ParserRuleContext {
		public ITerminalNode LEFT_PAREN() { return GetToken(PlPgSqlParser.LEFT_PAREN, 0); }
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlPgSqlParser.RIGHT_PAREN, 0); }
		public VexContext[] vex() {
			return GetRuleContexts<VexContext>();
		}
		public VexContext vex(int i) {
			return GetRuleContext<VexContext>(i);
		}
		public ITerminalNode[] DEFAULT() { return GetTokens(PlPgSqlParser.DEFAULT); }
		public ITerminalNode DEFAULT(int i) {
			return GetToken(PlPgSqlParser.DEFAULT, i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlPgSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlPgSqlParser.COMMA, i);
		}
		public Values_valuesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_values_values; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitValues_values(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Values_valuesContext values_values() {
		Values_valuesContext _localctx = new Values_valuesContext(Context, State);
		EnterRule(_localctx, 46, RULE_values_values);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 635; Match(LEFT_PAREN);
			State = 638;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ABORT:
			case ABSOLUTE:
			case ACCESS:
			case ACTION:
			case ADD:
			case ADMIN:
			case AFTER:
			case AGGREGATE:
			case ALSO:
			case ALTER:
			case ALWAYS:
			case ASSERTION:
			case ASSIGNMENT:
			case AT:
			case ATTACH:
			case ATTRIBUTE:
			case BACKWARD:
			case BEFORE:
			case BEGIN:
			case BY:
			case CACHE:
			case CALL:
			case CALLED:
			case CASCADE:
			case CASCADED:
			case CATALOG:
			case CHAIN:
			case CHARACTERISTICS:
			case CHECKPOINT:
			case CLASS:
			case CLOSE:
			case CLUSTER:
			case COLUMNS:
			case COMMENT:
			case COMMENTS:
			case COMMIT:
			case COMMITTED:
			case CONFIGURATION:
			case CONFLICT:
			case CONNECTION:
			case CONSTRAINTS:
			case CONTENT:
			case CONTINUE:
			case CONVERSION:
			case COPY:
			case COST:
			case CSV:
			case CUBE:
			case CURRENT:
			case CURSOR:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DAY:
			case DEALLOCATE:
			case DECLARE:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DELIMITER:
			case DELIMITERS:
			case DEPENDS:
			case DETACH:
			case DICTIONARY:
			case DISABLE:
			case DISCARD:
			case DOCUMENT:
			case DOMAIN:
			case DOUBLE:
			case DROP:
			case EACH:
			case ENABLE:
			case ENCODING:
			case ENCRYPTED:
			case ENUM:
			case ESCAPE:
			case EVENT:
			case EXCLUDE:
			case EXCLUDING:
			case EXCLUSIVE:
			case EXECUTE:
			case EXPLAIN:
			case EXTENSION:
			case EXTERNAL:
			case FAMILY:
			case FILTER:
			case FIRST:
			case FOLLOWING:
			case FORCE:
			case FORWARD:
			case FUNCTION:
			case FUNCTIONS:
			case GENERATED:
			case GLOBAL:
			case GRANTED:
			case GROUPS:
			case HANDLER:
			case HEADER:
			case HOLD:
			case HOUR:
			case IDENTITY:
			case IF:
			case IMMEDIATE:
			case IMMUTABLE:
			case IMPLICIT:
			case IMPORT:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDEX:
			case INDEXES:
			case INHERIT:
			case INHERITS:
			case INLINE:
			case INPUT:
			case INSENSITIVE:
			case INSERT:
			case INSTEAD:
			case INVOKER:
			case ISOLATION:
			case KEY:
			case LABEL:
			case LANGUAGE:
			case LARGE:
			case LAST:
			case LEAKPROOF:
			case LEVEL:
			case LISTEN:
			case LOAD:
			case LOCAL:
			case LOCATION:
			case LOCK:
			case LOCKED:
			case LOGGED:
			case MAPPING:
			case MATCH:
			case MATERIALIZED:
			case MAXVALUE:
			case METHOD:
			case MINUTE:
			case MINVALUE:
			case MODE:
			case MONTH:
			case MOVE:
			case NAME:
			case NAMES:
			case NEW:
			case NEXT:
			case NO:
			case NOTHING:
			case NOTIFY:
			case NOWAIT:
			case NULLS:
			case OBJECT:
			case OF:
			case OFF:
			case OIDS:
			case OLD:
			case OPERATOR:
			case OPTION:
			case OPTIONS:
			case ORDINALITY:
			case OTHERS:
			case OVER:
			case OVERRIDING:
			case OWNED:
			case OWNER:
			case PARALLEL:
			case PARSER:
			case PARTIAL:
			case PARTITION:
			case PASSING:
			case PASSWORD:
			case PLANS:
			case POLICY:
			case PRECEDING:
			case PREPARE:
			case PREPARED:
			case PRESERVE:
			case PRIOR:
			case PRIVILEGES:
			case PROCEDURAL:
			case PROCEDURE:
			case PROCEDURES:
			case PROGRAM:
			case PUBLICATION:
			case QUOTE:
			case RANGE:
			case READ:
			case REASSIGN:
			case RECHECK:
			case RECURSIVE:
			case REF:
			case REFERENCING:
			case REFRESH:
			case REINDEX:
			case RELATIVE:
			case RELEASE:
			case RENAME:
			case REPEATABLE:
			case REPLACE:
			case REPLICA:
			case RESET:
			case RESTART:
			case RESTRICT:
			case RETURNS:
			case REVOKE:
			case ROLE:
			case ROLLBACK:
			case ROLLUP:
			case ROUTINE:
			case ROUTINES:
			case ROWS:
			case RULE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMAS:
			case SCROLL:
			case SEARCH:
			case SECOND:
			case SECURITY:
			case SEQUENCE:
			case SEQUENCES:
			case SERIALIZABLE:
			case SERVER:
			case SESSION:
			case SET:
			case SETS:
			case SHARE:
			case SHOW:
			case SIMPLE:
			case SKIP_:
			case SNAPSHOT:
			case SQL:
			case STABLE:
			case STANDALONE:
			case START:
			case STATEMENT:
			case STATISTICS:
			case STDIN:
			case STDOUT:
			case STORAGE:
			case STORED:
			case STRICT:
			case STRIP:
			case SUBSCRIPTION:
			case SUPPORT:
			case SYSID:
			case SYSTEM:
			case TABLES:
			case TABLESPACE:
			case TEMP:
			case TEMPLATE:
			case TEMPORARY:
			case TEXT:
			case TIES:
			case TRANSACTION:
			case TRANSFORM:
			case TRIGGER:
			case TRUNCATE:
			case TRUSTED:
			case TYPE:
			case TYPES:
			case UNBOUNDED:
			case UNCOMMITTED:
			case UNENCRYPTED:
			case UNKNOWN:
			case UNLISTEN:
			case UNLOGGED:
			case UNTIL:
			case UPDATE:
			case VACUUM:
			case VALID:
			case VALIDATE:
			case VALIDATOR:
			case VALUE:
			case VARYING:
			case VERSION:
			case VIEW:
			case VIEWS:
			case VOLATILE:
			case WHITESPACE:
			case WITHIN:
			case WITHOUT:
			case WORK:
			case WRAPPER:
			case WRITE:
			case XML:
			case YEAR:
			case YES:
			case ZONE:
			case BETWEEN:
			case BIGINT:
			case BIT:
			case BOOLEAN:
			case CHAR:
			case CHARACTER:
			case COALESCE:
			case DEC:
			case DECIMAL:
			case EXISTS:
			case EXTRACT:
			case FLOAT:
			case GREATEST:
			case GROUPING:
			case INOUT:
			case INT:
			case INTEGER:
			case INTERVAL:
			case LEAST:
			case NATIONAL:
			case NCHAR:
			case NONE:
			case NULLIF:
			case NUMERIC:
			case OUT:
			case OVERLAY:
			case POSITION:
			case PRECISION:
			case REAL:
			case ROW:
			case SETOF:
			case SMALLINT:
			case SUBSTRING:
			case TIME:
			case TIMESTAMP:
			case TREAT:
			case TRIM:
			case VALUES:
			case VARCHAR:
			case XMLATTRIBUTES:
			case XMLCONCAT:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case AUTHORIZATION:
			case BINARY:
			case COLLATION:
			case CONCURRENTLY:
			case CROSS:
			case CURRENT_SCHEMA:
			case FREEZE:
			case FULL:
			case ILIKE:
			case INNER:
			case IS:
			case ISNULL:
			case JOIN:
			case LEFT:
			case LIKE:
			case NATURAL:
			case NOTNULL:
			case OUTER:
			case OVERLAPS:
			case RIGHT:
			case SIMILAR:
			case TABLESAMPLE:
			case VERBOSE:
			case ALL:
			case ANY:
			case ARRAY:
			case CASE:
			case CAST:
			case CURRENT_CATALOG:
			case CURRENT_DATE:
			case CURRENT_TIME:
			case CURRENT_TIMESTAMP:
			case CURRENT_USER:
			case FALSE:
			case LOCALTIME:
			case LOCALTIMESTAMP:
			case NOT:
			case NULL:
			case ON:
			case SESSION_USER:
			case SOME:
			case TRUE:
			case USER:
			case ALIGNMENT:
			case BASETYPE:
			case BUFFERS:
			case BYPASSRLS:
			case CANONICAL:
			case CATEGORY:
			case COLLATABLE:
			case COMBINEFUNC:
			case COMMUTATOR:
			case CONNECT:
			case COSTS:
			case CREATEDB:
			case CREATEROLE:
			case DESERIALFUNC:
			case DETERMINISTIC:
			case DISABLE_PAGE_SKIPPING:
			case ELEMENT:
			case EXTENDED:
			case FINALFUNC:
			case FINALFUNC_EXTRA:
			case FINALFUNC_MODIFY:
			case FORCE_NOT_NULL:
			case FORCE_NULL:
			case FORCE_QUOTE:
			case FORMAT:
			case GETTOKEN:
			case HASH:
			case HASHES:
			case HEADLINE:
			case HYPOTHETICAL:
			case INDEX_CLEANUP:
			case INIT:
			case INITCOND:
			case INTERNALLENGTH:
			case JSON:
			case LC_COLLATE:
			case LC_CTYPE:
			case LEFTARG:
			case LEXIZE:
			case LEXTYPES:
			case LIST:
			case LOCALE:
			case LOGIN:
			case MAIN:
			case MERGES:
			case MFINALFUNC:
			case MFINALFUNC_EXTRA:
			case MFINALFUNC_MODIFY:
			case MINITCOND:
			case MINVFUNC:
			case MODULUS:
			case MSFUNC:
			case MSSPACE:
			case MSTYPE:
			case NEGATOR:
			case NOBYPASSRLS:
			case NOCREATEDB:
			case NOCREATEROLE:
			case NOINHERIT:
			case NOLOGIN:
			case NOREPLICATION:
			case NOSUPERUSER:
			case OUTPUT:
			case PASSEDBYVALUE:
			case PATH:
			case PERMISSIVE:
			case PLAIN:
			case PREFERRED:
			case PROVIDER:
			case READ_ONLY:
			case READ_WRITE:
			case RECEIVE:
			case REMAINDER:
			case REPLICATION:
			case RESTRICTED:
			case RESTRICTIVE:
			case RIGHTARG:
			case SAFE:
			case SEND:
			case SERIALFUNC:
			case SETTINGS:
			case SFUNC:
			case SHAREABLE:
			case SKIP_LOCKED:
			case SORTOP:
			case SSPACE:
			case STYPE:
			case SUBTYPE_DIFF:
			case SUBTYPE_OPCLASS:
			case SUBTYPE:
			case SUMMARY:
			case SUPERUSER:
			case TIMING:
			case TYPMOD_IN:
			case TYPMOD_OUT:
			case UNSAFE:
			case USAGE:
			case VARIABLE:
			case YAML:
			case ALIAS:
			case ASSERT:
			case CONSTANT:
			case DATATYPE:
			case DEBUG:
			case DETAIL:
			case DIAGNOSTICS:
			case ELSEIF:
			case ELSIF:
			case ERRCODE:
			case EXIT:
			case EXCEPTION:
			case FOREACH:
			case GET:
			case HINT:
			case INFO:
			case LOG:
			case LOOP:
			case MESSAGE:
			case NOTICE:
			case OPEN:
			case PERFORM:
			case QUERY:
			case RAISE:
			case RECORD:
			case RETURN:
			case REVERSE:
			case ROWTYPE:
			case SLICE:
			case SQLSTATE:
			case STACKED:
			case WARNING:
			case WHILE:
			case LEFT_PAREN:
			case PLUS:
			case MINUS:
			case MULTIPLY:
			case LESS_LESS:
			case GREATER_GREATER:
			case HASH_SIGN:
			case OP_CHARS:
			case NUMBER_LITERAL:
			case REAL_NUMBER:
			case DOLLAR_NUMBER:
			case Identifier:
			case QuotedIdentifier:
			case Character_String_Literal:
			case BeginDollarStringConstant:
				{
				State = 636; vex(0);
				}
				break;
			case DEFAULT:
				{
				State = 637; Match(DEFAULT);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 647;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 640; Match(COMMA);
				State = 643;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case ABORT:
				case ABSOLUTE:
				case ACCESS:
				case ACTION:
				case ADD:
				case ADMIN:
				case AFTER:
				case AGGREGATE:
				case ALSO:
				case ALTER:
				case ALWAYS:
				case ASSERTION:
				case ASSIGNMENT:
				case AT:
				case ATTACH:
				case ATTRIBUTE:
				case BACKWARD:
				case BEFORE:
				case BEGIN:
				case BY:
				case CACHE:
				case CALL:
				case CALLED:
				case CASCADE:
				case CASCADED:
				case CATALOG:
				case CHAIN:
				case CHARACTERISTICS:
				case CHECKPOINT:
				case CLASS:
				case CLOSE:
				case CLUSTER:
				case COLUMNS:
				case COMMENT:
				case COMMENTS:
				case COMMIT:
				case COMMITTED:
				case CONFIGURATION:
				case CONFLICT:
				case CONNECTION:
				case CONSTRAINTS:
				case CONTENT:
				case CONTINUE:
				case CONVERSION:
				case COPY:
				case COST:
				case CSV:
				case CUBE:
				case CURRENT:
				case CURSOR:
				case CYCLE:
				case DATA:
				case DATABASE:
				case DAY:
				case DEALLOCATE:
				case DECLARE:
				case DEFAULTS:
				case DEFERRED:
				case DEFINER:
				case DELETE:
				case DELIMITER:
				case DELIMITERS:
				case DEPENDS:
				case DETACH:
				case DICTIONARY:
				case DISABLE:
				case DISCARD:
				case DOCUMENT:
				case DOMAIN:
				case DOUBLE:
				case DROP:
				case EACH:
				case ENABLE:
				case ENCODING:
				case ENCRYPTED:
				case ENUM:
				case ESCAPE:
				case EVENT:
				case EXCLUDE:
				case EXCLUDING:
				case EXCLUSIVE:
				case EXECUTE:
				case EXPLAIN:
				case EXTENSION:
				case EXTERNAL:
				case FAMILY:
				case FILTER:
				case FIRST:
				case FOLLOWING:
				case FORCE:
				case FORWARD:
				case FUNCTION:
				case FUNCTIONS:
				case GENERATED:
				case GLOBAL:
				case GRANTED:
				case GROUPS:
				case HANDLER:
				case HEADER:
				case HOLD:
				case HOUR:
				case IDENTITY:
				case IF:
				case IMMEDIATE:
				case IMMUTABLE:
				case IMPLICIT:
				case IMPORT:
				case INCLUDE:
				case INCLUDING:
				case INCREMENT:
				case INDEX:
				case INDEXES:
				case INHERIT:
				case INHERITS:
				case INLINE:
				case INPUT:
				case INSENSITIVE:
				case INSERT:
				case INSTEAD:
				case INVOKER:
				case ISOLATION:
				case KEY:
				case LABEL:
				case LANGUAGE:
				case LARGE:
				case LAST:
				case LEAKPROOF:
				case LEVEL:
				case LISTEN:
				case LOAD:
				case LOCAL:
				case LOCATION:
				case LOCK:
				case LOCKED:
				case LOGGED:
				case MAPPING:
				case MATCH:
				case MATERIALIZED:
				case MAXVALUE:
				case METHOD:
				case MINUTE:
				case MINVALUE:
				case MODE:
				case MONTH:
				case MOVE:
				case NAME:
				case NAMES:
				case NEW:
				case NEXT:
				case NO:
				case NOTHING:
				case NOTIFY:
				case NOWAIT:
				case NULLS:
				case OBJECT:
				case OF:
				case OFF:
				case OIDS:
				case OLD:
				case OPERATOR:
				case OPTION:
				case OPTIONS:
				case ORDINALITY:
				case OTHERS:
				case OVER:
				case OVERRIDING:
				case OWNED:
				case OWNER:
				case PARALLEL:
				case PARSER:
				case PARTIAL:
				case PARTITION:
				case PASSING:
				case PASSWORD:
				case PLANS:
				case POLICY:
				case PRECEDING:
				case PREPARE:
				case PREPARED:
				case PRESERVE:
				case PRIOR:
				case PRIVILEGES:
				case PROCEDURAL:
				case PROCEDURE:
				case PROCEDURES:
				case PROGRAM:
				case PUBLICATION:
				case QUOTE:
				case RANGE:
				case READ:
				case REASSIGN:
				case RECHECK:
				case RECURSIVE:
				case REF:
				case REFERENCING:
				case REFRESH:
				case REINDEX:
				case RELATIVE:
				case RELEASE:
				case RENAME:
				case REPEATABLE:
				case REPLACE:
				case REPLICA:
				case RESET:
				case RESTART:
				case RESTRICT:
				case RETURNS:
				case REVOKE:
				case ROLE:
				case ROLLBACK:
				case ROLLUP:
				case ROUTINE:
				case ROUTINES:
				case ROWS:
				case RULE:
				case SAVEPOINT:
				case SCHEMA:
				case SCHEMAS:
				case SCROLL:
				case SEARCH:
				case SECOND:
				case SECURITY:
				case SEQUENCE:
				case SEQUENCES:
				case SERIALIZABLE:
				case SERVER:
				case SESSION:
				case SET:
				case SETS:
				case SHARE:
				case SHOW:
				case SIMPLE:
				case SKIP_:
				case SNAPSHOT:
				case SQL:
				case STABLE:
				case STANDALONE:
				case START:
				case STATEMENT:
				case STATISTICS:
				case STDIN:
				case STDOUT:
				case STORAGE:
				case STORED:
				case STRICT:
				case STRIP:
				case SUBSCRIPTION:
				case SUPPORT:
				case SYSID:
				case SYSTEM:
				case TABLES:
				case TABLESPACE:
				case TEMP:
				case TEMPLATE:
				case TEMPORARY:
				case TEXT:
				case TIES:
				case TRANSACTION:
				case TRANSFORM:
				case TRIGGER:
				case TRUNCATE:
				case TRUSTED:
				case TYPE:
				case TYPES:
				case UNBOUNDED:
				case UNCOMMITTED:
				case UNENCRYPTED:
				case UNKNOWN:
				case UNLISTEN:
				case UNLOGGED:
				case UNTIL:
				case UPDATE:
				case VACUUM:
				case VALID:
				case VALIDATE:
				case VALIDATOR:
				case VALUE:
				case VARYING:
				case VERSION:
				case VIEW:
				case VIEWS:
				case VOLATILE:
				case WHITESPACE:
				case WITHIN:
				case WITHOUT:
				case WORK:
				case WRAPPER:
				case WRITE:
				case XML:
				case YEAR:
				case YES:
				case ZONE:
				case BETWEEN:
				case BIGINT:
				case BIT:
				case BOOLEAN:
				case CHAR:
				case CHARACTER:
				case COALESCE:
				case DEC:
				case DECIMAL:
				case EXISTS:
				case EXTRACT:
				case FLOAT:
				case GREATEST:
				case GROUPING:
				case INOUT:
				case INT:
				case INTEGER:
				case INTERVAL:
				case LEAST:
				case NATIONAL:
				case NCHAR:
				case NONE:
				case NULLIF:
				case NUMERIC:
				case OUT:
				case OVERLAY:
				case POSITION:
				case PRECISION:
				case REAL:
				case ROW:
				case SETOF:
				case SMALLINT:
				case SUBSTRING:
				case TIME:
				case TIMESTAMP:
				case TREAT:
				case TRIM:
				case VALUES:
				case VARCHAR:
				case XMLATTRIBUTES:
				case XMLCONCAT:
				case XMLELEMENT:
				case XMLEXISTS:
				case XMLFOREST:
				case XMLNAMESPACES:
				case XMLPARSE:
				case XMLPI:
				case XMLROOT:
				case XMLSERIALIZE:
				case XMLTABLE:
				case AUTHORIZATION:
				case BINARY:
				case COLLATION:
				case CONCURRENTLY:
				case CROSS:
				case CURRENT_SCHEMA:
				case FREEZE:
				case FULL:
				case ILIKE:
				case INNER:
				case IS:
				case ISNULL:
				case JOIN:
				case LEFT:
				case LIKE:
				case NATURAL:
				case NOTNULL:
				case OUTER:
				case OVERLAPS:
				case RIGHT:
				case SIMILAR:
				case TABLESAMPLE:
				case VERBOSE:
				case ALL:
				case ANY:
				case ARRAY:
				case CASE:
				case CAST:
				case CURRENT_CATALOG:
				case CURRENT_DATE:
				case CURRENT_TIME:
				case CURRENT_TIMESTAMP:
				case CURRENT_USER:
				case FALSE:
				case LOCALTIME:
				case LOCALTIMESTAMP:
				case NOT:
				case NULL:
				case ON:
				case SESSION_USER:
				case SOME:
				case TRUE:
				case USER:
				case ALIGNMENT:
				case BASETYPE:
				case BUFFERS:
				case BYPASSRLS:
				case CANONICAL:
				case CATEGORY:
				case COLLATABLE:
				case COMBINEFUNC:
				case COMMUTATOR:
				case CONNECT:
				case COSTS:
				case CREATEDB:
				case CREATEROLE:
				case DESERIALFUNC:
				case DETERMINISTIC:
				case DISABLE_PAGE_SKIPPING:
				case ELEMENT:
				case EXTENDED:
				case FINALFUNC:
				case FINALFUNC_EXTRA:
				case FINALFUNC_MODIFY:
				case FORCE_NOT_NULL:
				case FORCE_NULL:
				case FORCE_QUOTE:
				case FORMAT:
				case GETTOKEN:
				case HASH:
				case HASHES:
				case HEADLINE:
				case HYPOTHETICAL:
				case INDEX_CLEANUP:
				case INIT:
				case INITCOND:
				case INTERNALLENGTH:
				case JSON:
				case LC_COLLATE:
				case LC_CTYPE:
				case LEFTARG:
				case LEXIZE:
				case LEXTYPES:
				case LIST:
				case LOCALE:
				case LOGIN:
				case MAIN:
				case MERGES:
				case MFINALFUNC:
				case MFINALFUNC_EXTRA:
				case MFINALFUNC_MODIFY:
				case MINITCOND:
				case MINVFUNC:
				case MODULUS:
				case MSFUNC:
				case MSSPACE:
				case MSTYPE:
				case NEGATOR:
				case NOBYPASSRLS:
				case NOCREATEDB:
				case NOCREATEROLE:
				case NOINHERIT:
				case NOLOGIN:
				case NOREPLICATION:
				case NOSUPERUSER:
				case OUTPUT:
				case PASSEDBYVALUE:
				case PATH:
				case PERMISSIVE:
				case PLAIN:
				case PREFERRED:
				case PROVIDER:
				case READ_ONLY:
				case READ_WRITE:
				case RECEIVE:
				case REMAINDER:
				case REPLICATION:
				case RESTRICTED:
				case RESTRICTIVE:
				case RIGHTARG:
				case SAFE:
				case SEND:
				case SERIALFUNC:
				case SETTINGS:
				case SFUNC:
				case SHAREABLE:
				case SKIP_LOCKED:
				case SORTOP:
				case SSPACE:
				case STYPE:
				case SUBTYPE_DIFF:
				case SUBTYPE_OPCLASS:
				case SUBTYPE:
				case SUMMARY:
				case SUPERUSER:
				case TIMING:
				case TYPMOD_IN:
				case TYPMOD_OUT:
				case UNSAFE:
				case USAGE:
				case VARIABLE:
				case YAML:
				case ALIAS:
				case ASSERT:
				case CONSTANT:
				case DATATYPE:
				case DEBUG:
				case DETAIL:
				case DIAGNOSTICS:
				case ELSEIF:
				case ELSIF:
				case ERRCODE:
				case EXIT:
				case EXCEPTION:
				case FOREACH:
				case GET:
				case HINT:
				case INFO:
				case LOG:
				case LOOP:
				case MESSAGE:
				case NOTICE:
				case OPEN:
				case PERFORM:
				case QUERY:
				case RAISE:
				case RECORD:
				case RETURN:
				case REVERSE:
				case ROWTYPE:
				case SLICE:
				case SQLSTATE:
				case STACKED:
				case WARNING:
				case WHILE:
				case LEFT_PAREN:
				case PLUS:
				case MINUS:
				case MULTIPLY:
				case LESS_LESS:
				case GREATER_GREATER:
				case HASH_SIGN:
				case OP_CHARS:
				case NUMBER_LITERAL:
				case REAL_NUMBER:
				case DOLLAR_NUMBER:
				case Identifier:
				case QuotedIdentifier:
				case Character_String_Literal:
				case BeginDollarStringConstant:
					{
					State = 641; vex(0);
					}
					break;
				case DEFAULT:
					{
					State = 642; Match(DEFAULT);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				}
				State = 649;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 650; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Partition_by_columnsContext : ParserRuleContext {
		public ITerminalNode PARTITION() { return GetToken(PlPgSqlParser.PARTITION, 0); }
		public ITerminalNode BY() { return GetToken(PlPgSqlParser.BY, 0); }
		public VexContext[] vex() {
			return GetRuleContexts<VexContext>();
		}
		public VexContext vex(int i) {
			return GetRuleContext<VexContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlPgSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlPgSqlParser.COMMA, i);
		}
		public Partition_by_columnsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_partition_by_columns; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPartition_by_columns(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Partition_by_columnsContext partition_by_columns() {
		Partition_by_columnsContext _localctx = new Partition_by_columnsContext(Context, State);
		EnterRule(_localctx, 48, RULE_partition_by_columns);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 652; Match(PARTITION);
			State = 653; Match(BY);
			State = 654; vex(0);
			State = 659;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 655; Match(COMMA);
				State = 656; vex(0);
				}
				}
				State = 661;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Schema_qualified_nameContext : ParserRuleContext {
		public IdentifierContext[] identifier() {
			return GetRuleContexts<IdentifierContext>();
		}
		public IdentifierContext identifier(int i) {
			return GetRuleContext<IdentifierContext>(i);
		}
		public ITerminalNode[] DOT() { return GetTokens(PlPgSqlParser.DOT); }
		public ITerminalNode DOT(int i) {
			return GetToken(PlPgSqlParser.DOT, i);
		}
		public Schema_qualified_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_schema_qualified_name; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSchema_qualified_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Schema_qualified_nameContext schema_qualified_name() {
		Schema_qualified_nameContext _localctx = new Schema_qualified_nameContext(Context, State);
		EnterRule(_localctx, 50, RULE_schema_qualified_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 662; identifier();
			State = 669;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,60,Context) ) {
			case 1:
				{
				State = 663; Match(DOT);
				State = 664; identifier();
				State = 667;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,59,Context) ) {
				case 1:
					{
					State = 665; Match(DOT);
					State = 666; identifier();
					}
					break;
				}
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Select_listContext : ParserRuleContext {
		public Select_sublistContext[] select_sublist() {
			return GetRuleContexts<Select_sublistContext>();
		}
		public Select_sublistContext select_sublist(int i) {
			return GetRuleContext<Select_sublistContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlPgSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlPgSqlParser.COMMA, i);
		}
		public Select_listContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_select_list; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSelect_list(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Select_listContext select_list() {
		Select_listContext _localctx = new Select_listContext(Context, State);
		EnterRule(_localctx, 52, RULE_select_list);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 671; select_sublist();
			State = 676;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,61,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 672; Match(COMMA);
					State = 673; select_sublist();
					}
					} 
				}
				State = 678;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,61,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Select_sublistContext : ParserRuleContext {
		public VexContext vex() {
			return GetRuleContext<VexContext>(0);
		}
		public ITerminalNode AS() { return GetToken(PlPgSqlParser.AS, 0); }
		public Col_labelContext col_label() {
			return GetRuleContext<Col_labelContext>(0);
		}
		public Id_tokenContext id_token() {
			return GetRuleContext<Id_tokenContext>(0);
		}
		public Select_sublistContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_select_sublist; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSelect_sublist(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Select_sublistContext select_sublist() {
		Select_sublistContext _localctx = new Select_sublistContext(Context, State);
		EnterRule(_localctx, 54, RULE_select_sublist);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 679; vex(0);
			State = 683;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,62,Context) ) {
			case 1:
				{
				State = 680; Match(AS);
				State = 681; col_label();
				}
				break;
			case 2:
				{
				State = 682; id_token();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Col_labelContext : ParserRuleContext {
		public Id_tokenContext id_token() {
			return GetRuleContext<Id_tokenContext>(0);
		}
		public Tokens_reservedContext tokens_reserved() {
			return GetRuleContext<Tokens_reservedContext>(0);
		}
		public Tokens_nonreservedContext tokens_nonreserved() {
			return GetRuleContext<Tokens_nonreservedContext>(0);
		}
		public Tokens_nonreserved_except_function_typeContext tokens_nonreserved_except_function_type() {
			return GetRuleContext<Tokens_nonreserved_except_function_typeContext>(0);
		}
		public Col_labelContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_col_label; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCol_label(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Col_labelContext col_label() {
		Col_labelContext _localctx = new Col_labelContext(Context, State);
		EnterRule(_localctx, 56, RULE_col_label);
		try {
			State = 689;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ALIGNMENT:
			case BASETYPE:
			case BUFFERS:
			case BYPASSRLS:
			case CANONICAL:
			case CATEGORY:
			case COLLATABLE:
			case COMBINEFUNC:
			case COMMUTATOR:
			case CONNECT:
			case COSTS:
			case CREATEDB:
			case CREATEROLE:
			case DESERIALFUNC:
			case DETERMINISTIC:
			case DISABLE_PAGE_SKIPPING:
			case ELEMENT:
			case EXTENDED:
			case FINALFUNC:
			case FINALFUNC_EXTRA:
			case FINALFUNC_MODIFY:
			case FORCE_NOT_NULL:
			case FORCE_NULL:
			case FORCE_QUOTE:
			case FORMAT:
			case GETTOKEN:
			case HASH:
			case HASHES:
			case HEADLINE:
			case HYPOTHETICAL:
			case INDEX_CLEANUP:
			case INIT:
			case INITCOND:
			case INTERNALLENGTH:
			case JSON:
			case LC_COLLATE:
			case LC_CTYPE:
			case LEFTARG:
			case LEXIZE:
			case LEXTYPES:
			case LIST:
			case LOCALE:
			case LOGIN:
			case MAIN:
			case MERGES:
			case MFINALFUNC:
			case MFINALFUNC_EXTRA:
			case MFINALFUNC_MODIFY:
			case MINITCOND:
			case MINVFUNC:
			case MODULUS:
			case MSFUNC:
			case MSSPACE:
			case MSTYPE:
			case NEGATOR:
			case NOBYPASSRLS:
			case NOCREATEDB:
			case NOCREATEROLE:
			case NOINHERIT:
			case NOLOGIN:
			case NOREPLICATION:
			case NOSUPERUSER:
			case OUTPUT:
			case PASSEDBYVALUE:
			case PATH:
			case PERMISSIVE:
			case PLAIN:
			case PREFERRED:
			case PROVIDER:
			case READ_ONLY:
			case READ_WRITE:
			case RECEIVE:
			case REMAINDER:
			case REPLICATION:
			case RESTRICTED:
			case RESTRICTIVE:
			case RIGHTARG:
			case SAFE:
			case SEND:
			case SERIALFUNC:
			case SETTINGS:
			case SFUNC:
			case SHAREABLE:
			case SKIP_LOCKED:
			case SORTOP:
			case SSPACE:
			case STYPE:
			case SUBTYPE_DIFF:
			case SUBTYPE_OPCLASS:
			case SUBTYPE:
			case SUMMARY:
			case SUPERUSER:
			case TIMING:
			case TYPMOD_IN:
			case TYPMOD_OUT:
			case UNSAFE:
			case USAGE:
			case VARIABLE:
			case YAML:
			case ALIAS:
			case ASSERT:
			case CONSTANT:
			case DATATYPE:
			case DEBUG:
			case DETAIL:
			case DIAGNOSTICS:
			case ELSEIF:
			case ELSIF:
			case ERRCODE:
			case EXIT:
			case EXCEPTION:
			case FOREACH:
			case GET:
			case HINT:
			case INFO:
			case LOG:
			case LOOP:
			case MESSAGE:
			case NOTICE:
			case OPEN:
			case PERFORM:
			case QUERY:
			case RAISE:
			case RECORD:
			case RETURN:
			case REVERSE:
			case ROWTYPE:
			case SLICE:
			case SQLSTATE:
			case STACKED:
			case WARNING:
			case WHILE:
			case Identifier:
			case QuotedIdentifier:
				EnterOuterAlt(_localctx, 1);
				{
				State = 685; id_token();
				}
				break;
			case ALL:
			case ANALYSE:
			case ANALYZE:
			case AND:
			case ANY:
			case ARRAY:
			case AS:
			case ASC:
			case ASYMMETRIC:
			case BOTH:
			case CASE:
			case CAST:
			case CHECK:
			case COLLATE:
			case COLUMN:
			case CONSTRAINT:
			case CREATE:
			case CURRENT_CATALOG:
			case CURRENT_DATE:
			case CURRENT_ROLE:
			case CURRENT_TIME:
			case CURRENT_TIMESTAMP:
			case CURRENT_USER:
			case DEFAULT:
			case DEFERRABLE:
			case DESC:
			case DISTINCT:
			case DO:
			case ELSE:
			case END:
			case EXCEPT:
			case FALSE:
			case FETCH:
			case FOR:
			case FOREIGN:
			case FROM:
			case GRANT:
			case GROUP:
			case HAVING:
			case IN:
			case INITIALLY:
			case INTERSECT:
			case INTO:
			case LATERAL:
			case LEADING:
			case LIMIT:
			case LOCALTIME:
			case LOCALTIMESTAMP:
			case NOT:
			case NULL:
			case OFFSET:
			case ON:
			case ONLY:
			case OR:
			case ORDER:
			case PLACING:
			case PRIMARY:
			case REFERENCES:
			case RETURNING:
			case SELECT:
			case SESSION_USER:
			case SOME:
			case SYMMETRIC:
			case TABLE:
			case THEN:
			case TO:
			case TRAILING:
			case TRUE:
			case UNION:
			case UNIQUE:
			case USER:
			case USING:
			case VARIADIC:
			case WHEN:
			case WHERE:
			case WINDOW:
			case WITH:
				EnterOuterAlt(_localctx, 2);
				{
				State = 686; tokens_reserved();
				}
				break;
			case ABORT:
			case ABSOLUTE:
			case ACCESS:
			case ACTION:
			case ADD:
			case ADMIN:
			case AFTER:
			case AGGREGATE:
			case ALSO:
			case ALTER:
			case ALWAYS:
			case ASSERTION:
			case ASSIGNMENT:
			case AT:
			case ATTACH:
			case ATTRIBUTE:
			case BACKWARD:
			case BEFORE:
			case BEGIN:
			case BY:
			case CACHE:
			case CALL:
			case CALLED:
			case CASCADE:
			case CASCADED:
			case CATALOG:
			case CHAIN:
			case CHARACTERISTICS:
			case CHECKPOINT:
			case CLASS:
			case CLOSE:
			case CLUSTER:
			case COLUMNS:
			case COMMENT:
			case COMMENTS:
			case COMMIT:
			case COMMITTED:
			case CONFIGURATION:
			case CONFLICT:
			case CONNECTION:
			case CONSTRAINTS:
			case CONTENT:
			case CONTINUE:
			case CONVERSION:
			case COPY:
			case COST:
			case CSV:
			case CUBE:
			case CURRENT:
			case CURSOR:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DAY:
			case DEALLOCATE:
			case DECLARE:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DELIMITER:
			case DELIMITERS:
			case DEPENDS:
			case DETACH:
			case DICTIONARY:
			case DISABLE:
			case DISCARD:
			case DOCUMENT:
			case DOMAIN:
			case DOUBLE:
			case DROP:
			case EACH:
			case ENABLE:
			case ENCODING:
			case ENCRYPTED:
			case ENUM:
			case ESCAPE:
			case EVENT:
			case EXCLUDE:
			case EXCLUDING:
			case EXCLUSIVE:
			case EXECUTE:
			case EXPLAIN:
			case EXTENSION:
			case EXTERNAL:
			case FAMILY:
			case FILTER:
			case FIRST:
			case FOLLOWING:
			case FORCE:
			case FORWARD:
			case FUNCTION:
			case FUNCTIONS:
			case GENERATED:
			case GLOBAL:
			case GRANTED:
			case GROUPS:
			case HANDLER:
			case HEADER:
			case HOLD:
			case HOUR:
			case IDENTITY:
			case IF:
			case IMMEDIATE:
			case IMMUTABLE:
			case IMPLICIT:
			case IMPORT:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDEX:
			case INDEXES:
			case INHERIT:
			case INHERITS:
			case INLINE:
			case INPUT:
			case INSENSITIVE:
			case INSERT:
			case INSTEAD:
			case INVOKER:
			case ISOLATION:
			case KEY:
			case LABEL:
			case LANGUAGE:
			case LARGE:
			case LAST:
			case LEAKPROOF:
			case LEVEL:
			case LISTEN:
			case LOAD:
			case LOCAL:
			case LOCATION:
			case LOCK:
			case LOCKED:
			case LOGGED:
			case MAPPING:
			case MATCH:
			case MATERIALIZED:
			case MAXVALUE:
			case METHOD:
			case MINUTE:
			case MINVALUE:
			case MODE:
			case MONTH:
			case MOVE:
			case NAME:
			case NAMES:
			case NEW:
			case NEXT:
			case NO:
			case NOTHING:
			case NOTIFY:
			case NOWAIT:
			case NULLS:
			case OBJECT:
			case OF:
			case OFF:
			case OIDS:
			case OLD:
			case OPERATOR:
			case OPTION:
			case OPTIONS:
			case ORDINALITY:
			case OTHERS:
			case OVER:
			case OVERRIDING:
			case OWNED:
			case OWNER:
			case PARALLEL:
			case PARSER:
			case PARTIAL:
			case PARTITION:
			case PASSING:
			case PASSWORD:
			case PLANS:
			case POLICY:
			case PRECEDING:
			case PREPARE:
			case PREPARED:
			case PRESERVE:
			case PRIOR:
			case PRIVILEGES:
			case PROCEDURAL:
			case PROCEDURE:
			case PROCEDURES:
			case PROGRAM:
			case PUBLICATION:
			case QUOTE:
			case RANGE:
			case READ:
			case REASSIGN:
			case RECHECK:
			case RECURSIVE:
			case REF:
			case REFERENCING:
			case REFRESH:
			case REINDEX:
			case RELATIVE:
			case RELEASE:
			case RENAME:
			case REPEATABLE:
			case REPLACE:
			case REPLICA:
			case RESET:
			case RESTART:
			case RESTRICT:
			case RETURNS:
			case REVOKE:
			case ROLE:
			case ROLLBACK:
			case ROLLUP:
			case ROUTINE:
			case ROUTINES:
			case ROWS:
			case RULE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMAS:
			case SCROLL:
			case SEARCH:
			case SECOND:
			case SECURITY:
			case SEQUENCE:
			case SEQUENCES:
			case SERIALIZABLE:
			case SERVER:
			case SESSION:
			case SET:
			case SETS:
			case SHARE:
			case SHOW:
			case SIMPLE:
			case SKIP_:
			case SNAPSHOT:
			case SQL:
			case STABLE:
			case STANDALONE:
			case START:
			case STATEMENT:
			case STATISTICS:
			case STDIN:
			case STDOUT:
			case STORAGE:
			case STORED:
			case STRICT:
			case STRIP:
			case SUBSCRIPTION:
			case SUPPORT:
			case SYSID:
			case SYSTEM:
			case TABLES:
			case TABLESPACE:
			case TEMP:
			case TEMPLATE:
			case TEMPORARY:
			case TEXT:
			case TIES:
			case TRANSACTION:
			case TRANSFORM:
			case TRIGGER:
			case TRUNCATE:
			case TRUSTED:
			case TYPE:
			case TYPES:
			case UNBOUNDED:
			case UNCOMMITTED:
			case UNENCRYPTED:
			case UNKNOWN:
			case UNLISTEN:
			case UNLOGGED:
			case UNTIL:
			case UPDATE:
			case VACUUM:
			case VALID:
			case VALIDATE:
			case VALIDATOR:
			case VALUE:
			case VARYING:
			case VERSION:
			case VIEW:
			case VIEWS:
			case VOLATILE:
			case WHITESPACE:
			case WITHIN:
			case WITHOUT:
			case WORK:
			case WRAPPER:
			case WRITE:
			case XML:
			case YEAR:
			case YES:
			case ZONE:
				EnterOuterAlt(_localctx, 3);
				{
				State = 687; tokens_nonreserved();
				}
				break;
			case BETWEEN:
			case BIGINT:
			case BIT:
			case BOOLEAN:
			case CHAR:
			case CHARACTER:
			case COALESCE:
			case DEC:
			case DECIMAL:
			case EXISTS:
			case EXTRACT:
			case FLOAT:
			case GREATEST:
			case GROUPING:
			case INOUT:
			case INT:
			case INTEGER:
			case INTERVAL:
			case LEAST:
			case NATIONAL:
			case NCHAR:
			case NONE:
			case NULLIF:
			case NUMERIC:
			case OUT:
			case OVERLAY:
			case POSITION:
			case PRECISION:
			case REAL:
			case ROW:
			case SETOF:
			case SMALLINT:
			case SUBSTRING:
			case TIME:
			case TIMESTAMP:
			case TREAT:
			case TRIM:
			case VALUES:
			case VARCHAR:
			case XMLATTRIBUTES:
			case XMLCONCAT:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
				EnterOuterAlt(_localctx, 4);
				{
				State = 688; tokens_nonreserved_except_function_type();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Groupby_clauseContext : ParserRuleContext {
		public ITerminalNode GROUP() { return GetToken(PlPgSqlParser.GROUP, 0); }
		public ITerminalNode BY() { return GetToken(PlPgSqlParser.BY, 0); }
		public Grouping_element_listContext grouping_element_list() {
			return GetRuleContext<Grouping_element_listContext>(0);
		}
		public Groupby_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_groupby_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGroupby_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Groupby_clauseContext groupby_clause() {
		Groupby_clauseContext _localctx = new Groupby_clauseContext(Context, State);
		EnterRule(_localctx, 58, RULE_groupby_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 691; Match(GROUP);
			State = 692; Match(BY);
			State = 693; grouping_element_list();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Grouping_element_listContext : ParserRuleContext {
		public Grouping_elementContext[] grouping_element() {
			return GetRuleContexts<Grouping_elementContext>();
		}
		public Grouping_elementContext grouping_element(int i) {
			return GetRuleContext<Grouping_elementContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlPgSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlPgSqlParser.COMMA, i);
		}
		public Grouping_element_listContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_grouping_element_list; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGrouping_element_list(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Grouping_element_listContext grouping_element_list() {
		Grouping_element_listContext _localctx = new Grouping_element_listContext(Context, State);
		EnterRule(_localctx, 60, RULE_grouping_element_list);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 695; grouping_element();
			State = 700;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,64,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 696; Match(COMMA);
					State = 697; grouping_element();
					}
					} 
				}
				State = 702;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,64,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Grouping_elementContext : ParserRuleContext {
		public VexContext vex() {
			return GetRuleContext<VexContext>(0);
		}
		public ITerminalNode LEFT_PAREN() { return GetToken(PlPgSqlParser.LEFT_PAREN, 0); }
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlPgSqlParser.RIGHT_PAREN, 0); }
		public Grouping_element_listContext grouping_element_list() {
			return GetRuleContext<Grouping_element_listContext>(0);
		}
		public ITerminalNode ROLLUP() { return GetToken(PlPgSqlParser.ROLLUP, 0); }
		public ITerminalNode CUBE() { return GetToken(PlPgSqlParser.CUBE, 0); }
		public ITerminalNode GROUPING() { return GetToken(PlPgSqlParser.GROUPING, 0); }
		public ITerminalNode SETS() { return GetToken(PlPgSqlParser.SETS, 0); }
		public Grouping_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_grouping_element; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGrouping_element(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Grouping_elementContext grouping_element() {
		Grouping_elementContext _localctx = new Grouping_elementContext(Context, State);
		EnterRule(_localctx, 62, RULE_grouping_element);
		try {
			State = 716;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,66,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 703; vex(0);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 704; Match(LEFT_PAREN);
				State = 705; Match(RIGHT_PAREN);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 710;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case ROLLUP:
					{
					State = 706; Match(ROLLUP);
					}
					break;
				case CUBE:
					{
					State = 707; Match(CUBE);
					}
					break;
				case GROUPING:
					{
					State = 708; Match(GROUPING);
					State = 709; Match(SETS);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 712; Match(LEFT_PAREN);
				State = 713; grouping_element_list();
				State = 714; Match(RIGHT_PAREN);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class From_itemContext : ParserRuleContext {
		public ITerminalNode LEFT_PAREN() { return GetToken(PlPgSqlParser.LEFT_PAREN, 0); }
		public From_itemContext[] from_item() {
			return GetRuleContexts<From_itemContext>();
		}
		public From_itemContext from_item(int i) {
			return GetRuleContext<From_itemContext>(i);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlPgSqlParser.RIGHT_PAREN, 0); }
		public Alias_clauseContext alias_clause() {
			return GetRuleContext<Alias_clauseContext>(0);
		}
		public From_primaryContext from_primary() {
			return GetRuleContext<From_primaryContext>(0);
		}
		public ITerminalNode CROSS() { return GetToken(PlPgSqlParser.CROSS, 0); }
		public ITerminalNode JOIN() { return GetToken(PlPgSqlParser.JOIN, 0); }
		public ITerminalNode NATURAL() { return GetToken(PlPgSqlParser.NATURAL, 0); }
		public ITerminalNode INNER() { return GetToken(PlPgSqlParser.INNER, 0); }
		public ITerminalNode LEFT() { return GetToken(PlPgSqlParser.LEFT, 0); }
		public ITerminalNode RIGHT() { return GetToken(PlPgSqlParser.RIGHT, 0); }
		public ITerminalNode FULL() { return GetToken(PlPgSqlParser.FULL, 0); }
		public ITerminalNode OUTER() { return GetToken(PlPgSqlParser.OUTER, 0); }
		public ITerminalNode ON() { return GetToken(PlPgSqlParser.ON, 0); }
		public VexContext vex() {
			return GetRuleContext<VexContext>(0);
		}
		public ITerminalNode USING() { return GetToken(PlPgSqlParser.USING, 0); }
		public Names_in_parensContext names_in_parens() {
			return GetRuleContext<Names_in_parensContext>(0);
		}
		public From_itemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_from_item; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFrom_item(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public From_itemContext from_item() {
		return from_item(0);
	}

	private From_itemContext from_item(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		From_itemContext _localctx = new From_itemContext(Context, _parentState);
		From_itemContext _prevctx = _localctx;
		int _startState = 64;
		EnterRecursionRule(_localctx, 64, RULE_from_item, _p);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 726;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,68,Context) ) {
			case 1:
				{
				State = 719; Match(LEFT_PAREN);
				State = 720; from_item(0);
				State = 721; Match(RIGHT_PAREN);
				State = 723;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,67,Context) ) {
				case 1:
					{
					State = 722; alias_clause();
					}
					break;
				}
				}
				break;
			case 2:
				{
				State = 725; from_primary();
				}
				break;
			}
			Context.Stop = TokenStream.LT(-1);
			State = 771;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,76,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 769;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,75,Context) ) {
					case 1:
						{
						_localctx = new From_itemContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_from_item);
						State = 728;
						if (!(Precpred(Context, 5))) throw new FailedPredicateException(this, "Precpred(Context, 5)");
						State = 729; Match(CROSS);
						State = 730; Match(JOIN);
						State = 731; from_item(6);
						}
						break;
					case 2:
						{
						_localctx = new From_itemContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_from_item);
						State = 732;
						if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
						State = 733; Match(NATURAL);
						State = 739;
						ErrorHandler.Sync(this);
						switch (TokenStream.LA(1)) {
						case INNER:
							{
							State = 734; Match(INNER);
							}
							break;
						case FULL:
						case LEFT:
						case RIGHT:
							{
							State = 735;
							_la = TokenStream.LA(1);
							if ( !(((((_la - 350)) & ~0x3f) == 0 && ((1L << (_la - 350)) & ((1L << (FULL - 350)) | (1L << (LEFT - 350)) | (1L << (RIGHT - 350)))) != 0)) ) {
							ErrorHandler.RecoverInline(this);
							}
							else {
								ErrorHandler.ReportMatch(this);
							    Consume();
							}
							State = 737;
							ErrorHandler.Sync(this);
							_la = TokenStream.LA(1);
							if (_la==OUTER) {
								{
								State = 736; Match(OUTER);
								}
							}

							}
							break;
						case JOIN:
							break;
						default:
							break;
						}
						State = 741; Match(JOIN);
						State = 742; from_item(3);
						}
						break;
					case 3:
						{
						_localctx = new From_itemContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_from_item);
						State = 743;
						if (!(Precpred(Context, 4))) throw new FailedPredicateException(this, "Precpred(Context, 4)");
						State = 749;
						ErrorHandler.Sync(this);
						switch (TokenStream.LA(1)) {
						case INNER:
							{
							State = 744; Match(INNER);
							}
							break;
						case FULL:
						case LEFT:
						case RIGHT:
							{
							State = 745;
							_la = TokenStream.LA(1);
							if ( !(((((_la - 350)) & ~0x3f) == 0 && ((1L << (_la - 350)) & ((1L << (FULL - 350)) | (1L << (LEFT - 350)) | (1L << (RIGHT - 350)))) != 0)) ) {
							ErrorHandler.RecoverInline(this);
							}
							else {
								ErrorHandler.ReportMatch(this);
							    Consume();
							}
							State = 747;
							ErrorHandler.Sync(this);
							_la = TokenStream.LA(1);
							if (_la==OUTER) {
								{
								State = 746; Match(OUTER);
								}
							}

							}
							break;
						case JOIN:
							break;
						default:
							break;
						}
						State = 751; Match(JOIN);
						State = 752; from_item(0);
						State = 753; Match(ON);
						State = 754; vex(0);
						}
						break;
					case 4:
						{
						_localctx = new From_itemContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_from_item);
						State = 756;
						if (!(Precpred(Context, 3))) throw new FailedPredicateException(this, "Precpred(Context, 3)");
						State = 762;
						ErrorHandler.Sync(this);
						switch (TokenStream.LA(1)) {
						case INNER:
							{
							State = 757; Match(INNER);
							}
							break;
						case FULL:
						case LEFT:
						case RIGHT:
							{
							State = 758;
							_la = TokenStream.LA(1);
							if ( !(((((_la - 350)) & ~0x3f) == 0 && ((1L << (_la - 350)) & ((1L << (FULL - 350)) | (1L << (LEFT - 350)) | (1L << (RIGHT - 350)))) != 0)) ) {
							ErrorHandler.RecoverInline(this);
							}
							else {
								ErrorHandler.ReportMatch(this);
							    Consume();
							}
							State = 760;
							ErrorHandler.Sync(this);
							_la = TokenStream.LA(1);
							if (_la==OUTER) {
								{
								State = 759; Match(OUTER);
								}
							}

							}
							break;
						case JOIN:
							break;
						default:
							break;
						}
						State = 764; Match(JOIN);
						State = 765; from_item(0);
						State = 766; Match(USING);
						State = 767; names_in_parens();
						}
						break;
					}
					} 
				}
				State = 773;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,76,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class From_primaryContext : ParserRuleContext {
		public IdentifierContext method;
		public IdentifierContext alias;
		public IdentifierContext _identifier;
		public IList<IdentifierContext> _column_alias = new List<IdentifierContext>();
		public Schema_qualified_nameContext schema_qualified_name() {
			return GetRuleContext<Schema_qualified_nameContext>(0);
		}
		public ITerminalNode ONLY() { return GetToken(PlPgSqlParser.ONLY, 0); }
		public ITerminalNode MULTIPLY() { return GetToken(PlPgSqlParser.MULTIPLY, 0); }
		public Alias_clauseContext alias_clause() {
			return GetRuleContext<Alias_clauseContext>(0);
		}
		public ITerminalNode TABLESAMPLE() { return GetToken(PlPgSqlParser.TABLESAMPLE, 0); }
		public ITerminalNode[] LEFT_PAREN() { return GetTokens(PlPgSqlParser.LEFT_PAREN); }
		public ITerminalNode LEFT_PAREN(int i) {
			return GetToken(PlPgSqlParser.LEFT_PAREN, i);
		}
		public VexContext[] vex() {
			return GetRuleContexts<VexContext>();
		}
		public VexContext vex(int i) {
			return GetRuleContext<VexContext>(i);
		}
		public ITerminalNode[] RIGHT_PAREN() { return GetTokens(PlPgSqlParser.RIGHT_PAREN); }
		public ITerminalNode RIGHT_PAREN(int i) {
			return GetToken(PlPgSqlParser.RIGHT_PAREN, i);
		}
		public IdentifierContext[] identifier() {
			return GetRuleContexts<IdentifierContext>();
		}
		public IdentifierContext identifier(int i) {
			return GetRuleContext<IdentifierContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlPgSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlPgSqlParser.COMMA, i);
		}
		public ITerminalNode REPEATABLE() { return GetToken(PlPgSqlParser.REPEATABLE, 0); }
		public Table_subqueryContext table_subquery() {
			return GetRuleContext<Table_subqueryContext>(0);
		}
		public ITerminalNode LATERAL() { return GetToken(PlPgSqlParser.LATERAL, 0); }
		public Function_callContext[] function_call() {
			return GetRuleContexts<Function_callContext>();
		}
		public Function_callContext function_call(int i) {
			return GetRuleContext<Function_callContext>(i);
		}
		public ITerminalNode WITH() { return GetToken(PlPgSqlParser.WITH, 0); }
		public ITerminalNode ORDINALITY() { return GetToken(PlPgSqlParser.ORDINALITY, 0); }
		public ITerminalNode[] AS() { return GetTokens(PlPgSqlParser.AS); }
		public ITerminalNode AS(int i) {
			return GetToken(PlPgSqlParser.AS, i);
		}
		public From_function_column_defContext[] from_function_column_def() {
			return GetRuleContexts<From_function_column_defContext>();
		}
		public From_function_column_defContext from_function_column_def(int i) {
			return GetRuleContext<From_function_column_defContext>(i);
		}
		public ITerminalNode ROWS() { return GetToken(PlPgSqlParser.ROWS, 0); }
		public ITerminalNode FROM() { return GetToken(PlPgSqlParser.FROM, 0); }
		public From_primaryContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_from_primary; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFrom_primary(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public From_primaryContext from_primary() {
		From_primaryContext _localctx = new From_primaryContext(Context, State);
		EnterRule(_localctx, 66, RULE_from_primary);
		int _la;
		try {
			State = 884;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,99,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 775;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ONLY) {
					{
					State = 774; Match(ONLY);
					}
				}

				State = 777; schema_qualified_name();
				State = 779;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,78,Context) ) {
				case 1:
					{
					State = 778; Match(MULTIPLY);
					}
					break;
				}
				State = 782;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,79,Context) ) {
				case 1:
					{
					State = 781; alias_clause();
					}
					break;
				}
				State = 800;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,82,Context) ) {
				case 1:
					{
					State = 784; Match(TABLESAMPLE);
					State = 785; _localctx.method = identifier();
					State = 786; Match(LEFT_PAREN);
					State = 787; vex(0);
					State = 792;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					while (_la==COMMA) {
						{
						{
						State = 788; Match(COMMA);
						State = 789; vex(0);
						}
						}
						State = 794;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					}
					State = 795; Match(RIGHT_PAREN);
					State = 798;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,81,Context) ) {
					case 1:
						{
						State = 796; Match(REPEATABLE);
						State = 797; vex(0);
						}
						break;
					}
					}
					break;
				}
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 803;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LATERAL) {
					{
					State = 802; Match(LATERAL);
					}
				}

				State = 805; table_subquery();
				State = 806; alias_clause();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 809;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LATERAL) {
					{
					State = 808; Match(LATERAL);
					}
				}

				State = 811; function_call();
				State = 814;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,85,Context) ) {
				case 1:
					{
					State = 812; Match(WITH);
					State = 813; Match(ORDINALITY);
					}
					break;
				}
				State = 836;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,89,Context) ) {
				case 1:
					{
					State = 816; Match(AS);
					State = 817; from_function_column_def();
					}
					break;
				case 2:
					{
					State = 819;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==AS) {
						{
						State = 818; Match(AS);
						}
					}

					State = 821; _localctx.alias = identifier();
					State = 834;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,88,Context) ) {
					case 1:
						{
						State = 822; Match(LEFT_PAREN);
						State = 823; _localctx._identifier = identifier();
						_localctx._column_alias.Add(_localctx._identifier);
						State = 828;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						while (_la==COMMA) {
							{
							{
							State = 824; Match(COMMA);
							State = 825; _localctx._identifier = identifier();
							_localctx._column_alias.Add(_localctx._identifier);
							}
							}
							State = 830;
							ErrorHandler.Sync(this);
							_la = TokenStream.LA(1);
						}
						State = 831; Match(RIGHT_PAREN);
						}
						break;
					case 2:
						{
						State = 833; from_function_column_def();
						}
						break;
					}
					}
					break;
				}
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 839;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LATERAL) {
					{
					State = 838; Match(LATERAL);
					}
				}

				State = 841; Match(ROWS);
				State = 842; Match(FROM);
				State = 843; Match(LEFT_PAREN);
				State = 844; function_call();
				State = 847;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==AS) {
					{
					State = 845; Match(AS);
					State = 846; from_function_column_def();
					}
				}

				State = 857;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 849; Match(COMMA);
					State = 850; function_call();
					State = 853;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==AS) {
						{
						State = 851; Match(AS);
						State = 852; from_function_column_def();
						}
					}

					}
					}
					State = 859;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 860; Match(RIGHT_PAREN);
				State = 863;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,94,Context) ) {
				case 1:
					{
					State = 861; Match(WITH);
					State = 862; Match(ORDINALITY);
					}
					break;
				}
				State = 882;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,98,Context) ) {
				case 1:
					{
					State = 866;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==AS) {
						{
						State = 865; Match(AS);
						}
					}

					State = 868; _localctx.alias = identifier();
					State = 880;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,97,Context) ) {
					case 1:
						{
						State = 869; Match(LEFT_PAREN);
						State = 870; _localctx._identifier = identifier();
						_localctx._column_alias.Add(_localctx._identifier);
						State = 875;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						while (_la==COMMA) {
							{
							{
							State = 871; Match(COMMA);
							State = 872; _localctx._identifier = identifier();
							_localctx._column_alias.Add(_localctx._identifier);
							}
							}
							State = 877;
							ErrorHandler.Sync(this);
							_la = TokenStream.LA(1);
						}
						State = 878; Match(RIGHT_PAREN);
						}
						break;
					}
					}
					break;
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class From_function_column_defContext : ParserRuleContext {
		public IdentifierContext _identifier;
		public IList<IdentifierContext> _column_alias = new List<IdentifierContext>();
		public ITerminalNode LEFT_PAREN() { return GetToken(PlPgSqlParser.LEFT_PAREN, 0); }
		public Data_typeContext[] data_type() {
			return GetRuleContexts<Data_typeContext>();
		}
		public Data_typeContext data_type(int i) {
			return GetRuleContext<Data_typeContext>(i);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlPgSqlParser.RIGHT_PAREN, 0); }
		public IdentifierContext[] identifier() {
			return GetRuleContexts<IdentifierContext>();
		}
		public IdentifierContext identifier(int i) {
			return GetRuleContext<IdentifierContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlPgSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlPgSqlParser.COMMA, i);
		}
		public From_function_column_defContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_from_function_column_def; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFrom_function_column_def(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public From_function_column_defContext from_function_column_def() {
		From_function_column_defContext _localctx = new From_function_column_defContext(Context, State);
		EnterRule(_localctx, 68, RULE_from_function_column_def);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 886; Match(LEFT_PAREN);
			State = 887; _localctx._identifier = identifier();
			_localctx._column_alias.Add(_localctx._identifier);
			State = 888; data_type();
			State = 895;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 889; Match(COMMA);
				State = 890; _localctx._identifier = identifier();
				_localctx._column_alias.Add(_localctx._identifier);
				State = 891; data_type();
				}
				}
				State = 897;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 898; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Data_typeContext : ParserRuleContext {
		public Predefined_typeContext predefined_type() {
			return GetRuleContext<Predefined_typeContext>(0);
		}
		public ITerminalNode SETOF() { return GetToken(PlPgSqlParser.SETOF, 0); }
		public ITerminalNode ARRAY() { return GetToken(PlPgSqlParser.ARRAY, 0); }
		public Array_typeContext[] array_type() {
			return GetRuleContexts<Array_typeContext>();
		}
		public Array_typeContext array_type(int i) {
			return GetRuleContext<Array_typeContext>(i);
		}
		public Data_typeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_data_type; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitData_type(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Data_typeContext data_type() {
		Data_typeContext _localctx = new Data_typeContext(Context, State);
		EnterRule(_localctx, 70, RULE_data_type);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 901;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,101,Context) ) {
			case 1:
				{
				State = 900; Match(SETOF);
				}
				break;
			}
			State = 903; predefined_type();
			State = 913;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,104,Context) ) {
			case 1:
				{
				State = 904; Match(ARRAY);
				State = 906;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,102,Context) ) {
				case 1:
					{
					State = 905; array_type();
					}
					break;
				}
				}
				break;
			case 2:
				{
				State = 909;
				ErrorHandler.Sync(this);
				_alt = 1;
				do {
					switch (_alt) {
					case 1:
						{
						{
						State = 908; array_type();
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 911;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,103,Context);
				} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Array_typeContext : ParserRuleContext {
		public ITerminalNode LEFT_BRACKET() { return GetToken(PlPgSqlParser.LEFT_BRACKET, 0); }
		public ITerminalNode RIGHT_BRACKET() { return GetToken(PlPgSqlParser.RIGHT_BRACKET, 0); }
		public ITerminalNode NUMBER_LITERAL() { return GetToken(PlPgSqlParser.NUMBER_LITERAL, 0); }
		public Array_typeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_array_type; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArray_type(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Array_typeContext array_type() {
		Array_typeContext _localctx = new Array_typeContext(Context, State);
		EnterRule(_localctx, 72, RULE_array_type);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 915; Match(LEFT_BRACKET);
			State = 917;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NUMBER_LITERAL) {
				{
				State = 916; Match(NUMBER_LITERAL);
				}
			}

			State = 919; Match(RIGHT_BRACKET);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Predefined_typeContext : ParserRuleContext {
		public ITerminalNode BIGINT() { return GetToken(PlPgSqlParser.BIGINT, 0); }
		public ITerminalNode BIT() { return GetToken(PlPgSqlParser.BIT, 0); }
		public ITerminalNode VARYING() { return GetToken(PlPgSqlParser.VARYING, 0); }
		public Type_lengthContext type_length() {
			return GetRuleContext<Type_lengthContext>(0);
		}
		public ITerminalNode BOOLEAN() { return GetToken(PlPgSqlParser.BOOLEAN, 0); }
		public ITerminalNode DEC() { return GetToken(PlPgSqlParser.DEC, 0); }
		public Precision_paramContext precision_param() {
			return GetRuleContext<Precision_paramContext>(0);
		}
		public ITerminalNode DECIMAL() { return GetToken(PlPgSqlParser.DECIMAL, 0); }
		public ITerminalNode DOUBLE() { return GetToken(PlPgSqlParser.DOUBLE, 0); }
		public ITerminalNode PRECISION() { return GetToken(PlPgSqlParser.PRECISION, 0); }
		public ITerminalNode FLOAT() { return GetToken(PlPgSqlParser.FLOAT, 0); }
		public ITerminalNode INT() { return GetToken(PlPgSqlParser.INT, 0); }
		public ITerminalNode INTEGER() { return GetToken(PlPgSqlParser.INTEGER, 0); }
		public ITerminalNode INTERVAL() { return GetToken(PlPgSqlParser.INTERVAL, 0); }
		public Interval_fieldContext interval_field() {
			return GetRuleContext<Interval_fieldContext>(0);
		}
		public ITerminalNode CHARACTER() { return GetToken(PlPgSqlParser.CHARACTER, 0); }
		public ITerminalNode CHAR() { return GetToken(PlPgSqlParser.CHAR, 0); }
		public ITerminalNode NATIONAL() { return GetToken(PlPgSqlParser.NATIONAL, 0); }
		public ITerminalNode NCHAR() { return GetToken(PlPgSqlParser.NCHAR, 0); }
		public ITerminalNode NUMERIC() { return GetToken(PlPgSqlParser.NUMERIC, 0); }
		public ITerminalNode REAL() { return GetToken(PlPgSqlParser.REAL, 0); }
		public ITerminalNode SMALLINT() { return GetToken(PlPgSqlParser.SMALLINT, 0); }
		public ITerminalNode[] TIME() { return GetTokens(PlPgSqlParser.TIME); }
		public ITerminalNode TIME(int i) {
			return GetToken(PlPgSqlParser.TIME, i);
		}
		public ITerminalNode ZONE() { return GetToken(PlPgSqlParser.ZONE, 0); }
		public ITerminalNode WITH() { return GetToken(PlPgSqlParser.WITH, 0); }
		public ITerminalNode WITHOUT() { return GetToken(PlPgSqlParser.WITHOUT, 0); }
		public ITerminalNode TIMESTAMP() { return GetToken(PlPgSqlParser.TIMESTAMP, 0); }
		public ITerminalNode VARCHAR() { return GetToken(PlPgSqlParser.VARCHAR, 0); }
		public Schema_qualified_name_nontypeContext schema_qualified_name_nontype() {
			return GetRuleContext<Schema_qualified_name_nontypeContext>(0);
		}
		public ITerminalNode LEFT_PAREN() { return GetToken(PlPgSqlParser.LEFT_PAREN, 0); }
		public VexContext[] vex() {
			return GetRuleContexts<VexContext>();
		}
		public VexContext vex(int i) {
			return GetRuleContext<VexContext>(i);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlPgSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(PlPgSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlPgSqlParser.COMMA, i);
		}
		public Predefined_typeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_predefined_type; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPredefined_type(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Predefined_typeContext predefined_type() {
		Predefined_typeContext _localctx = new Predefined_typeContext(Context, State);
		EnterRule(_localctx, 74, RULE_predefined_type);
		int _la;
		try {
			State = 1012;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,126,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 921; Match(BIGINT);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 922; Match(BIT);
				State = 924;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,106,Context) ) {
				case 1:
					{
					State = 923; Match(VARYING);
					}
					break;
				}
				State = 927;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,107,Context) ) {
				case 1:
					{
					State = 926; type_length();
					}
					break;
				}
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 929; Match(BOOLEAN);
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 930; Match(DEC);
				State = 932;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,108,Context) ) {
				case 1:
					{
					State = 931; precision_param();
					}
					break;
				}
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 934; Match(DECIMAL);
				State = 936;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,109,Context) ) {
				case 1:
					{
					State = 935; precision_param();
					}
					break;
				}
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 938; Match(DOUBLE);
				State = 939; Match(PRECISION);
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 940; Match(FLOAT);
				State = 942;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,110,Context) ) {
				case 1:
					{
					State = 941; precision_param();
					}
					break;
				}
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 944; Match(INT);
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 945; Match(INTEGER);
				}
				break;
			case 10:
				EnterOuterAlt(_localctx, 10);
				{
				State = 946; Match(INTERVAL);
				State = 948;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,111,Context) ) {
				case 1:
					{
					State = 947; interval_field();
					}
					break;
				}
				State = 951;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,112,Context) ) {
				case 1:
					{
					State = 950; type_length();
					}
					break;
				}
				}
				break;
			case 11:
				EnterOuterAlt(_localctx, 11);
				{
				State = 954;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==NATIONAL) {
					{
					State = 953; Match(NATIONAL);
					}
				}

				State = 956;
				_la = TokenStream.LA(1);
				if ( !(_la==CHAR || _la==CHARACTER) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 958;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,114,Context) ) {
				case 1:
					{
					State = 957; Match(VARYING);
					}
					break;
				}
				State = 961;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,115,Context) ) {
				case 1:
					{
					State = 960; type_length();
					}
					break;
				}
				}
				break;
			case 12:
				EnterOuterAlt(_localctx, 12);
				{
				State = 963; Match(NCHAR);
				State = 965;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,116,Context) ) {
				case 1:
					{
					State = 964; Match(VARYING);
					}
					break;
				}
				State = 968;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,117,Context) ) {
				case 1:
					{
					State = 967; type_length();
					}
					break;
				}
				}
				break;
			case 13:
				EnterOuterAlt(_localctx, 13);
				{
				State = 970; Match(NUMERIC);
				State = 972;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,118,Context) ) {
				case 1:
					{
					State = 971; precision_param();
					}
					break;
				}
				}
				break;
			case 14:
				EnterOuterAlt(_localctx, 14);
				{
				State = 974; Match(REAL);
				}
				break;
			case 15:
				EnterOuterAlt(_localctx, 15);
				{
				State = 975; Match(SMALLINT);
				}
				break;
			case 16:
				EnterOuterAlt(_localctx, 16);
				{
				State = 976; Match(TIME);
				State = 978;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,119,Context) ) {
				case 1:
					{
					State = 977; type_length();
					}
					break;
				}
				State = 983;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,120,Context) ) {
				case 1:
					{
					State = 980;
					_la = TokenStream.LA(1);
					if ( !(_la==WITHOUT || _la==WITH) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					State = 981; Match(TIME);
					State = 982; Match(ZONE);
					}
					break;
				}
				}
				break;
			case 17:
				EnterOuterAlt(_localctx, 17);
				{
				State = 985; Match(TIMESTAMP);
				State = 987;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,121,Context) ) {
				case 1:
					{
					State = 986; type_length();
					}
					break;
				}
				State = 992;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,122,Context) ) {
				case 1:
					{
					State = 989;
					_la = TokenStream.LA(1);
					if ( !(_la==WITHOUT || _la==WITH) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					State = 990; Match(TIME);
					State = 991; Match(ZONE);
					}
					break;
				}
				}
				break;
			case 18:
				EnterOuterAlt(_localctx, 18);
				{
				State = 994; Match(VARCHAR);
				State = 996;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,123,Context) ) {
				case 1:
					{
					State = 995; type_length();
					}
					break;
				}
				}
				break;
			case 19:
				EnterOuterAlt(_localctx, 19);
				{
				State = 998; schema_qualified_name_nontype();
				State = 1010;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,125,Context) ) {
				case 1:
					{
					State = 999; Match(LEFT_PAREN);
					State = 1000; vex(0);
					State = 1005;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					while (_la==COMMA) {
						{
						{
						State = 1001; Match(COMMA);
						State = 1002; vex(0);
						}
						}
						State = 1007;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					}
					State = 1008; Match(RIGHT_PAREN);
					}
					break;
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Schema_qualified_name_nontypeContext : ParserRuleContext {
		public IdentifierContext schema;
		public Identifier_nontypeContext identifier_nontype() {
			return GetRuleContext<Identifier_nontypeContext>(0);
		}
		public ITerminalNode DOT() { return GetToken(PlPgSqlParser.DOT, 0); }
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Schema_qualified_name_nontypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_schema_qualified_name_nontype; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSchema_qualified_name_nontype(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Schema_qualified_name_nontypeContext schema_qualified_name_nontype() {
		Schema_qualified_name_nontypeContext _localctx = new Schema_qualified_name_nontypeContext(Context, State);
		EnterRule(_localctx, 76, RULE_schema_qualified_name_nontype);
		try {
			State = 1019;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,127,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1014; identifier_nontype();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1015; _localctx.schema = identifier();
				State = 1016; Match(DOT);
				State = 1017; identifier_nontype();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Identifier_nontypeContext : ParserRuleContext {
		public Id_tokenContext id_token() {
			return GetRuleContext<Id_tokenContext>(0);
		}
		public Tokens_nonreservedContext tokens_nonreserved() {
			return GetRuleContext<Tokens_nonreservedContext>(0);
		}
		public Tokens_reserved_except_function_typeContext tokens_reserved_except_function_type() {
			return GetRuleContext<Tokens_reserved_except_function_typeContext>(0);
		}
		public Identifier_nontypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifier_nontype; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIdentifier_nontype(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Identifier_nontypeContext identifier_nontype() {
		Identifier_nontypeContext _localctx = new Identifier_nontypeContext(Context, State);
		EnterRule(_localctx, 78, RULE_identifier_nontype);
		try {
			State = 1024;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ALIGNMENT:
			case BASETYPE:
			case BUFFERS:
			case BYPASSRLS:
			case CANONICAL:
			case CATEGORY:
			case COLLATABLE:
			case COMBINEFUNC:
			case COMMUTATOR:
			case CONNECT:
			case COSTS:
			case CREATEDB:
			case CREATEROLE:
			case DESERIALFUNC:
			case DETERMINISTIC:
			case DISABLE_PAGE_SKIPPING:
			case ELEMENT:
			case EXTENDED:
			case FINALFUNC:
			case FINALFUNC_EXTRA:
			case FINALFUNC_MODIFY:
			case FORCE_NOT_NULL:
			case FORCE_NULL:
			case FORCE_QUOTE:
			case FORMAT:
			case GETTOKEN:
			case HASH:
			case HASHES:
			case HEADLINE:
			case HYPOTHETICAL:
			case INDEX_CLEANUP:
			case INIT:
			case INITCOND:
			case INTERNALLENGTH:
			case JSON:
			case LC_COLLATE:
			case LC_CTYPE:
			case LEFTARG:
			case LEXIZE:
			case LEXTYPES:
			case LIST:
			case LOCALE:
			case LOGIN:
			case MAIN:
			case MERGES:
			case MFINALFUNC:
			case MFINALFUNC_EXTRA:
			case MFINALFUNC_MODIFY:
			case MINITCOND:
			case MINVFUNC:
			case MODULUS:
			case MSFUNC:
			case MSSPACE:
			case MSTYPE:
			case NEGATOR:
			case NOBYPASSRLS:
			case NOCREATEDB:
			case NOCREATEROLE:
			case NOINHERIT:
			case NOLOGIN:
			case NOREPLICATION:
			case NOSUPERUSER:
			case OUTPUT:
			case PASSEDBYVALUE:
			case PATH:
			case PERMISSIVE:
			case PLAIN:
			case PREFERRED:
			case PROVIDER:
			case READ_ONLY:
			case READ_WRITE:
			case RECEIVE:
			case REMAINDER:
			case REPLICATION:
			case RESTRICTED:
			case RESTRICTIVE:
			case RIGHTARG:
			case SAFE:
			case SEND:
			case SERIALFUNC:
			case SETTINGS:
			case SFUNC:
			case SHAREABLE:
			case SKIP_LOCKED:
			case SORTOP:
			case SSPACE:
			case STYPE:
			case SUBTYPE_DIFF:
			case SUBTYPE_OPCLASS:
			case SUBTYPE:
			case SUMMARY:
			case SUPERUSER:
			case TIMING:
			case TYPMOD_IN:
			case TYPMOD_OUT:
			case UNSAFE:
			case USAGE:
			case VARIABLE:
			case YAML:
			case ALIAS:
			case ASSERT:
			case CONSTANT:
			case DATATYPE:
			case DEBUG:
			case DETAIL:
			case DIAGNOSTICS:
			case ELSEIF:
			case ELSIF:
			case ERRCODE:
			case EXIT:
			case EXCEPTION:
			case FOREACH:
			case GET:
			case HINT:
			case INFO:
			case LOG:
			case LOOP:
			case MESSAGE:
			case NOTICE:
			case OPEN:
			case PERFORM:
			case QUERY:
			case RAISE:
			case RECORD:
			case RETURN:
			case REVERSE:
			case ROWTYPE:
			case SLICE:
			case SQLSTATE:
			case STACKED:
			case WARNING:
			case WHILE:
			case Identifier:
			case QuotedIdentifier:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1021; id_token();
				}
				break;
			case ABORT:
			case ABSOLUTE:
			case ACCESS:
			case ACTION:
			case ADD:
			case ADMIN:
			case AFTER:
			case AGGREGATE:
			case ALSO:
			case ALTER:
			case ALWAYS:
			case ASSERTION:
			case ASSIGNMENT:
			case AT:
			case ATTACH:
			case ATTRIBUTE:
			case BACKWARD:
			case BEFORE:
			case BEGIN:
			case BY:
			case CACHE:
			case CALL:
			case CALLED:
			case CASCADE:
			case CASCADED:
			case CATALOG:
			case CHAIN:
			case CHARACTERISTICS:
			case CHECKPOINT:
			case CLASS:
			case CLOSE:
			case CLUSTER:
			case COLUMNS:
			case COMMENT:
			case COMMENTS:
			case COMMIT:
			case COMMITTED:
			case CONFIGURATION:
			case CONFLICT:
			case CONNECTION:
			case CONSTRAINTS:
			case CONTENT:
			case CONTINUE:
			case CONVERSION:
			case COPY:
			case COST:
			case CSV:
			case CUBE:
			case CURRENT:
			case CURSOR:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DAY:
			case DEALLOCATE:
			case DECLARE:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DELIMITER:
			case DELIMITERS:
			case DEPENDS:
			case DETACH:
			case DICTIONARY:
			case DISABLE:
			case DISCARD:
			case DOCUMENT:
			case DOMAIN:
			case DOUBLE:
			case DROP:
			case EACH:
			case ENABLE:
			case ENCODING:
			case ENCRYPTED:
			case ENUM:
			case ESCAPE:
			case EVENT:
			case EXCLUDE:
			case EXCLUDING:
			case EXCLUSIVE:
			case EXECUTE:
			case EXPLAIN:
			case EXTENSION:
			case EXTERNAL:
			case FAMILY:
			case FILTER:
			case FIRST:
			case FOLLOWING:
			case FORCE:
			case FORWARD:
			case FUNCTION:
			case FUNCTIONS:
			case GENERATED:
			case GLOBAL:
			case GRANTED:
			case GROUPS:
			case HANDLER:
			case HEADER:
			case HOLD:
			case HOUR:
			case IDENTITY:
			case IF:
			case IMMEDIATE:
			case IMMUTABLE:
			case IMPLICIT:
			case IMPORT:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDEX:
			case INDEXES:
			case INHERIT:
			case INHERITS:
			case INLINE:
			case INPUT:
			case INSENSITIVE:
			case INSERT:
			case INSTEAD:
			case INVOKER:
			case ISOLATION:
			case KEY:
			case LABEL:
			case LANGUAGE:
			case LARGE:
			case LAST:
			case LEAKPROOF:
			case LEVEL:
			case LISTEN:
			case LOAD:
			case LOCAL:
			case LOCATION:
			case LOCK:
			case LOCKED:
			case LOGGED:
			case MAPPING:
			case MATCH:
			case MATERIALIZED:
			case MAXVALUE:
			case METHOD:
			case MINUTE:
			case MINVALUE:
			case MODE:
			case MONTH:
			case MOVE:
			case NAME:
			case NAMES:
			case NEW:
			case NEXT:
			case NO:
			case NOTHING:
			case NOTIFY:
			case NOWAIT:
			case NULLS:
			case OBJECT:
			case OF:
			case OFF:
			case OIDS:
			case OLD:
			case OPERATOR:
			case OPTION:
			case OPTIONS:
			case ORDINALITY:
			case OTHERS:
			case OVER:
			case OVERRIDING:
			case OWNED:
			case OWNER:
			case PARALLEL:
			case PARSER:
			case PARTIAL:
			case PARTITION:
			case PASSING:
			case PASSWORD:
			case PLANS:
			case POLICY:
			case PRECEDING:
			case PREPARE:
			case PREPARED:
			case PRESERVE:
			case PRIOR:
			case PRIVILEGES:
			case PROCEDURAL:
			case PROCEDURE:
			case PROCEDURES:
			case PROGRAM:
			case PUBLICATION:
			case QUOTE:
			case RANGE:
			case READ:
			case REASSIGN:
			case RECHECK:
			case RECURSIVE:
			case REF:
			case REFERENCING:
			case REFRESH:
			case REINDEX:
			case RELATIVE:
			case RELEASE:
			case RENAME:
			case REPEATABLE:
			case REPLACE:
			case REPLICA:
			case RESET:
			case RESTART:
			case RESTRICT:
			case RETURNS:
			case REVOKE:
			case ROLE:
			case ROLLBACK:
			case ROLLUP:
			case ROUTINE:
			case ROUTINES:
			case ROWS:
			case RULE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMAS:
			case SCROLL:
			case SEARCH:
			case SECOND:
			case SECURITY:
			case SEQUENCE:
			case SEQUENCES:
			case SERIALIZABLE:
			case SERVER:
			case SESSION:
			case SET:
			case SETS:
			case SHARE:
			case SHOW:
			case SIMPLE:
			case SKIP_:
			case SNAPSHOT:
			case SQL:
			case STABLE:
			case STANDALONE:
			case START:
			case STATEMENT:
			case STATISTICS:
			case STDIN:
			case STDOUT:
			case STORAGE:
			case STORED:
			case STRICT:
			case STRIP:
			case SUBSCRIPTION:
			case SUPPORT:
			case SYSID:
			case SYSTEM:
			case TABLES:
			case TABLESPACE:
			case TEMP:
			case TEMPLATE:
			case TEMPORARY:
			case TEXT:
			case TIES:
			case TRANSACTION:
			case TRANSFORM:
			case TRIGGER:
			case TRUNCATE:
			case TRUSTED:
			case TYPE:
			case TYPES:
			case UNBOUNDED:
			case UNCOMMITTED:
			case UNENCRYPTED:
			case UNKNOWN:
			case UNLISTEN:
			case UNLOGGED:
			case UNTIL:
			case UPDATE:
			case VACUUM:
			case VALID:
			case VALIDATE:
			case VALIDATOR:
			case VALUE:
			case VARYING:
			case VERSION:
			case VIEW:
			case VIEWS:
			case VOLATILE:
			case WHITESPACE:
			case WITHIN:
			case WITHOUT:
			case WORK:
			case WRAPPER:
			case WRITE:
			case XML:
			case YEAR:
			case YES:
			case ZONE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1022; tokens_nonreserved();
				}
				break;
			case AUTHORIZATION:
			case BINARY:
			case COLLATION:
			case CONCURRENTLY:
			case CROSS:
			case CURRENT_SCHEMA:
			case FREEZE:
			case FULL:
			case ILIKE:
			case INNER:
			case IS:
			case ISNULL:
			case JOIN:
			case LEFT:
			case LIKE:
			case NATURAL:
			case NOTNULL:
			case OUTER:
			case OVERLAPS:
			case RIGHT:
			case SIMILAR:
			case TABLESAMPLE:
			case VERBOSE:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1023; tokens_reserved_except_function_type();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Interval_fieldContext : ParserRuleContext {
		public ITerminalNode YEAR() { return GetToken(PlPgSqlParser.YEAR, 0); }
		public ITerminalNode MONTH() { return GetToken(PlPgSqlParser.MONTH, 0); }
		public ITerminalNode DAY() { return GetToken(PlPgSqlParser.DAY, 0); }
		public ITerminalNode HOUR() { return GetToken(PlPgSqlParser.HOUR, 0); }
		public ITerminalNode MINUTE() { return GetToken(PlPgSqlParser.MINUTE, 0); }
		public ITerminalNode SECOND() { return GetToken(PlPgSqlParser.SECOND, 0); }
		public ITerminalNode TO() { return GetToken(PlPgSqlParser.TO, 0); }
		public Interval_fieldContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_interval_field; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInterval_field(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Interval_fieldContext interval_field() {
		Interval_fieldContext _localctx = new Interval_fieldContext(Context, State);
		EnterRule(_localctx, 80, RULE_interval_field);
		try {
			State = 1053;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,129,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1026; Match(YEAR);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1027; Match(MONTH);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1028; Match(DAY);
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 1029; Match(HOUR);
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 1030; Match(MINUTE);
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 1031; Match(SECOND);
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 1032; Match(YEAR);
				State = 1033; Match(TO);
				State = 1034; Match(MONTH);
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 1035; Match(DAY);
				State = 1036; Match(TO);
				State = 1037; Match(HOUR);
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 1038; Match(DAY);
				State = 1039; Match(TO);
				State = 1040; Match(MINUTE);
				}
				break;
			case 10:
				EnterOuterAlt(_localctx, 10);
				{
				State = 1041; Match(DAY);
				State = 1042; Match(TO);
				State = 1043; Match(SECOND);
				}
				break;
			case 11:
				EnterOuterAlt(_localctx, 11);
				{
				State = 1044; Match(HOUR);
				State = 1045; Match(TO);
				State = 1046; Match(MINUTE);
				}
				break;
			case 12:
				EnterOuterAlt(_localctx, 12);
				{
				State = 1047; Match(HOUR);
				State = 1048; Match(TO);
				State = 1049; Match(SECOND);
				}
				break;
			case 13:
				EnterOuterAlt(_localctx, 13);
				{
				State = 1050; Match(MINUTE);
				State = 1051; Match(TO);
				State = 1052; Match(SECOND);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Type_lengthContext : ParserRuleContext {
		public ITerminalNode LEFT_PAREN() { return GetToken(PlPgSqlParser.LEFT_PAREN, 0); }
		public ITerminalNode NUMBER_LITERAL() { return GetToken(PlPgSqlParser.NUMBER_LITERAL, 0); }
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlPgSqlParser.RIGHT_PAREN, 0); }
		public Type_lengthContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type_length; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType_length(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Type_lengthContext type_length() {
		Type_lengthContext _localctx = new Type_lengthContext(Context, State);
		EnterRule(_localctx, 82, RULE_type_length);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1055; Match(LEFT_PAREN);
			State = 1056; Match(NUMBER_LITERAL);
			State = 1057; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Precision_paramContext : ParserRuleContext {
		public IToken precision;
		public IToken scale;
		public ITerminalNode LEFT_PAREN() { return GetToken(PlPgSqlParser.LEFT_PAREN, 0); }
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlPgSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode[] NUMBER_LITERAL() { return GetTokens(PlPgSqlParser.NUMBER_LITERAL); }
		public ITerminalNode NUMBER_LITERAL(int i) {
			return GetToken(PlPgSqlParser.NUMBER_LITERAL, i);
		}
		public ITerminalNode COMMA() { return GetToken(PlPgSqlParser.COMMA, 0); }
		public Precision_paramContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_precision_param; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPrecision_param(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Precision_paramContext precision_param() {
		Precision_paramContext _localctx = new Precision_paramContext(Context, State);
		EnterRule(_localctx, 84, RULE_precision_param);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1059; Match(LEFT_PAREN);
			State = 1060; _localctx.precision = Match(NUMBER_LITERAL);
			State = 1063;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMMA) {
				{
				State = 1061; Match(COMMA);
				State = 1062; _localctx.scale = Match(NUMBER_LITERAL);
				}
			}

			State = 1065; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Function_callContext : ParserRuleContext {
		public Schema_qualified_name_nontypeContext schema_qualified_name_nontype() {
			return GetRuleContext<Schema_qualified_name_nontypeContext>(0);
		}
		public ITerminalNode[] LEFT_PAREN() { return GetTokens(PlPgSqlParser.LEFT_PAREN); }
		public ITerminalNode LEFT_PAREN(int i) {
			return GetToken(PlPgSqlParser.LEFT_PAREN, i);
		}
		public ITerminalNode[] RIGHT_PAREN() { return GetTokens(PlPgSqlParser.RIGHT_PAREN); }
		public ITerminalNode RIGHT_PAREN(int i) {
			return GetToken(PlPgSqlParser.RIGHT_PAREN, i);
		}
		public Vex_or_named_notationContext[] vex_or_named_notation() {
			return GetRuleContexts<Vex_or_named_notationContext>();
		}
		public Vex_or_named_notationContext vex_or_named_notation(int i) {
			return GetRuleContext<Vex_or_named_notationContext>(i);
		}
		public ITerminalNode WITHIN() { return GetToken(PlPgSqlParser.WITHIN, 0); }
		public ITerminalNode GROUP() { return GetToken(PlPgSqlParser.GROUP, 0); }
		public Orderby_clauseContext[] orderby_clause() {
			return GetRuleContexts<Orderby_clauseContext>();
		}
		public Orderby_clauseContext orderby_clause(int i) {
			return GetRuleContext<Orderby_clauseContext>(i);
		}
		public Filter_clauseContext filter_clause() {
			return GetRuleContext<Filter_clauseContext>(0);
		}
		public ITerminalNode OVER() { return GetToken(PlPgSqlParser.OVER, 0); }
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Window_definitionContext window_definition() {
			return GetRuleContext<Window_definitionContext>(0);
		}
		public Set_qualifierContext set_qualifier() {
			return GetRuleContext<Set_qualifierContext>(0);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlPgSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlPgSqlParser.COMMA, i);
		}
		public Function_constructContext function_construct() {
			return GetRuleContext<Function_constructContext>(0);
		}
		public Extract_functionContext extract_function() {
			return GetRuleContext<Extract_functionContext>(0);
		}
		public System_functionContext system_function() {
			return GetRuleContext<System_functionContext>(0);
		}
		public Date_time_functionContext date_time_function() {
			return GetRuleContext<Date_time_functionContext>(0);
		}
		public String_value_functionContext string_value_function() {
			return GetRuleContext<String_value_functionContext>(0);
		}
		public Xml_functionContext xml_function() {
			return GetRuleContext<Xml_functionContext>(0);
		}
		public Function_callContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_function_call; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunction_call(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Function_callContext function_call() {
		Function_callContext _localctx = new Function_callContext(Context, State);
		EnterRule(_localctx, 86, RULE_function_call);
		int _la;
		try {
			State = 1110;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,139,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1067; schema_qualified_name_nontype();
				State = 1068; Match(LEFT_PAREN);
				State = 1083;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ABORT) | (1L << ABSOLUTE) | (1L << ACCESS) | (1L << ACTION) | (1L << ADD) | (1L << ADMIN) | (1L << AFTER) | (1L << AGGREGATE) | (1L << ALSO) | (1L << ALTER) | (1L << ALWAYS) | (1L << ASSERTION) | (1L << ASSIGNMENT) | (1L << AT) | (1L << ATTACH) | (1L << ATTRIBUTE) | (1L << BACKWARD) | (1L << BEFORE) | (1L << BEGIN) | (1L << BY) | (1L << CACHE) | (1L << CALL) | (1L << CALLED) | (1L << CASCADE) | (1L << CASCADED) | (1L << CATALOG) | (1L << CHAIN) | (1L << CHARACTERISTICS) | (1L << CHECKPOINT) | (1L << CLASS) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMENTS) | (1L << COMMIT) | (1L << COMMITTED) | (1L << CONFIGURATION) | (1L << CONFLICT) | (1L << CONNECTION) | (1L << CONSTRAINTS) | (1L << CONTENT) | (1L << CONTINUE) | (1L << CONVERSION) | (1L << COPY) | (1L << COST) | (1L << CSV) | (1L << CUBE) | (1L << CURRENT) | (1L << CURSOR) | (1L << CYCLE) | (1L << DATA) | (1L << DATABASE) | (1L << DAY) | (1L << DEALLOCATE) | (1L << DECLARE) | (1L << DEFAULTS) | (1L << DEFERRED) | (1L << DEFINER) | (1L << DELETE) | (1L << DELIMITER) | (1L << DELIMITERS) | (1L << DEPENDS))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (DETACH - 64)) | (1L << (DICTIONARY - 64)) | (1L << (DISABLE - 64)) | (1L << (DISCARD - 64)) | (1L << (DOCUMENT - 64)) | (1L << (DOMAIN - 64)) | (1L << (DOUBLE - 64)) | (1L << (DROP - 64)) | (1L << (EACH - 64)) | (1L << (ENABLE - 64)) | (1L << (ENCODING - 64)) | (1L << (ENCRYPTED - 64)) | (1L << (ENUM - 64)) | (1L << (ESCAPE - 64)) | (1L << (EVENT - 64)) | (1L << (EXCLUDE - 64)) | (1L << (EXCLUDING - 64)) | (1L << (EXCLUSIVE - 64)) | (1L << (EXECUTE - 64)) | (1L << (EXPLAIN - 64)) | (1L << (EXTENSION - 64)) | (1L << (EXTERNAL - 64)) | (1L << (FAMILY - 64)) | (1L << (FILTER - 64)) | (1L << (FIRST - 64)) | (1L << (FOLLOWING - 64)) | (1L << (FORCE - 64)) | (1L << (FORWARD - 64)) | (1L << (FUNCTION - 64)) | (1L << (FUNCTIONS - 64)) | (1L << (GENERATED - 64)) | (1L << (GLOBAL - 64)) | (1L << (GRANTED - 64)) | (1L << (GROUPS - 64)) | (1L << (HANDLER - 64)) | (1L << (HEADER - 64)) | (1L << (HOLD - 64)) | (1L << (HOUR - 64)) | (1L << (IDENTITY - 64)) | (1L << (IF - 64)) | (1L << (IMMEDIATE - 64)) | (1L << (IMMUTABLE - 64)) | (1L << (IMPLICIT - 64)) | (1L << (IMPORT - 64)) | (1L << (INCLUDE - 64)) | (1L << (INCLUDING - 64)) | (1L << (INCREMENT - 64)) | (1L << (INDEX - 64)) | (1L << (INDEXES - 64)) | (1L << (INHERIT - 64)) | (1L << (INHERITS - 64)) | (1L << (INLINE - 64)) | (1L << (INPUT - 64)) | (1L << (INSENSITIVE - 64)) | (1L << (INSERT - 64)) | (1L << (INSTEAD - 64)) | (1L << (INVOKER - 64)) | (1L << (ISOLATION - 64)) | (1L << (KEY - 64)) | (1L << (LABEL - 64)) | (1L << (LANGUAGE - 64)) | (1L << (LARGE - 64)) | (1L << (LAST - 64)) | (1L << (LEAKPROOF - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (LEVEL - 128)) | (1L << (LISTEN - 128)) | (1L << (LOAD - 128)) | (1L << (LOCAL - 128)) | (1L << (LOCATION - 128)) | (1L << (LOCK - 128)) | (1L << (LOCKED - 128)) | (1L << (LOGGED - 128)) | (1L << (MAPPING - 128)) | (1L << (MATCH - 128)) | (1L << (MATERIALIZED - 128)) | (1L << (MAXVALUE - 128)) | (1L << (METHOD - 128)) | (1L << (MINUTE - 128)) | (1L << (MINVALUE - 128)) | (1L << (MODE - 128)) | (1L << (MONTH - 128)) | (1L << (MOVE - 128)) | (1L << (NAME - 128)) | (1L << (NAMES - 128)) | (1L << (NEW - 128)) | (1L << (NEXT - 128)) | (1L << (NO - 128)) | (1L << (NOTHING - 128)) | (1L << (NOTIFY - 128)) | (1L << (NOWAIT - 128)) | (1L << (NULLS - 128)) | (1L << (OBJECT - 128)) | (1L << (OF - 128)) | (1L << (OFF - 128)) | (1L << (OIDS - 128)) | (1L << (OLD - 128)) | (1L << (OPERATOR - 128)) | (1L << (OPTION - 128)) | (1L << (OPTIONS - 128)) | (1L << (ORDINALITY - 128)) | (1L << (OTHERS - 128)) | (1L << (OVER - 128)) | (1L << (OVERRIDING - 128)) | (1L << (OWNED - 128)) | (1L << (OWNER - 128)) | (1L << (PARALLEL - 128)) | (1L << (PARSER - 128)) | (1L << (PARTIAL - 128)) | (1L << (PARTITION - 128)) | (1L << (PASSING - 128)) | (1L << (PASSWORD - 128)) | (1L << (PLANS - 128)) | (1L << (POLICY - 128)) | (1L << (PRECEDING - 128)) | (1L << (PREPARE - 128)) | (1L << (PREPARED - 128)) | (1L << (PRESERVE - 128)) | (1L << (PRIOR - 128)) | (1L << (PRIVILEGES - 128)) | (1L << (PROCEDURAL - 128)) | (1L << (PROCEDURE - 128)) | (1L << (PROCEDURES - 128)) | (1L << (PROGRAM - 128)) | (1L << (PUBLICATION - 128)) | (1L << (QUOTE - 128)) | (1L << (RANGE - 128)) | (1L << (READ - 128)) | (1L << (REASSIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (RECHECK - 192)) | (1L << (RECURSIVE - 192)) | (1L << (REF - 192)) | (1L << (REFERENCING - 192)) | (1L << (REFRESH - 192)) | (1L << (REINDEX - 192)) | (1L << (RELATIVE - 192)) | (1L << (RELEASE - 192)) | (1L << (RENAME - 192)) | (1L << (REPEATABLE - 192)) | (1L << (REPLACE - 192)) | (1L << (REPLICA - 192)) | (1L << (RESET - 192)) | (1L << (RESTART - 192)) | (1L << (RESTRICT - 192)) | (1L << (RETURNS - 192)) | (1L << (REVOKE - 192)) | (1L << (ROLE - 192)) | (1L << (ROLLBACK - 192)) | (1L << (ROLLUP - 192)) | (1L << (ROUTINE - 192)) | (1L << (ROUTINES - 192)) | (1L << (ROWS - 192)) | (1L << (RULE - 192)) | (1L << (SAVEPOINT - 192)) | (1L << (SCHEMA - 192)) | (1L << (SCHEMAS - 192)) | (1L << (SCROLL - 192)) | (1L << (SEARCH - 192)) | (1L << (SECOND - 192)) | (1L << (SECURITY - 192)) | (1L << (SEQUENCE - 192)) | (1L << (SEQUENCES - 192)) | (1L << (SERIALIZABLE - 192)) | (1L << (SERVER - 192)) | (1L << (SESSION - 192)) | (1L << (SET - 192)) | (1L << (SETS - 192)) | (1L << (SHARE - 192)) | (1L << (SHOW - 192)) | (1L << (SIMPLE - 192)) | (1L << (SKIP_ - 192)) | (1L << (SNAPSHOT - 192)) | (1L << (SQL - 192)) | (1L << (STABLE - 192)) | (1L << (STANDALONE - 192)) | (1L << (START - 192)) | (1L << (STATEMENT - 192)) | (1L << (STATISTICS - 192)) | (1L << (STDIN - 192)) | (1L << (STDOUT - 192)) | (1L << (STORAGE - 192)) | (1L << (STORED - 192)) | (1L << (STRICT - 192)) | (1L << (STRIP - 192)) | (1L << (SUBSCRIPTION - 192)) | (1L << (SUPPORT - 192)) | (1L << (SYSID - 192)) | (1L << (SYSTEM - 192)) | (1L << (TABLES - 192)) | (1L << (TABLESPACE - 192)) | (1L << (TEMP - 192)) | (1L << (TEMPLATE - 192)) | (1L << (TEMPORARY - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (TEXT - 256)) | (1L << (TIES - 256)) | (1L << (TRANSACTION - 256)) | (1L << (TRANSFORM - 256)) | (1L << (TRIGGER - 256)) | (1L << (TRUNCATE - 256)) | (1L << (TRUSTED - 256)) | (1L << (TYPE - 256)) | (1L << (TYPES - 256)) | (1L << (UNBOUNDED - 256)) | (1L << (UNCOMMITTED - 256)) | (1L << (UNENCRYPTED - 256)) | (1L << (UNKNOWN - 256)) | (1L << (UNLISTEN - 256)) | (1L << (UNLOGGED - 256)) | (1L << (UNTIL - 256)) | (1L << (UPDATE - 256)) | (1L << (VACUUM - 256)) | (1L << (VALID - 256)) | (1L << (VALIDATE - 256)) | (1L << (VALIDATOR - 256)) | (1L << (VALUE - 256)) | (1L << (VARYING - 256)) | (1L << (VERSION - 256)) | (1L << (VIEW - 256)) | (1L << (VIEWS - 256)) | (1L << (VOLATILE - 256)) | (1L << (WHITESPACE - 256)) | (1L << (WITHIN - 256)) | (1L << (WITHOUT - 256)) | (1L << (WORK - 256)) | (1L << (WRAPPER - 256)) | (1L << (WRITE - 256)) | (1L << (XML - 256)) | (1L << (YEAR - 256)) | (1L << (YES - 256)) | (1L << (ZONE - 256)) | (1L << (BETWEEN - 256)) | (1L << (BIGINT - 256)) | (1L << (BIT - 256)) | (1L << (BOOLEAN - 256)) | (1L << (CHAR - 256)) | (1L << (CHARACTER - 256)) | (1L << (COALESCE - 256)) | (1L << (DEC - 256)) | (1L << (DECIMAL - 256)) | (1L << (EXISTS - 256)) | (1L << (EXTRACT - 256)) | (1L << (FLOAT - 256)) | (1L << (GREATEST - 256)) | (1L << (GROUPING - 256)) | (1L << (INOUT - 256)) | (1L << (INT - 256)) | (1L << (INTEGER - 256)) | (1L << (INTERVAL - 256)) | (1L << (LEAST - 256)) | (1L << (NATIONAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NONE - 256)) | (1L << (NULLIF - 256)) | (1L << (NUMERIC - 256)) | (1L << (OUT - 256)) | (1L << (OVERLAY - 256)) | (1L << (POSITION - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (PRECISION - 320)) | (1L << (REAL - 320)) | (1L << (ROW - 320)) | (1L << (SETOF - 320)) | (1L << (SMALLINT - 320)) | (1L << (SUBSTRING - 320)) | (1L << (TIME - 320)) | (1L << (TIMESTAMP - 320)) | (1L << (TREAT - 320)) | (1L << (TRIM - 320)) | (1L << (VALUES - 320)) | (1L << (VARCHAR - 320)) | (1L << (XMLATTRIBUTES - 320)) | (1L << (XMLCONCAT - 320)) | (1L << (XMLELEMENT - 320)) | (1L << (XMLEXISTS - 320)) | (1L << (XMLFOREST - 320)) | (1L << (XMLNAMESPACES - 320)) | (1L << (XMLPARSE - 320)) | (1L << (XMLPI - 320)) | (1L << (XMLROOT - 320)) | (1L << (XMLSERIALIZE - 320)) | (1L << (XMLTABLE - 320)) | (1L << (AUTHORIZATION - 320)) | (1L << (BINARY - 320)) | (1L << (COLLATION - 320)) | (1L << (CONCURRENTLY - 320)) | (1L << (CROSS - 320)) | (1L << (CURRENT_SCHEMA - 320)) | (1L << (FREEZE - 320)) | (1L << (FULL - 320)) | (1L << (ILIKE - 320)) | (1L << (INNER - 320)) | (1L << (IS - 320)) | (1L << (ISNULL - 320)) | (1L << (JOIN - 320)) | (1L << (LEFT - 320)) | (1L << (LIKE - 320)) | (1L << (NATURAL - 320)) | (1L << (NOTNULL - 320)) | (1L << (OUTER - 320)) | (1L << (OVERLAPS - 320)) | (1L << (RIGHT - 320)) | (1L << (SIMILAR - 320)) | (1L << (TABLESAMPLE - 320)) | (1L << (VERBOSE - 320)) | (1L << (ALL - 320)) | (1L << (ANY - 320)) | (1L << (ARRAY - 320)) | (1L << (CASE - 320)) | (1L << (CAST - 320)) | (1L << (CURRENT_CATALOG - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (CURRENT_DATE - 384)) | (1L << (CURRENT_TIME - 384)) | (1L << (CURRENT_TIMESTAMP - 384)) | (1L << (CURRENT_USER - 384)) | (1L << (DISTINCT - 384)) | (1L << (FALSE - 384)) | (1L << (LOCALTIME - 384)) | (1L << (LOCALTIMESTAMP - 384)) | (1L << (NOT - 384)) | (1L << (NULL - 384)) | (1L << (ON - 384)) | (1L << (SESSION_USER - 384)) | (1L << (SOME - 384)) | (1L << (TRUE - 384)) | (1L << (USER - 384)) | (1L << (VARIADIC - 384)) | (1L << (ALIGNMENT - 384)) | (1L << (BASETYPE - 384)) | (1L << (BUFFERS - 384)) | (1L << (BYPASSRLS - 384)) | (1L << (CANONICAL - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (CATEGORY - 448)) | (1L << (COLLATABLE - 448)) | (1L << (COMBINEFUNC - 448)) | (1L << (COMMUTATOR - 448)) | (1L << (CONNECT - 448)) | (1L << (COSTS - 448)) | (1L << (CREATEDB - 448)) | (1L << (CREATEROLE - 448)) | (1L << (DESERIALFUNC - 448)) | (1L << (DETERMINISTIC - 448)) | (1L << (DISABLE_PAGE_SKIPPING - 448)) | (1L << (ELEMENT - 448)) | (1L << (EXTENDED - 448)) | (1L << (FINALFUNC - 448)) | (1L << (FINALFUNC_EXTRA - 448)) | (1L << (FINALFUNC_MODIFY - 448)) | (1L << (FORCE_NOT_NULL - 448)) | (1L << (FORCE_NULL - 448)) | (1L << (FORCE_QUOTE - 448)) | (1L << (FORMAT - 448)) | (1L << (GETTOKEN - 448)) | (1L << (HASH - 448)) | (1L << (HASHES - 448)) | (1L << (HEADLINE - 448)) | (1L << (HYPOTHETICAL - 448)) | (1L << (INDEX_CLEANUP - 448)) | (1L << (INIT - 448)) | (1L << (INITCOND - 448)) | (1L << (INTERNALLENGTH - 448)) | (1L << (JSON - 448)) | (1L << (LC_COLLATE - 448)) | (1L << (LC_CTYPE - 448)) | (1L << (LEFTARG - 448)) | (1L << (LEXIZE - 448)) | (1L << (LEXTYPES - 448)) | (1L << (LIST - 448)) | (1L << (LOCALE - 448)) | (1L << (LOGIN - 448)) | (1L << (MAIN - 448)) | (1L << (MERGES - 448)) | (1L << (MFINALFUNC - 448)) | (1L << (MFINALFUNC_EXTRA - 448)) | (1L << (MFINALFUNC_MODIFY - 448)) | (1L << (MINITCOND - 448)) | (1L << (MINVFUNC - 448)) | (1L << (MODULUS - 448)) | (1L << (MSFUNC - 448)) | (1L << (MSSPACE - 448)) | (1L << (MSTYPE - 448)) | (1L << (NEGATOR - 448)) | (1L << (NOBYPASSRLS - 448)) | (1L << (NOCREATEDB - 448)) | (1L << (NOCREATEROLE - 448)) | (1L << (NOINHERIT - 448)) | (1L << (NOLOGIN - 448)) | (1L << (NOREPLICATION - 448)) | (1L << (NOSUPERUSER - 448)) | (1L << (OUTPUT - 448)) | (1L << (PASSEDBYVALUE - 448)) | (1L << (PATH - 448)) | (1L << (PERMISSIVE - 448)) | (1L << (PLAIN - 448)) | (1L << (PREFERRED - 448)) | (1L << (PROVIDER - 448)))) != 0) || ((((_la - 512)) & ~0x3f) == 0 && ((1L << (_la - 512)) & ((1L << (READ_ONLY - 512)) | (1L << (READ_WRITE - 512)) | (1L << (RECEIVE - 512)) | (1L << (REMAINDER - 512)) | (1L << (REPLICATION - 512)) | (1L << (RESTRICTED - 512)) | (1L << (RESTRICTIVE - 512)) | (1L << (RIGHTARG - 512)) | (1L << (SAFE - 512)) | (1L << (SEND - 512)) | (1L << (SERIALFUNC - 512)) | (1L << (SETTINGS - 512)) | (1L << (SFUNC - 512)) | (1L << (SHAREABLE - 512)) | (1L << (SKIP_LOCKED - 512)) | (1L << (SORTOP - 512)) | (1L << (SSPACE - 512)) | (1L << (STYPE - 512)) | (1L << (SUBTYPE_DIFF - 512)) | (1L << (SUBTYPE_OPCLASS - 512)) | (1L << (SUBTYPE - 512)) | (1L << (SUMMARY - 512)) | (1L << (SUPERUSER - 512)) | (1L << (TIMING - 512)) | (1L << (TYPMOD_IN - 512)) | (1L << (TYPMOD_OUT - 512)) | (1L << (UNSAFE - 512)) | (1L << (USAGE - 512)) | (1L << (VARIABLE - 512)) | (1L << (YAML - 512)) | (1L << (ALIAS - 512)) | (1L << (ASSERT - 512)) | (1L << (CONSTANT - 512)) | (1L << (DATATYPE - 512)) | (1L << (DEBUG - 512)) | (1L << (DETAIL - 512)) | (1L << (DIAGNOSTICS - 512)) | (1L << (ELSEIF - 512)) | (1L << (ELSIF - 512)) | (1L << (ERRCODE - 512)) | (1L << (EXIT - 512)) | (1L << (EXCEPTION - 512)) | (1L << (FOREACH - 512)) | (1L << (GET - 512)) | (1L << (HINT - 512)) | (1L << (INFO - 512)) | (1L << (LOG - 512)) | (1L << (LOOP - 512)) | (1L << (MESSAGE - 512)) | (1L << (NOTICE - 512)) | (1L << (OPEN - 512)) | (1L << (PERFORM - 512)) | (1L << (QUERY - 512)) | (1L << (RAISE - 512)) | (1L << (RECORD - 512)) | (1L << (RETURN - 512)) | (1L << (REVERSE - 512)) | (1L << (ROWTYPE - 512)) | (1L << (SLICE - 512)) | (1L << (SQLSTATE - 512)) | (1L << (STACKED - 512)) | (1L << (WARNING - 512)) | (1L << (WHILE - 512)))) != 0) || ((((_la - 585)) & ~0x3f) == 0 && ((1L << (_la - 585)) & ((1L << (LEFT_PAREN - 585)) | (1L << (PLUS - 585)) | (1L << (MINUS - 585)) | (1L << (MULTIPLY - 585)) | (1L << (LESS_LESS - 585)) | (1L << (GREATER_GREATER - 585)) | (1L << (HASH_SIGN - 585)) | (1L << (OP_CHARS - 585)) | (1L << (NUMBER_LITERAL - 585)) | (1L << (REAL_NUMBER - 585)) | (1L << (DOLLAR_NUMBER - 585)) | (1L << (Identifier - 585)) | (1L << (QuotedIdentifier - 585)) | (1L << (Character_String_Literal - 585)) | (1L << (BeginDollarStringConstant - 585)))) != 0)) {
					{
					State = 1070;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,131,Context) ) {
					case 1:
						{
						State = 1069; set_qualifier();
						}
						break;
					}
					State = 1072; vex_or_named_notation();
					State = 1077;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					while (_la==COMMA) {
						{
						{
						State = 1073; Match(COMMA);
						State = 1074; vex_or_named_notation();
						}
						}
						State = 1079;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					}
					State = 1081;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==ORDER) {
						{
						State = 1080; orderby_clause();
						}
					}

					}
				}

				State = 1085; Match(RIGHT_PAREN);
				State = 1092;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,135,Context) ) {
				case 1:
					{
					State = 1086; Match(WITHIN);
					State = 1087; Match(GROUP);
					State = 1088; Match(LEFT_PAREN);
					State = 1089; orderby_clause();
					State = 1090; Match(RIGHT_PAREN);
					}
					break;
				}
				State = 1095;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,136,Context) ) {
				case 1:
					{
					State = 1094; filter_clause();
					}
					break;
				}
				State = 1102;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,138,Context) ) {
				case 1:
					{
					State = 1097; Match(OVER);
					State = 1100;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case ABORT:
					case ABSOLUTE:
					case ACCESS:
					case ACTION:
					case ADD:
					case ADMIN:
					case AFTER:
					case AGGREGATE:
					case ALSO:
					case ALTER:
					case ALWAYS:
					case ASSERTION:
					case ASSIGNMENT:
					case AT:
					case ATTACH:
					case ATTRIBUTE:
					case BACKWARD:
					case BEFORE:
					case BEGIN:
					case BY:
					case CACHE:
					case CALL:
					case CALLED:
					case CASCADE:
					case CASCADED:
					case CATALOG:
					case CHAIN:
					case CHARACTERISTICS:
					case CHECKPOINT:
					case CLASS:
					case CLOSE:
					case CLUSTER:
					case COLUMNS:
					case COMMENT:
					case COMMENTS:
					case COMMIT:
					case COMMITTED:
					case CONFIGURATION:
					case CONFLICT:
					case CONNECTION:
					case CONSTRAINTS:
					case CONTENT:
					case CONTINUE:
					case CONVERSION:
					case COPY:
					case COST:
					case CSV:
					case CUBE:
					case CURRENT:
					case CURSOR:
					case CYCLE:
					case DATA:
					case DATABASE:
					case DAY:
					case DEALLOCATE:
					case DECLARE:
					case DEFAULTS:
					case DEFERRED:
					case DEFINER:
					case DELETE:
					case DELIMITER:
					case DELIMITERS:
					case DEPENDS:
					case DETACH:
					case DICTIONARY:
					case DISABLE:
					case DISCARD:
					case DOCUMENT:
					case DOMAIN:
					case DOUBLE:
					case DROP:
					case EACH:
					case ENABLE:
					case ENCODING:
					case ENCRYPTED:
					case ENUM:
					case ESCAPE:
					case EVENT:
					case EXCLUDE:
					case EXCLUDING:
					case EXCLUSIVE:
					case EXECUTE:
					case EXPLAIN:
					case EXTENSION:
					case EXTERNAL:
					case FAMILY:
					case FILTER:
					case FIRST:
					case FOLLOWING:
					case FORCE:
					case FORWARD:
					case FUNCTION:
					case FUNCTIONS:
					case GENERATED:
					case GLOBAL:
					case GRANTED:
					case GROUPS:
					case HANDLER:
					case HEADER:
					case HOLD:
					case HOUR:
					case IDENTITY:
					case IF:
					case IMMEDIATE:
					case IMMUTABLE:
					case IMPLICIT:
					case IMPORT:
					case INCLUDE:
					case INCLUDING:
					case INCREMENT:
					case INDEX:
					case INDEXES:
					case INHERIT:
					case INHERITS:
					case INLINE:
					case INPUT:
					case INSENSITIVE:
					case INSERT:
					case INSTEAD:
					case INVOKER:
					case ISOLATION:
					case KEY:
					case LABEL:
					case LANGUAGE:
					case LARGE:
					case LAST:
					case LEAKPROOF:
					case LEVEL:
					case LISTEN:
					case LOAD:
					case LOCAL:
					case LOCATION:
					case LOCK:
					case LOCKED:
					case LOGGED:
					case MAPPING:
					case MATCH:
					case MATERIALIZED:
					case MAXVALUE:
					case METHOD:
					case MINUTE:
					case MINVALUE:
					case MODE:
					case MONTH:
					case MOVE:
					case NAME:
					case NAMES:
					case NEW:
					case NEXT:
					case NO:
					case NOTHING:
					case NOTIFY:
					case NOWAIT:
					case NULLS:
					case OBJECT:
					case OF:
					case OFF:
					case OIDS:
					case OLD:
					case OPERATOR:
					case OPTION:
					case OPTIONS:
					case ORDINALITY:
					case OTHERS:
					case OVER:
					case OVERRIDING:
					case OWNED:
					case OWNER:
					case PARALLEL:
					case PARSER:
					case PARTIAL:
					case PARTITION:
					case PASSING:
					case PASSWORD:
					case PLANS:
					case POLICY:
					case PRECEDING:
					case PREPARE:
					case PREPARED:
					case PRESERVE:
					case PRIOR:
					case PRIVILEGES:
					case PROCEDURAL:
					case PROCEDURE:
					case PROCEDURES:
					case PROGRAM:
					case PUBLICATION:
					case QUOTE:
					case RANGE:
					case READ:
					case REASSIGN:
					case RECHECK:
					case RECURSIVE:
					case REF:
					case REFERENCING:
					case REFRESH:
					case REINDEX:
					case RELATIVE:
					case RELEASE:
					case RENAME:
					case REPEATABLE:
					case REPLACE:
					case REPLICA:
					case RESET:
					case RESTART:
					case RESTRICT:
					case RETURNS:
					case REVOKE:
					case ROLE:
					case ROLLBACK:
					case ROLLUP:
					case ROUTINE:
					case ROUTINES:
					case ROWS:
					case RULE:
					case SAVEPOINT:
					case SCHEMA:
					case SCHEMAS:
					case SCROLL:
					case SEARCH:
					case SECOND:
					case SECURITY:
					case SEQUENCE:
					case SEQUENCES:
					case SERIALIZABLE:
					case SERVER:
					case SESSION:
					case SET:
					case SETS:
					case SHARE:
					case SHOW:
					case SIMPLE:
					case SKIP_:
					case SNAPSHOT:
					case SQL:
					case STABLE:
					case STANDALONE:
					case START:
					case STATEMENT:
					case STATISTICS:
					case STDIN:
					case STDOUT:
					case STORAGE:
					case STORED:
					case STRICT:
					case STRIP:
					case SUBSCRIPTION:
					case SUPPORT:
					case SYSID:
					case SYSTEM:
					case TABLES:
					case TABLESPACE:
					case TEMP:
					case TEMPLATE:
					case TEMPORARY:
					case TEXT:
					case TIES:
					case TRANSACTION:
					case TRANSFORM:
					case TRIGGER:
					case TRUNCATE:
					case TRUSTED:
					case TYPE:
					case TYPES:
					case UNBOUNDED:
					case UNCOMMITTED:
					case UNENCRYPTED:
					case UNKNOWN:
					case UNLISTEN:
					case UNLOGGED:
					case UNTIL:
					case UPDATE:
					case VACUUM:
					case VALID:
					case VALIDATE:
					case VALIDATOR:
					case VALUE:
					case VARYING:
					case VERSION:
					case VIEW:
					case VIEWS:
					case VOLATILE:
					case WHITESPACE:
					case WITHIN:
					case WITHOUT:
					case WORK:
					case WRAPPER:
					case WRITE:
					case XML:
					case YEAR:
					case YES:
					case ZONE:
					case BETWEEN:
					case BIGINT:
					case BIT:
					case BOOLEAN:
					case CHAR:
					case CHARACTER:
					case COALESCE:
					case DEC:
					case DECIMAL:
					case EXISTS:
					case EXTRACT:
					case FLOAT:
					case GREATEST:
					case GROUPING:
					case INOUT:
					case INT:
					case INTEGER:
					case INTERVAL:
					case LEAST:
					case NATIONAL:
					case NCHAR:
					case NONE:
					case NULLIF:
					case NUMERIC:
					case OUT:
					case OVERLAY:
					case POSITION:
					case PRECISION:
					case REAL:
					case ROW:
					case SETOF:
					case SMALLINT:
					case SUBSTRING:
					case TIME:
					case TIMESTAMP:
					case TREAT:
					case TRIM:
					case VALUES:
					case VARCHAR:
					case XMLATTRIBUTES:
					case XMLCONCAT:
					case XMLELEMENT:
					case XMLEXISTS:
					case XMLFOREST:
					case XMLNAMESPACES:
					case XMLPARSE:
					case XMLPI:
					case XMLROOT:
					case XMLSERIALIZE:
					case XMLTABLE:
					case ALIGNMENT:
					case BASETYPE:
					case BUFFERS:
					case BYPASSRLS:
					case CANONICAL:
					case CATEGORY:
					case COLLATABLE:
					case COMBINEFUNC:
					case COMMUTATOR:
					case CONNECT:
					case COSTS:
					case CREATEDB:
					case CREATEROLE:
					case DESERIALFUNC:
					case DETERMINISTIC:
					case DISABLE_PAGE_SKIPPING:
					case ELEMENT:
					case EXTENDED:
					case FINALFUNC:
					case FINALFUNC_EXTRA:
					case FINALFUNC_MODIFY:
					case FORCE_NOT_NULL:
					case FORCE_NULL:
					case FORCE_QUOTE:
					case FORMAT:
					case GETTOKEN:
					case HASH:
					case HASHES:
					case HEADLINE:
					case HYPOTHETICAL:
					case INDEX_CLEANUP:
					case INIT:
					case INITCOND:
					case INTERNALLENGTH:
					case JSON:
					case LC_COLLATE:
					case LC_CTYPE:
					case LEFTARG:
					case LEXIZE:
					case LEXTYPES:
					case LIST:
					case LOCALE:
					case LOGIN:
					case MAIN:
					case MERGES:
					case MFINALFUNC:
					case MFINALFUNC_EXTRA:
					case MFINALFUNC_MODIFY:
					case MINITCOND:
					case MINVFUNC:
					case MODULUS:
					case MSFUNC:
					case MSSPACE:
					case MSTYPE:
					case NEGATOR:
					case NOBYPASSRLS:
					case NOCREATEDB:
					case NOCREATEROLE:
					case NOINHERIT:
					case NOLOGIN:
					case NOREPLICATION:
					case NOSUPERUSER:
					case OUTPUT:
					case PASSEDBYVALUE:
					case PATH:
					case PERMISSIVE:
					case PLAIN:
					case PREFERRED:
					case PROVIDER:
					case READ_ONLY:
					case READ_WRITE:
					case RECEIVE:
					case REMAINDER:
					case REPLICATION:
					case RESTRICTED:
					case RESTRICTIVE:
					case RIGHTARG:
					case SAFE:
					case SEND:
					case SERIALFUNC:
					case SETTINGS:
					case SFUNC:
					case SHAREABLE:
					case SKIP_LOCKED:
					case SORTOP:
					case SSPACE:
					case STYPE:
					case SUBTYPE_DIFF:
					case SUBTYPE_OPCLASS:
					case SUBTYPE:
					case SUMMARY:
					case SUPERUSER:
					case TIMING:
					case TYPMOD_IN:
					case TYPMOD_OUT:
					case UNSAFE:
					case USAGE:
					case VARIABLE:
					case YAML:
					case ALIAS:
					case ASSERT:
					case CONSTANT:
					case DATATYPE:
					case DEBUG:
					case DETAIL:
					case DIAGNOSTICS:
					case ELSEIF:
					case ELSIF:
					case ERRCODE:
					case EXIT:
					case EXCEPTION:
					case FOREACH:
					case GET:
					case HINT:
					case INFO:
					case LOG:
					case LOOP:
					case MESSAGE:
					case NOTICE:
					case OPEN:
					case PERFORM:
					case QUERY:
					case RAISE:
					case RECORD:
					case RETURN:
					case REVERSE:
					case ROWTYPE:
					case SLICE:
					case SQLSTATE:
					case STACKED:
					case WARNING:
					case WHILE:
					case Identifier:
					case QuotedIdentifier:
						{
						State = 1098; identifier();
						}
						break;
					case LEFT_PAREN:
						{
						State = 1099; window_definition();
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
					break;
				}
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1104; function_construct();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1105; extract_function();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 1106; system_function();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 1107; date_time_function();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 1108; string_value_function();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 1109; xml_function();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Xml_functionContext : ParserRuleContext {
		public IdentifierContext name;
		public IdentifierContext attname;
		public ITerminalNode XMLELEMENT() { return GetToken(PlPgSqlParser.XMLELEMENT, 0); }
		public ITerminalNode[] LEFT_PAREN() { return GetTokens(PlPgSqlParser.LEFT_PAREN); }
		public ITerminalNode LEFT_PAREN(int i) {
			return GetToken(PlPgSqlParser.LEFT_PAREN, i);
		}
		public ITerminalNode NAME() { return GetToken(PlPgSqlParser.NAME, 0); }
		public ITerminalNode[] RIGHT_PAREN() { return GetTokens(PlPgSqlParser.RIGHT_PAREN); }
		public ITerminalNode RIGHT_PAREN(int i) {
			return GetToken(PlPgSqlParser.RIGHT_PAREN, i);
		}
		public IdentifierContext[] identifier() {
			return GetRuleContexts<IdentifierContext>();
		}
		public IdentifierContext identifier(int i) {
			return GetRuleContext<IdentifierContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlPgSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlPgSqlParser.COMMA, i);
		}
		public ITerminalNode XMLATTRIBUTES() { return GetToken(PlPgSqlParser.XMLATTRIBUTES, 0); }
		public VexContext[] vex() {
			return GetRuleContexts<VexContext>();
		}
		public VexContext vex(int i) {
			return GetRuleContext<VexContext>(i);
		}
		public ITerminalNode[] AS() { return GetTokens(PlPgSqlParser.AS); }
		public ITerminalNode AS(int i) {
			return GetToken(PlPgSqlParser.AS, i);
		}
		public ITerminalNode XMLFOREST() { return GetToken(PlPgSqlParser.XMLFOREST, 0); }
		public ITerminalNode XMLPI() { return GetToken(PlPgSqlParser.XMLPI, 0); }
		public ITerminalNode XMLROOT() { return GetToken(PlPgSqlParser.XMLROOT, 0); }
		public ITerminalNode VERSION() { return GetToken(PlPgSqlParser.VERSION, 0); }
		public ITerminalNode[] NO() { return GetTokens(PlPgSqlParser.NO); }
		public ITerminalNode NO(int i) {
			return GetToken(PlPgSqlParser.NO, i);
		}
		public ITerminalNode[] VALUE() { return GetTokens(PlPgSqlParser.VALUE); }
		public ITerminalNode VALUE(int i) {
			return GetToken(PlPgSqlParser.VALUE, i);
		}
		public ITerminalNode STANDALONE() { return GetToken(PlPgSqlParser.STANDALONE, 0); }
		public ITerminalNode YES() { return GetToken(PlPgSqlParser.YES, 0); }
		public ITerminalNode XMLEXISTS() { return GetToken(PlPgSqlParser.XMLEXISTS, 0); }
		public ITerminalNode PASSING() { return GetToken(PlPgSqlParser.PASSING, 0); }
		public ITerminalNode[] BY() { return GetTokens(PlPgSqlParser.BY); }
		public ITerminalNode BY(int i) {
			return GetToken(PlPgSqlParser.BY, i);
		}
		public ITerminalNode[] REF() { return GetTokens(PlPgSqlParser.REF); }
		public ITerminalNode REF(int i) {
			return GetToken(PlPgSqlParser.REF, i);
		}
		public ITerminalNode XMLPARSE() { return GetToken(PlPgSqlParser.XMLPARSE, 0); }
		public ITerminalNode DOCUMENT() { return GetToken(PlPgSqlParser.DOCUMENT, 0); }
		public ITerminalNode CONTENT() { return GetToken(PlPgSqlParser.CONTENT, 0); }
		public ITerminalNode XMLSERIALIZE() { return GetToken(PlPgSqlParser.XMLSERIALIZE, 0); }
		public Data_typeContext data_type() {
			return GetRuleContext<Data_typeContext>(0);
		}
		public ITerminalNode XMLTABLE() { return GetToken(PlPgSqlParser.XMLTABLE, 0); }
		public ITerminalNode COLUMNS() { return GetToken(PlPgSqlParser.COLUMNS, 0); }
		public Xml_table_columnContext[] xml_table_column() {
			return GetRuleContexts<Xml_table_columnContext>();
		}
		public Xml_table_columnContext xml_table_column(int i) {
			return GetRuleContext<Xml_table_columnContext>(i);
		}
		public ITerminalNode XMLNAMESPACES() { return GetToken(PlPgSqlParser.XMLNAMESPACES, 0); }
		public Xml_functionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xml_function; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitXml_function(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Xml_functionContext xml_function() {
		Xml_functionContext _localctx = new Xml_functionContext(Context, State);
		EnterRule(_localctx, 88, RULE_xml_function);
		int _la;
		try {
			State = 1273;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case XMLELEMENT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1112; Match(XMLELEMENT);
				State = 1113; Match(LEFT_PAREN);
				State = 1114; Match(NAME);
				State = 1115; _localctx.name = identifier();
				State = 1137;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,143,Context) ) {
				case 1:
					{
					State = 1116; Match(COMMA);
					State = 1117; Match(XMLATTRIBUTES);
					State = 1118; Match(LEFT_PAREN);
					State = 1119; vex(0);
					State = 1122;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==AS) {
						{
						State = 1120; Match(AS);
						State = 1121; _localctx.attname = identifier();
						}
					}

					State = 1132;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					while (_la==COMMA) {
						{
						{
						State = 1124; Match(COMMA);
						State = 1125; vex(0);
						State = 1128;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==AS) {
							{
							State = 1126; Match(AS);
							State = 1127; _localctx.attname = identifier();
							}
						}

						}
						}
						State = 1134;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					}
					State = 1135; Match(RIGHT_PAREN);
					}
					break;
				}
				State = 1143;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 1139; Match(COMMA);
					State = 1140; vex(0);
					}
					}
					State = 1145;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 1146; Match(RIGHT_PAREN);
				}
				break;
			case XMLFOREST:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1148; Match(XMLFOREST);
				State = 1149; Match(LEFT_PAREN);
				State = 1150; vex(0);
				State = 1153;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==AS) {
					{
					State = 1151; Match(AS);
					State = 1152; _localctx.name = identifier();
					}
				}

				State = 1163;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 1155; Match(COMMA);
					State = 1156; vex(0);
					State = 1159;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==AS) {
						{
						State = 1157; Match(AS);
						State = 1158; _localctx.name = identifier();
						}
					}

					}
					}
					State = 1165;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 1166; Match(RIGHT_PAREN);
				}
				break;
			case XMLPI:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1168; Match(XMLPI);
				State = 1169; Match(LEFT_PAREN);
				State = 1170; Match(NAME);
				State = 1171; _localctx.name = identifier();
				State = 1174;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COMMA) {
					{
					State = 1172; Match(COMMA);
					State = 1173; vex(0);
					}
				}

				State = 1176; Match(RIGHT_PAREN);
				}
				break;
			case XMLROOT:
				EnterOuterAlt(_localctx, 4);
				{
				State = 1178; Match(XMLROOT);
				State = 1179; Match(LEFT_PAREN);
				State = 1180; vex(0);
				State = 1181; Match(COMMA);
				State = 1182; Match(VERSION);
				State = 1186;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,149,Context) ) {
				case 1:
					{
					State = 1183; vex(0);
					}
					break;
				case 2:
					{
					State = 1184; Match(NO);
					State = 1185; Match(VALUE);
					}
					break;
				}
				State = 1196;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COMMA) {
					{
					State = 1188; Match(COMMA);
					State = 1189; Match(STANDALONE);
					State = 1194;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,150,Context) ) {
					case 1:
						{
						State = 1190; Match(YES);
						}
						break;
					case 2:
						{
						State = 1191; Match(NO);
						}
						break;
					case 3:
						{
						State = 1192; Match(NO);
						State = 1193; Match(VALUE);
						}
						break;
					}
					}
				}

				State = 1198; Match(RIGHT_PAREN);
				}
				break;
			case XMLEXISTS:
				EnterOuterAlt(_localctx, 5);
				{
				State = 1200; Match(XMLEXISTS);
				State = 1201; Match(LEFT_PAREN);
				State = 1202; vex(0);
				State = 1203; Match(PASSING);
				State = 1206;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,152,Context) ) {
				case 1:
					{
					State = 1204; Match(BY);
					State = 1205; Match(REF);
					}
					break;
				}
				State = 1208; vex(0);
				State = 1211;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==BY) {
					{
					State = 1209; Match(BY);
					State = 1210; Match(REF);
					}
				}

				State = 1213; Match(RIGHT_PAREN);
				}
				break;
			case XMLPARSE:
				EnterOuterAlt(_localctx, 6);
				{
				State = 1215; Match(XMLPARSE);
				State = 1216; Match(LEFT_PAREN);
				State = 1217;
				_la = TokenStream.LA(1);
				if ( !(_la==CONTENT || _la==DOCUMENT) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 1218; vex(0);
				State = 1219; Match(RIGHT_PAREN);
				}
				break;
			case XMLSERIALIZE:
				EnterOuterAlt(_localctx, 7);
				{
				State = 1221; Match(XMLSERIALIZE);
				State = 1222; Match(LEFT_PAREN);
				State = 1223;
				_la = TokenStream.LA(1);
				if ( !(_la==CONTENT || _la==DOCUMENT) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 1224; vex(0);
				State = 1225; Match(AS);
				State = 1226; data_type();
				State = 1227; Match(RIGHT_PAREN);
				}
				break;
			case XMLTABLE:
				EnterOuterAlt(_localctx, 8);
				{
				State = 1229; Match(XMLTABLE);
				State = 1230; Match(LEFT_PAREN);
				State = 1249;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,155,Context) ) {
				case 1:
					{
					State = 1231; Match(XMLNAMESPACES);
					State = 1232; Match(LEFT_PAREN);
					State = 1233; vex(0);
					State = 1234; Match(AS);
					State = 1235; _localctx.name = identifier();
					State = 1243;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					while (_la==COMMA) {
						{
						{
						State = 1236; Match(COMMA);
						State = 1237; vex(0);
						State = 1238; Match(AS);
						State = 1239; _localctx.name = identifier();
						}
						}
						State = 1245;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					}
					State = 1246; Match(RIGHT_PAREN);
					State = 1247; Match(COMMA);
					}
					break;
				}
				State = 1251; vex(0);
				State = 1252; Match(PASSING);
				State = 1255;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,156,Context) ) {
				case 1:
					{
					State = 1253; Match(BY);
					State = 1254; Match(REF);
					}
					break;
				}
				State = 1257; vex(0);
				State = 1260;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==BY) {
					{
					State = 1258; Match(BY);
					State = 1259; Match(REF);
					}
				}

				State = 1262; Match(COLUMNS);
				State = 1263; xml_table_column();
				State = 1268;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 1264; Match(COMMA);
					State = 1265; xml_table_column();
					}
					}
					State = 1270;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 1271; Match(RIGHT_PAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Xml_table_columnContext : ParserRuleContext {
		public IdentifierContext name;
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Data_typeContext data_type() {
			return GetRuleContext<Data_typeContext>(0);
		}
		public ITerminalNode FOR() { return GetToken(PlPgSqlParser.FOR, 0); }
		public ITerminalNode ORDINALITY() { return GetToken(PlPgSqlParser.ORDINALITY, 0); }
		public ITerminalNode PATH() { return GetToken(PlPgSqlParser.PATH, 0); }
		public VexContext[] vex() {
			return GetRuleContexts<VexContext>();
		}
		public VexContext vex(int i) {
			return GetRuleContext<VexContext>(i);
		}
		public ITerminalNode DEFAULT() { return GetToken(PlPgSqlParser.DEFAULT, 0); }
		public ITerminalNode NULL() { return GetToken(PlPgSqlParser.NULL, 0); }
		public ITerminalNode NOT() { return GetToken(PlPgSqlParser.NOT, 0); }
		public Xml_table_columnContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xml_table_column; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitXml_table_column(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Xml_table_columnContext xml_table_column() {
		Xml_table_columnContext _localctx = new Xml_table_columnContext(Context, State);
		EnterRule(_localctx, 90, RULE_xml_table_column);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1275; _localctx.name = identifier();
			State = 1293;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ABORT:
			case ABSOLUTE:
			case ACCESS:
			case ACTION:
			case ADD:
			case ADMIN:
			case AFTER:
			case AGGREGATE:
			case ALSO:
			case ALTER:
			case ALWAYS:
			case ASSERTION:
			case ASSIGNMENT:
			case AT:
			case ATTACH:
			case ATTRIBUTE:
			case BACKWARD:
			case BEFORE:
			case BEGIN:
			case BY:
			case CACHE:
			case CALL:
			case CALLED:
			case CASCADE:
			case CASCADED:
			case CATALOG:
			case CHAIN:
			case CHARACTERISTICS:
			case CHECKPOINT:
			case CLASS:
			case CLOSE:
			case CLUSTER:
			case COLUMNS:
			case COMMENT:
			case COMMENTS:
			case COMMIT:
			case COMMITTED:
			case CONFIGURATION:
			case CONFLICT:
			case CONNECTION:
			case CONSTRAINTS:
			case CONTENT:
			case CONTINUE:
			case CONVERSION:
			case COPY:
			case COST:
			case CSV:
			case CUBE:
			case CURRENT:
			case CURSOR:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DAY:
			case DEALLOCATE:
			case DECLARE:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DELIMITER:
			case DELIMITERS:
			case DEPENDS:
			case DETACH:
			case DICTIONARY:
			case DISABLE:
			case DISCARD:
			case DOCUMENT:
			case DOMAIN:
			case DOUBLE:
			case DROP:
			case EACH:
			case ENABLE:
			case ENCODING:
			case ENCRYPTED:
			case ENUM:
			case ESCAPE:
			case EVENT:
			case EXCLUDE:
			case EXCLUDING:
			case EXCLUSIVE:
			case EXECUTE:
			case EXPLAIN:
			case EXTENSION:
			case EXTERNAL:
			case FAMILY:
			case FILTER:
			case FIRST:
			case FOLLOWING:
			case FORCE:
			case FORWARD:
			case FUNCTION:
			case FUNCTIONS:
			case GENERATED:
			case GLOBAL:
			case GRANTED:
			case GROUPS:
			case HANDLER:
			case HEADER:
			case HOLD:
			case HOUR:
			case IDENTITY:
			case IF:
			case IMMEDIATE:
			case IMMUTABLE:
			case IMPLICIT:
			case IMPORT:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDEX:
			case INDEXES:
			case INHERIT:
			case INHERITS:
			case INLINE:
			case INPUT:
			case INSENSITIVE:
			case INSERT:
			case INSTEAD:
			case INVOKER:
			case ISOLATION:
			case KEY:
			case LABEL:
			case LANGUAGE:
			case LARGE:
			case LAST:
			case LEAKPROOF:
			case LEVEL:
			case LISTEN:
			case LOAD:
			case LOCAL:
			case LOCATION:
			case LOCK:
			case LOCKED:
			case LOGGED:
			case MAPPING:
			case MATCH:
			case MATERIALIZED:
			case MAXVALUE:
			case METHOD:
			case MINUTE:
			case MINVALUE:
			case MODE:
			case MONTH:
			case MOVE:
			case NAME:
			case NAMES:
			case NEW:
			case NEXT:
			case NO:
			case NOTHING:
			case NOTIFY:
			case NOWAIT:
			case NULLS:
			case OBJECT:
			case OF:
			case OFF:
			case OIDS:
			case OLD:
			case OPERATOR:
			case OPTION:
			case OPTIONS:
			case ORDINALITY:
			case OTHERS:
			case OVER:
			case OVERRIDING:
			case OWNED:
			case OWNER:
			case PARALLEL:
			case PARSER:
			case PARTIAL:
			case PARTITION:
			case PASSING:
			case PASSWORD:
			case PLANS:
			case POLICY:
			case PRECEDING:
			case PREPARE:
			case PREPARED:
			case PRESERVE:
			case PRIOR:
			case PRIVILEGES:
			case PROCEDURAL:
			case PROCEDURE:
			case PROCEDURES:
			case PROGRAM:
			case PUBLICATION:
			case QUOTE:
			case RANGE:
			case READ:
			case REASSIGN:
			case RECHECK:
			case RECURSIVE:
			case REF:
			case REFERENCING:
			case REFRESH:
			case REINDEX:
			case RELATIVE:
			case RELEASE:
			case RENAME:
			case REPEATABLE:
			case REPLACE:
			case REPLICA:
			case RESET:
			case RESTART:
			case RESTRICT:
			case RETURNS:
			case REVOKE:
			case ROLE:
			case ROLLBACK:
			case ROLLUP:
			case ROUTINE:
			case ROUTINES:
			case ROWS:
			case RULE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMAS:
			case SCROLL:
			case SEARCH:
			case SECOND:
			case SECURITY:
			case SEQUENCE:
			case SEQUENCES:
			case SERIALIZABLE:
			case SERVER:
			case SESSION:
			case SET:
			case SETS:
			case SHARE:
			case SHOW:
			case SIMPLE:
			case SKIP_:
			case SNAPSHOT:
			case SQL:
			case STABLE:
			case STANDALONE:
			case START:
			case STATEMENT:
			case STATISTICS:
			case STDIN:
			case STDOUT:
			case STORAGE:
			case STORED:
			case STRICT:
			case STRIP:
			case SUBSCRIPTION:
			case SUPPORT:
			case SYSID:
			case SYSTEM:
			case TABLES:
			case TABLESPACE:
			case TEMP:
			case TEMPLATE:
			case TEMPORARY:
			case TEXT:
			case TIES:
			case TRANSACTION:
			case TRANSFORM:
			case TRIGGER:
			case TRUNCATE:
			case TRUSTED:
			case TYPE:
			case TYPES:
			case UNBOUNDED:
			case UNCOMMITTED:
			case UNENCRYPTED:
			case UNKNOWN:
			case UNLISTEN:
			case UNLOGGED:
			case UNTIL:
			case UPDATE:
			case VACUUM:
			case VALID:
			case VALIDATE:
			case VALIDATOR:
			case VALUE:
			case VARYING:
			case VERSION:
			case VIEW:
			case VIEWS:
			case VOLATILE:
			case WHITESPACE:
			case WITHIN:
			case WITHOUT:
			case WORK:
			case WRAPPER:
			case WRITE:
			case XML:
			case YEAR:
			case YES:
			case ZONE:
			case BETWEEN:
			case BIGINT:
			case BIT:
			case BOOLEAN:
			case CHAR:
			case CHARACTER:
			case COALESCE:
			case DEC:
			case DECIMAL:
			case EXISTS:
			case EXTRACT:
			case FLOAT:
			case GREATEST:
			case GROUPING:
			case INOUT:
			case INT:
			case INTEGER:
			case INTERVAL:
			case LEAST:
			case NATIONAL:
			case NCHAR:
			case NONE:
			case NULLIF:
			case NUMERIC:
			case OUT:
			case OVERLAY:
			case POSITION:
			case PRECISION:
			case REAL:
			case ROW:
			case SETOF:
			case SMALLINT:
			case SUBSTRING:
			case TIME:
			case TIMESTAMP:
			case TREAT:
			case TRIM:
			case VALUES:
			case VARCHAR:
			case XMLATTRIBUTES:
			case XMLCONCAT:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case AUTHORIZATION:
			case BINARY:
			case COLLATION:
			case CONCURRENTLY:
			case CROSS:
			case CURRENT_SCHEMA:
			case FREEZE:
			case FULL:
			case ILIKE:
			case INNER:
			case IS:
			case ISNULL:
			case JOIN:
			case LEFT:
			case LIKE:
			case NATURAL:
			case NOTNULL:
			case OUTER:
			case OVERLAPS:
			case RIGHT:
			case SIMILAR:
			case TABLESAMPLE:
			case VERBOSE:
			case ALIGNMENT:
			case BASETYPE:
			case BUFFERS:
			case BYPASSRLS:
			case CANONICAL:
			case CATEGORY:
			case COLLATABLE:
			case COMBINEFUNC:
			case COMMUTATOR:
			case CONNECT:
			case COSTS:
			case CREATEDB:
			case CREATEROLE:
			case DESERIALFUNC:
			case DETERMINISTIC:
			case DISABLE_PAGE_SKIPPING:
			case ELEMENT:
			case EXTENDED:
			case FINALFUNC:
			case FINALFUNC_EXTRA:
			case FINALFUNC_MODIFY:
			case FORCE_NOT_NULL:
			case FORCE_NULL:
			case FORCE_QUOTE:
			case FORMAT:
			case GETTOKEN:
			case HASH:
			case HASHES:
			case HEADLINE:
			case HYPOTHETICAL:
			case INDEX_CLEANUP:
			case INIT:
			case INITCOND:
			case INTERNALLENGTH:
			case JSON:
			case LC_COLLATE:
			case LC_CTYPE:
			case LEFTARG:
			case LEXIZE:
			case LEXTYPES:
			case LIST:
			case LOCALE:
			case LOGIN:
			case MAIN:
			case MERGES:
			case MFINALFUNC:
			case MFINALFUNC_EXTRA:
			case MFINALFUNC_MODIFY:
			case MINITCOND:
			case MINVFUNC:
			case MODULUS:
			case MSFUNC:
			case MSSPACE:
			case MSTYPE:
			case NEGATOR:
			case NOBYPASSRLS:
			case NOCREATEDB:
			case NOCREATEROLE:
			case NOINHERIT:
			case NOLOGIN:
			case NOREPLICATION:
			case NOSUPERUSER:
			case OUTPUT:
			case PASSEDBYVALUE:
			case PATH:
			case PERMISSIVE:
			case PLAIN:
			case PREFERRED:
			case PROVIDER:
			case READ_ONLY:
			case READ_WRITE:
			case RECEIVE:
			case REMAINDER:
			case REPLICATION:
			case RESTRICTED:
			case RESTRICTIVE:
			case RIGHTARG:
			case SAFE:
			case SEND:
			case SERIALFUNC:
			case SETTINGS:
			case SFUNC:
			case SHAREABLE:
			case SKIP_LOCKED:
			case SORTOP:
			case SSPACE:
			case STYPE:
			case SUBTYPE_DIFF:
			case SUBTYPE_OPCLASS:
			case SUBTYPE:
			case SUMMARY:
			case SUPERUSER:
			case TIMING:
			case TYPMOD_IN:
			case TYPMOD_OUT:
			case UNSAFE:
			case USAGE:
			case VARIABLE:
			case YAML:
			case ALIAS:
			case ASSERT:
			case CONSTANT:
			case DATATYPE:
			case DEBUG:
			case DETAIL:
			case DIAGNOSTICS:
			case ELSEIF:
			case ELSIF:
			case ERRCODE:
			case EXIT:
			case EXCEPTION:
			case FOREACH:
			case GET:
			case HINT:
			case INFO:
			case LOG:
			case LOOP:
			case MESSAGE:
			case NOTICE:
			case OPEN:
			case PERFORM:
			case QUERY:
			case RAISE:
			case RECORD:
			case RETURN:
			case REVERSE:
			case ROWTYPE:
			case SLICE:
			case SQLSTATE:
			case STACKED:
			case WARNING:
			case WHILE:
			case Identifier:
			case QuotedIdentifier:
				{
				State = 1276; data_type();
				State = 1279;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==PATH) {
					{
					State = 1277; Match(PATH);
					State = 1278; vex(0);
					}
				}

				State = 1283;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DEFAULT) {
					{
					State = 1281; Match(DEFAULT);
					State = 1282; vex(0);
					}
				}

				State = 1289;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==NOT || _la==NULL) {
					{
					State = 1286;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==NOT) {
						{
						State = 1285; Match(NOT);
						}
					}

					State = 1288; Match(NULL);
					}
				}

				}
				break;
			case FOR:
				{
				State = 1291; Match(FOR);
				State = 1292; Match(ORDINALITY);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class String_value_functionContext : ParserRuleContext {
		public VexContext chars;
		public VexContext str;
		public ITerminalNode TRIM() { return GetToken(PlPgSqlParser.TRIM, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlPgSqlParser.LEFT_PAREN, 0); }
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlPgSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode FROM() { return GetToken(PlPgSqlParser.FROM, 0); }
		public VexContext[] vex() {
			return GetRuleContexts<VexContext>();
		}
		public VexContext vex(int i) {
			return GetRuleContext<VexContext>(i);
		}
		public ITerminalNode LEADING() { return GetToken(PlPgSqlParser.LEADING, 0); }
		public ITerminalNode TRAILING() { return GetToken(PlPgSqlParser.TRAILING, 0); }
		public ITerminalNode BOTH() { return GetToken(PlPgSqlParser.BOTH, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(PlPgSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlPgSqlParser.COMMA, i);
		}
		public ITerminalNode SUBSTRING() { return GetToken(PlPgSqlParser.SUBSTRING, 0); }
		public ITerminalNode FOR() { return GetToken(PlPgSqlParser.FOR, 0); }
		public ITerminalNode POSITION() { return GetToken(PlPgSqlParser.POSITION, 0); }
		public Vex_bContext vex_b() {
			return GetRuleContext<Vex_bContext>(0);
		}
		public ITerminalNode IN() { return GetToken(PlPgSqlParser.IN, 0); }
		public ITerminalNode OVERLAY() { return GetToken(PlPgSqlParser.OVERLAY, 0); }
		public ITerminalNode PLACING() { return GetToken(PlPgSqlParser.PLACING, 0); }
		public ITerminalNode COLLATION() { return GetToken(PlPgSqlParser.COLLATION, 0); }
		public String_value_functionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_string_value_function; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitString_value_function(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public String_value_functionContext string_value_function() {
		String_value_functionContext _localctx = new String_value_functionContext(Context, State);
		EnterRule(_localctx, 92, RULE_string_value_function);
		int _la;
		try {
			State = 1362;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case TRIM:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1295; Match(TRIM);
				State = 1296; Match(LEFT_PAREN);
				State = 1298;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (((((_la - 375)) & ~0x3f) == 0 && ((1L << (_la - 375)) & ((1L << (BOTH - 375)) | (1L << (LEADING - 375)) | (1L << (TRAILING - 375)))) != 0)) {
					{
					State = 1297;
					_la = TokenStream.LA(1);
					if ( !(((((_la - 375)) & ~0x3f) == 0 && ((1L << (_la - 375)) & ((1L << (BOTH - 375)) | (1L << (LEADING - 375)) | (1L << (TRAILING - 375)))) != 0)) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				State = 1312;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,168,Context) ) {
				case 1:
					{
					State = 1300; _localctx.chars = vex(0);
					State = 1301; Match(FROM);
					State = 1302; _localctx.str = vex(0);
					}
					break;
				case 2:
					{
					State = 1305;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==FROM) {
						{
						State = 1304; Match(FROM);
						}
					}

					State = 1307; _localctx.str = vex(0);
					State = 1310;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==COMMA) {
						{
						State = 1308; Match(COMMA);
						State = 1309; _localctx.chars = vex(0);
						}
					}

					}
					break;
				}
				State = 1314; Match(RIGHT_PAREN);
				}
				break;
			case SUBSTRING:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1316; Match(SUBSTRING);
				State = 1317; Match(LEFT_PAREN);
				State = 1318; vex(0);
				State = 1323;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 1319; Match(COMMA);
					State = 1320; vex(0);
					}
					}
					State = 1325;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 1328;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==FROM) {
					{
					State = 1326; Match(FROM);
					State = 1327; vex(0);
					}
				}

				State = 1332;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==FOR) {
					{
					State = 1330; Match(FOR);
					State = 1331; vex(0);
					}
				}

				State = 1334; Match(RIGHT_PAREN);
				}
				break;
			case POSITION:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1336; Match(POSITION);
				State = 1337; Match(LEFT_PAREN);
				State = 1338; vex_b(0);
				State = 1339; Match(IN);
				State = 1340; vex(0);
				State = 1341; Match(RIGHT_PAREN);
				}
				break;
			case OVERLAY:
				EnterOuterAlt(_localctx, 4);
				{
				State = 1343; Match(OVERLAY);
				State = 1344; Match(LEFT_PAREN);
				State = 1345; vex(0);
				State = 1346; Match(PLACING);
				State = 1347; vex(0);
				State = 1348; Match(FROM);
				State = 1349; vex(0);
				State = 1352;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==FOR) {
					{
					State = 1350; Match(FOR);
					State = 1351; vex(0);
					}
				}

				State = 1354; Match(RIGHT_PAREN);
				}
				break;
			case COLLATION:
				EnterOuterAlt(_localctx, 5);
				{
				State = 1356; Match(COLLATION);
				State = 1357; Match(FOR);
				State = 1358; Match(LEFT_PAREN);
				State = 1359; vex(0);
				State = 1360; Match(RIGHT_PAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Date_time_functionContext : ParserRuleContext {
		public ITerminalNode CURRENT_DATE() { return GetToken(PlPgSqlParser.CURRENT_DATE, 0); }
		public ITerminalNode CURRENT_TIME() { return GetToken(PlPgSqlParser.CURRENT_TIME, 0); }
		public Type_lengthContext type_length() {
			return GetRuleContext<Type_lengthContext>(0);
		}
		public ITerminalNode CURRENT_TIMESTAMP() { return GetToken(PlPgSqlParser.CURRENT_TIMESTAMP, 0); }
		public ITerminalNode LOCALTIME() { return GetToken(PlPgSqlParser.LOCALTIME, 0); }
		public ITerminalNode LOCALTIMESTAMP() { return GetToken(PlPgSqlParser.LOCALTIMESTAMP, 0); }
		public Date_time_functionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_date_time_function; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDate_time_function(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Date_time_functionContext date_time_function() {
		Date_time_functionContext _localctx = new Date_time_functionContext(Context, State);
		EnterRule(_localctx, 94, RULE_date_time_function);
		try {
			State = 1381;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CURRENT_DATE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1364; Match(CURRENT_DATE);
				}
				break;
			case CURRENT_TIME:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1365; Match(CURRENT_TIME);
				State = 1367;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,174,Context) ) {
				case 1:
					{
					State = 1366; type_length();
					}
					break;
				}
				}
				break;
			case CURRENT_TIMESTAMP:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1369; Match(CURRENT_TIMESTAMP);
				State = 1371;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,175,Context) ) {
				case 1:
					{
					State = 1370; type_length();
					}
					break;
				}
				}
				break;
			case LOCALTIME:
				EnterOuterAlt(_localctx, 4);
				{
				State = 1373; Match(LOCALTIME);
				State = 1375;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,176,Context) ) {
				case 1:
					{
					State = 1374; type_length();
					}
					break;
				}
				}
				break;
			case LOCALTIMESTAMP:
				EnterOuterAlt(_localctx, 5);
				{
				State = 1377; Match(LOCALTIMESTAMP);
				State = 1379;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,177,Context) ) {
				case 1:
					{
					State = 1378; type_length();
					}
					break;
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class System_functionContext : ParserRuleContext {
		public ITerminalNode CURRENT_CATALOG() { return GetToken(PlPgSqlParser.CURRENT_CATALOG, 0); }
		public ITerminalNode CURRENT_SCHEMA() { return GetToken(PlPgSqlParser.CURRENT_SCHEMA, 0); }
		public ITerminalNode CURRENT_USER() { return GetToken(PlPgSqlParser.CURRENT_USER, 0); }
		public ITerminalNode SESSION_USER() { return GetToken(PlPgSqlParser.SESSION_USER, 0); }
		public ITerminalNode USER() { return GetToken(PlPgSqlParser.USER, 0); }
		public Cast_specificationContext cast_specification() {
			return GetRuleContext<Cast_specificationContext>(0);
		}
		public System_functionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_system_function; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSystem_function(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public System_functionContext system_function() {
		System_functionContext _localctx = new System_functionContext(Context, State);
		EnterRule(_localctx, 96, RULE_system_function);
		try {
			State = 1389;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CURRENT_CATALOG:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1383; Match(CURRENT_CATALOG);
				}
				break;
			case CURRENT_SCHEMA:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1384; Match(CURRENT_SCHEMA);
				}
				break;
			case CURRENT_USER:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1385; Match(CURRENT_USER);
				}
				break;
			case SESSION_USER:
				EnterOuterAlt(_localctx, 4);
				{
				State = 1386; Match(SESSION_USER);
				}
				break;
			case USER:
				EnterOuterAlt(_localctx, 5);
				{
				State = 1387; Match(USER);
				}
				break;
			case TREAT:
			case CAST:
				EnterOuterAlt(_localctx, 6);
				{
				State = 1388; cast_specification();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Cast_specificationContext : ParserRuleContext {
		public ITerminalNode LEFT_PAREN() { return GetToken(PlPgSqlParser.LEFT_PAREN, 0); }
		public VexContext vex() {
			return GetRuleContext<VexContext>(0);
		}
		public ITerminalNode AS() { return GetToken(PlPgSqlParser.AS, 0); }
		public Data_typeContext data_type() {
			return GetRuleContext<Data_typeContext>(0);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlPgSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode CAST() { return GetToken(PlPgSqlParser.CAST, 0); }
		public ITerminalNode TREAT() { return GetToken(PlPgSqlParser.TREAT, 0); }
		public Cast_specificationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cast_specification; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCast_specification(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Cast_specificationContext cast_specification() {
		Cast_specificationContext _localctx = new Cast_specificationContext(Context, State);
		EnterRule(_localctx, 98, RULE_cast_specification);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1391;
			_la = TokenStream.LA(1);
			if ( !(_la==TREAT || _la==CAST) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 1392; Match(LEFT_PAREN);
			State = 1393; vex(0);
			State = 1394; Match(AS);
			State = 1395; data_type();
			State = 1396; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Extract_functionContext : ParserRuleContext {
		public ITerminalNode EXTRACT() { return GetToken(PlPgSqlParser.EXTRACT, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlPgSqlParser.LEFT_PAREN, 0); }
		public ITerminalNode FROM() { return GetToken(PlPgSqlParser.FROM, 0); }
		public VexContext vex() {
			return GetRuleContext<VexContext>(0);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlPgSqlParser.RIGHT_PAREN, 0); }
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Character_stringContext character_string() {
			return GetRuleContext<Character_stringContext>(0);
		}
		public Extract_functionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_extract_function; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExtract_function(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Extract_functionContext extract_function() {
		Extract_functionContext _localctx = new Extract_functionContext(Context, State);
		EnterRule(_localctx, 100, RULE_extract_function);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1398; Match(EXTRACT);
			State = 1399; Match(LEFT_PAREN);
			State = 1402;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ABORT:
			case ABSOLUTE:
			case ACCESS:
			case ACTION:
			case ADD:
			case ADMIN:
			case AFTER:
			case AGGREGATE:
			case ALSO:
			case ALTER:
			case ALWAYS:
			case ASSERTION:
			case ASSIGNMENT:
			case AT:
			case ATTACH:
			case ATTRIBUTE:
			case BACKWARD:
			case BEFORE:
			case BEGIN:
			case BY:
			case CACHE:
			case CALL:
			case CALLED:
			case CASCADE:
			case CASCADED:
			case CATALOG:
			case CHAIN:
			case CHARACTERISTICS:
			case CHECKPOINT:
			case CLASS:
			case CLOSE:
			case CLUSTER:
			case COLUMNS:
			case COMMENT:
			case COMMENTS:
			case COMMIT:
			case COMMITTED:
			case CONFIGURATION:
			case CONFLICT:
			case CONNECTION:
			case CONSTRAINTS:
			case CONTENT:
			case CONTINUE:
			case CONVERSION:
			case COPY:
			case COST:
			case CSV:
			case CUBE:
			case CURRENT:
			case CURSOR:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DAY:
			case DEALLOCATE:
			case DECLARE:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DELIMITER:
			case DELIMITERS:
			case DEPENDS:
			case DETACH:
			case DICTIONARY:
			case DISABLE:
			case DISCARD:
			case DOCUMENT:
			case DOMAIN:
			case DOUBLE:
			case DROP:
			case EACH:
			case ENABLE:
			case ENCODING:
			case ENCRYPTED:
			case ENUM:
			case ESCAPE:
			case EVENT:
			case EXCLUDE:
			case EXCLUDING:
			case EXCLUSIVE:
			case EXECUTE:
			case EXPLAIN:
			case EXTENSION:
			case EXTERNAL:
			case FAMILY:
			case FILTER:
			case FIRST:
			case FOLLOWING:
			case FORCE:
			case FORWARD:
			case FUNCTION:
			case FUNCTIONS:
			case GENERATED:
			case GLOBAL:
			case GRANTED:
			case GROUPS:
			case HANDLER:
			case HEADER:
			case HOLD:
			case HOUR:
			case IDENTITY:
			case IF:
			case IMMEDIATE:
			case IMMUTABLE:
			case IMPLICIT:
			case IMPORT:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDEX:
			case INDEXES:
			case INHERIT:
			case INHERITS:
			case INLINE:
			case INPUT:
			case INSENSITIVE:
			case INSERT:
			case INSTEAD:
			case INVOKER:
			case ISOLATION:
			case KEY:
			case LABEL:
			case LANGUAGE:
			case LARGE:
			case LAST:
			case LEAKPROOF:
			case LEVEL:
			case LISTEN:
			case LOAD:
			case LOCAL:
			case LOCATION:
			case LOCK:
			case LOCKED:
			case LOGGED:
			case MAPPING:
			case MATCH:
			case MATERIALIZED:
			case MAXVALUE:
			case METHOD:
			case MINUTE:
			case MINVALUE:
			case MODE:
			case MONTH:
			case MOVE:
			case NAME:
			case NAMES:
			case NEW:
			case NEXT:
			case NO:
			case NOTHING:
			case NOTIFY:
			case NOWAIT:
			case NULLS:
			case OBJECT:
			case OF:
			case OFF:
			case OIDS:
			case OLD:
			case OPERATOR:
			case OPTION:
			case OPTIONS:
			case ORDINALITY:
			case OTHERS:
			case OVER:
			case OVERRIDING:
			case OWNED:
			case OWNER:
			case PARALLEL:
			case PARSER:
			case PARTIAL:
			case PARTITION:
			case PASSING:
			case PASSWORD:
			case PLANS:
			case POLICY:
			case PRECEDING:
			case PREPARE:
			case PREPARED:
			case PRESERVE:
			case PRIOR:
			case PRIVILEGES:
			case PROCEDURAL:
			case PROCEDURE:
			case PROCEDURES:
			case PROGRAM:
			case PUBLICATION:
			case QUOTE:
			case RANGE:
			case READ:
			case REASSIGN:
			case RECHECK:
			case RECURSIVE:
			case REF:
			case REFERENCING:
			case REFRESH:
			case REINDEX:
			case RELATIVE:
			case RELEASE:
			case RENAME:
			case REPEATABLE:
			case REPLACE:
			case REPLICA:
			case RESET:
			case RESTART:
			case RESTRICT:
			case RETURNS:
			case REVOKE:
			case ROLE:
			case ROLLBACK:
			case ROLLUP:
			case ROUTINE:
			case ROUTINES:
			case ROWS:
			case RULE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMAS:
			case SCROLL:
			case SEARCH:
			case SECOND:
			case SECURITY:
			case SEQUENCE:
			case SEQUENCES:
			case SERIALIZABLE:
			case SERVER:
			case SESSION:
			case SET:
			case SETS:
			case SHARE:
			case SHOW:
			case SIMPLE:
			case SKIP_:
			case SNAPSHOT:
			case SQL:
			case STABLE:
			case STANDALONE:
			case START:
			case STATEMENT:
			case STATISTICS:
			case STDIN:
			case STDOUT:
			case STORAGE:
			case STORED:
			case STRICT:
			case STRIP:
			case SUBSCRIPTION:
			case SUPPORT:
			case SYSID:
			case SYSTEM:
			case TABLES:
			case TABLESPACE:
			case TEMP:
			case TEMPLATE:
			case TEMPORARY:
			case TEXT:
			case TIES:
			case TRANSACTION:
			case TRANSFORM:
			case TRIGGER:
			case TRUNCATE:
			case TRUSTED:
			case TYPE:
			case TYPES:
			case UNBOUNDED:
			case UNCOMMITTED:
			case UNENCRYPTED:
			case UNKNOWN:
			case UNLISTEN:
			case UNLOGGED:
			case UNTIL:
			case UPDATE:
			case VACUUM:
			case VALID:
			case VALIDATE:
			case VALIDATOR:
			case VALUE:
			case VARYING:
			case VERSION:
			case VIEW:
			case VIEWS:
			case VOLATILE:
			case WHITESPACE:
			case WITHIN:
			case WITHOUT:
			case WORK:
			case WRAPPER:
			case WRITE:
			case XML:
			case YEAR:
			case YES:
			case ZONE:
			case BETWEEN:
			case BIGINT:
			case BIT:
			case BOOLEAN:
			case CHAR:
			case CHARACTER:
			case COALESCE:
			case DEC:
			case DECIMAL:
			case EXISTS:
			case EXTRACT:
			case FLOAT:
			case GREATEST:
			case GROUPING:
			case INOUT:
			case INT:
			case INTEGER:
			case INTERVAL:
			case LEAST:
			case NATIONAL:
			case NCHAR:
			case NONE:
			case NULLIF:
			case NUMERIC:
			case OUT:
			case OVERLAY:
			case POSITION:
			case PRECISION:
			case REAL:
			case ROW:
			case SETOF:
			case SMALLINT:
			case SUBSTRING:
			case TIME:
			case TIMESTAMP:
			case TREAT:
			case TRIM:
			case VALUES:
			case VARCHAR:
			case XMLATTRIBUTES:
			case XMLCONCAT:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case ALIGNMENT:
			case BASETYPE:
			case BUFFERS:
			case BYPASSRLS:
			case CANONICAL:
			case CATEGORY:
			case COLLATABLE:
			case COMBINEFUNC:
			case COMMUTATOR:
			case CONNECT:
			case COSTS:
			case CREATEDB:
			case CREATEROLE:
			case DESERIALFUNC:
			case DETERMINISTIC:
			case DISABLE_PAGE_SKIPPING:
			case ELEMENT:
			case EXTENDED:
			case FINALFUNC:
			case FINALFUNC_EXTRA:
			case FINALFUNC_MODIFY:
			case FORCE_NOT_NULL:
			case FORCE_NULL:
			case FORCE_QUOTE:
			case FORMAT:
			case GETTOKEN:
			case HASH:
			case HASHES:
			case HEADLINE:
			case HYPOTHETICAL:
			case INDEX_CLEANUP:
			case INIT:
			case INITCOND:
			case INTERNALLENGTH:
			case JSON:
			case LC_COLLATE:
			case LC_CTYPE:
			case LEFTARG:
			case LEXIZE:
			case LEXTYPES:
			case LIST:
			case LOCALE:
			case LOGIN:
			case MAIN:
			case MERGES:
			case MFINALFUNC:
			case MFINALFUNC_EXTRA:
			case MFINALFUNC_MODIFY:
			case MINITCOND:
			case MINVFUNC:
			case MODULUS:
			case MSFUNC:
			case MSSPACE:
			case MSTYPE:
			case NEGATOR:
			case NOBYPASSRLS:
			case NOCREATEDB:
			case NOCREATEROLE:
			case NOINHERIT:
			case NOLOGIN:
			case NOREPLICATION:
			case NOSUPERUSER:
			case OUTPUT:
			case PASSEDBYVALUE:
			case PATH:
			case PERMISSIVE:
			case PLAIN:
			case PREFERRED:
			case PROVIDER:
			case READ_ONLY:
			case READ_WRITE:
			case RECEIVE:
			case REMAINDER:
			case REPLICATION:
			case RESTRICTED:
			case RESTRICTIVE:
			case RIGHTARG:
			case SAFE:
			case SEND:
			case SERIALFUNC:
			case SETTINGS:
			case SFUNC:
			case SHAREABLE:
			case SKIP_LOCKED:
			case SORTOP:
			case SSPACE:
			case STYPE:
			case SUBTYPE_DIFF:
			case SUBTYPE_OPCLASS:
			case SUBTYPE:
			case SUMMARY:
			case SUPERUSER:
			case TIMING:
			case TYPMOD_IN:
			case TYPMOD_OUT:
			case UNSAFE:
			case USAGE:
			case VARIABLE:
			case YAML:
			case ALIAS:
			case ASSERT:
			case CONSTANT:
			case DATATYPE:
			case DEBUG:
			case DETAIL:
			case DIAGNOSTICS:
			case ELSEIF:
			case ELSIF:
			case ERRCODE:
			case EXIT:
			case EXCEPTION:
			case FOREACH:
			case GET:
			case HINT:
			case INFO:
			case LOG:
			case LOOP:
			case MESSAGE:
			case NOTICE:
			case OPEN:
			case PERFORM:
			case QUERY:
			case RAISE:
			case RECORD:
			case RETURN:
			case REVERSE:
			case ROWTYPE:
			case SLICE:
			case SQLSTATE:
			case STACKED:
			case WARNING:
			case WHILE:
			case Identifier:
			case QuotedIdentifier:
				{
				State = 1400; identifier();
				}
				break;
			case Character_String_Literal:
			case BeginDollarStringConstant:
				{
				State = 1401; character_string();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 1404; Match(FROM);
			State = 1405; vex(0);
			State = 1406; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Character_stringContext : ParserRuleContext {
		public ITerminalNode BeginDollarStringConstant() { return GetToken(PlPgSqlParser.BeginDollarStringConstant, 0); }
		public ITerminalNode EndDollarStringConstant() { return GetToken(PlPgSqlParser.EndDollarStringConstant, 0); }
		public ITerminalNode[] Text_between_Dollar() { return GetTokens(PlPgSqlParser.Text_between_Dollar); }
		public ITerminalNode Text_between_Dollar(int i) {
			return GetToken(PlPgSqlParser.Text_between_Dollar, i);
		}
		public ITerminalNode Character_String_Literal() { return GetToken(PlPgSqlParser.Character_String_Literal, 0); }
		public Character_stringContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_character_string; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCharacter_string(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Character_stringContext character_string() {
		Character_stringContext _localctx = new Character_stringContext(Context, State);
		EnterRule(_localctx, 102, RULE_character_string);
		int _la;
		try {
			State = 1417;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case BeginDollarStringConstant:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1408; Match(BeginDollarStringConstant);
				State = 1412;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==Text_between_Dollar) {
					{
					{
					State = 1409; Match(Text_between_Dollar);
					}
					}
					State = 1414;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 1415; Match(EndDollarStringConstant);
				}
				break;
			case Character_String_Literal:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1416; Match(Character_String_Literal);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Function_constructContext : ParserRuleContext {
		public ITerminalNode LEFT_PAREN() { return GetToken(PlPgSqlParser.LEFT_PAREN, 0); }
		public VexContext[] vex() {
			return GetRuleContexts<VexContext>();
		}
		public VexContext vex(int i) {
			return GetRuleContext<VexContext>(i);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlPgSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode COALESCE() { return GetToken(PlPgSqlParser.COALESCE, 0); }
		public ITerminalNode GREATEST() { return GetToken(PlPgSqlParser.GREATEST, 0); }
		public ITerminalNode GROUPING() { return GetToken(PlPgSqlParser.GROUPING, 0); }
		public ITerminalNode LEAST() { return GetToken(PlPgSqlParser.LEAST, 0); }
		public ITerminalNode NULLIF() { return GetToken(PlPgSqlParser.NULLIF, 0); }
		public ITerminalNode XMLCONCAT() { return GetToken(PlPgSqlParser.XMLCONCAT, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(PlPgSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlPgSqlParser.COMMA, i);
		}
		public ITerminalNode ROW() { return GetToken(PlPgSqlParser.ROW, 0); }
		public Function_constructContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_function_construct; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunction_construct(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Function_constructContext function_construct() {
		Function_constructContext _localctx = new Function_constructContext(Context, State);
		EnterRule(_localctx, 104, RULE_function_construct);
		int _la;
		try {
			State = 1444;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case COALESCE:
			case GREATEST:
			case GROUPING:
			case LEAST:
			case NULLIF:
			case XMLCONCAT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1419;
				_la = TokenStream.LA(1);
				if ( !(((((_la - 299)) & ~0x3f) == 0 && ((1L << (_la - 299)) & ((1L << (COALESCE - 299)) | (1L << (GREATEST - 299)) | (1L << (GROUPING - 299)) | (1L << (LEAST - 299)) | (1L << (NULLIF - 299)) | (1L << (XMLCONCAT - 299)))) != 0)) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 1420; Match(LEFT_PAREN);
				State = 1421; vex(0);
				State = 1426;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 1422; Match(COMMA);
					State = 1423; vex(0);
					}
					}
					State = 1428;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 1429; Match(RIGHT_PAREN);
				}
				break;
			case ROW:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1431; Match(ROW);
				State = 1432; Match(LEFT_PAREN);
				State = 1441;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ABORT) | (1L << ABSOLUTE) | (1L << ACCESS) | (1L << ACTION) | (1L << ADD) | (1L << ADMIN) | (1L << AFTER) | (1L << AGGREGATE) | (1L << ALSO) | (1L << ALTER) | (1L << ALWAYS) | (1L << ASSERTION) | (1L << ASSIGNMENT) | (1L << AT) | (1L << ATTACH) | (1L << ATTRIBUTE) | (1L << BACKWARD) | (1L << BEFORE) | (1L << BEGIN) | (1L << BY) | (1L << CACHE) | (1L << CALL) | (1L << CALLED) | (1L << CASCADE) | (1L << CASCADED) | (1L << CATALOG) | (1L << CHAIN) | (1L << CHARACTERISTICS) | (1L << CHECKPOINT) | (1L << CLASS) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMENTS) | (1L << COMMIT) | (1L << COMMITTED) | (1L << CONFIGURATION) | (1L << CONFLICT) | (1L << CONNECTION) | (1L << CONSTRAINTS) | (1L << CONTENT) | (1L << CONTINUE) | (1L << CONVERSION) | (1L << COPY) | (1L << COST) | (1L << CSV) | (1L << CUBE) | (1L << CURRENT) | (1L << CURSOR) | (1L << CYCLE) | (1L << DATA) | (1L << DATABASE) | (1L << DAY) | (1L << DEALLOCATE) | (1L << DECLARE) | (1L << DEFAULTS) | (1L << DEFERRED) | (1L << DEFINER) | (1L << DELETE) | (1L << DELIMITER) | (1L << DELIMITERS) | (1L << DEPENDS))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (DETACH - 64)) | (1L << (DICTIONARY - 64)) | (1L << (DISABLE - 64)) | (1L << (DISCARD - 64)) | (1L << (DOCUMENT - 64)) | (1L << (DOMAIN - 64)) | (1L << (DOUBLE - 64)) | (1L << (DROP - 64)) | (1L << (EACH - 64)) | (1L << (ENABLE - 64)) | (1L << (ENCODING - 64)) | (1L << (ENCRYPTED - 64)) | (1L << (ENUM - 64)) | (1L << (ESCAPE - 64)) | (1L << (EVENT - 64)) | (1L << (EXCLUDE - 64)) | (1L << (EXCLUDING - 64)) | (1L << (EXCLUSIVE - 64)) | (1L << (EXECUTE - 64)) | (1L << (EXPLAIN - 64)) | (1L << (EXTENSION - 64)) | (1L << (EXTERNAL - 64)) | (1L << (FAMILY - 64)) | (1L << (FILTER - 64)) | (1L << (FIRST - 64)) | (1L << (FOLLOWING - 64)) | (1L << (FORCE - 64)) | (1L << (FORWARD - 64)) | (1L << (FUNCTION - 64)) | (1L << (FUNCTIONS - 64)) | (1L << (GENERATED - 64)) | (1L << (GLOBAL - 64)) | (1L << (GRANTED - 64)) | (1L << (GROUPS - 64)) | (1L << (HANDLER - 64)) | (1L << (HEADER - 64)) | (1L << (HOLD - 64)) | (1L << (HOUR - 64)) | (1L << (IDENTITY - 64)) | (1L << (IF - 64)) | (1L << (IMMEDIATE - 64)) | (1L << (IMMUTABLE - 64)) | (1L << (IMPLICIT - 64)) | (1L << (IMPORT - 64)) | (1L << (INCLUDE - 64)) | (1L << (INCLUDING - 64)) | (1L << (INCREMENT - 64)) | (1L << (INDEX - 64)) | (1L << (INDEXES - 64)) | (1L << (INHERIT - 64)) | (1L << (INHERITS - 64)) | (1L << (INLINE - 64)) | (1L << (INPUT - 64)) | (1L << (INSENSITIVE - 64)) | (1L << (INSERT - 64)) | (1L << (INSTEAD - 64)) | (1L << (INVOKER - 64)) | (1L << (ISOLATION - 64)) | (1L << (KEY - 64)) | (1L << (LABEL - 64)) | (1L << (LANGUAGE - 64)) | (1L << (LARGE - 64)) | (1L << (LAST - 64)) | (1L << (LEAKPROOF - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (LEVEL - 128)) | (1L << (LISTEN - 128)) | (1L << (LOAD - 128)) | (1L << (LOCAL - 128)) | (1L << (LOCATION - 128)) | (1L << (LOCK - 128)) | (1L << (LOCKED - 128)) | (1L << (LOGGED - 128)) | (1L << (MAPPING - 128)) | (1L << (MATCH - 128)) | (1L << (MATERIALIZED - 128)) | (1L << (MAXVALUE - 128)) | (1L << (METHOD - 128)) | (1L << (MINUTE - 128)) | (1L << (MINVALUE - 128)) | (1L << (MODE - 128)) | (1L << (MONTH - 128)) | (1L << (MOVE - 128)) | (1L << (NAME - 128)) | (1L << (NAMES - 128)) | (1L << (NEW - 128)) | (1L << (NEXT - 128)) | (1L << (NO - 128)) | (1L << (NOTHING - 128)) | (1L << (NOTIFY - 128)) | (1L << (NOWAIT - 128)) | (1L << (NULLS - 128)) | (1L << (OBJECT - 128)) | (1L << (OF - 128)) | (1L << (OFF - 128)) | (1L << (OIDS - 128)) | (1L << (OLD - 128)) | (1L << (OPERATOR - 128)) | (1L << (OPTION - 128)) | (1L << (OPTIONS - 128)) | (1L << (ORDINALITY - 128)) | (1L << (OTHERS - 128)) | (1L << (OVER - 128)) | (1L << (OVERRIDING - 128)) | (1L << (OWNED - 128)) | (1L << (OWNER - 128)) | (1L << (PARALLEL - 128)) | (1L << (PARSER - 128)) | (1L << (PARTIAL - 128)) | (1L << (PARTITION - 128)) | (1L << (PASSING - 128)) | (1L << (PASSWORD - 128)) | (1L << (PLANS - 128)) | (1L << (POLICY - 128)) | (1L << (PRECEDING - 128)) | (1L << (PREPARE - 128)) | (1L << (PREPARED - 128)) | (1L << (PRESERVE - 128)) | (1L << (PRIOR - 128)) | (1L << (PRIVILEGES - 128)) | (1L << (PROCEDURAL - 128)) | (1L << (PROCEDURE - 128)) | (1L << (PROCEDURES - 128)) | (1L << (PROGRAM - 128)) | (1L << (PUBLICATION - 128)) | (1L << (QUOTE - 128)) | (1L << (RANGE - 128)) | (1L << (READ - 128)) | (1L << (REASSIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (RECHECK - 192)) | (1L << (RECURSIVE - 192)) | (1L << (REF - 192)) | (1L << (REFERENCING - 192)) | (1L << (REFRESH - 192)) | (1L << (REINDEX - 192)) | (1L << (RELATIVE - 192)) | (1L << (RELEASE - 192)) | (1L << (RENAME - 192)) | (1L << (REPEATABLE - 192)) | (1L << (REPLACE - 192)) | (1L << (REPLICA - 192)) | (1L << (RESET - 192)) | (1L << (RESTART - 192)) | (1L << (RESTRICT - 192)) | (1L << (RETURNS - 192)) | (1L << (REVOKE - 192)) | (1L << (ROLE - 192)) | (1L << (ROLLBACK - 192)) | (1L << (ROLLUP - 192)) | (1L << (ROUTINE - 192)) | (1L << (ROUTINES - 192)) | (1L << (ROWS - 192)) | (1L << (RULE - 192)) | (1L << (SAVEPOINT - 192)) | (1L << (SCHEMA - 192)) | (1L << (SCHEMAS - 192)) | (1L << (SCROLL - 192)) | (1L << (SEARCH - 192)) | (1L << (SECOND - 192)) | (1L << (SECURITY - 192)) | (1L << (SEQUENCE - 192)) | (1L << (SEQUENCES - 192)) | (1L << (SERIALIZABLE - 192)) | (1L << (SERVER - 192)) | (1L << (SESSION - 192)) | (1L << (SET - 192)) | (1L << (SETS - 192)) | (1L << (SHARE - 192)) | (1L << (SHOW - 192)) | (1L << (SIMPLE - 192)) | (1L << (SKIP_ - 192)) | (1L << (SNAPSHOT - 192)) | (1L << (SQL - 192)) | (1L << (STABLE - 192)) | (1L << (STANDALONE - 192)) | (1L << (START - 192)) | (1L << (STATEMENT - 192)) | (1L << (STATISTICS - 192)) | (1L << (STDIN - 192)) | (1L << (STDOUT - 192)) | (1L << (STORAGE - 192)) | (1L << (STORED - 192)) | (1L << (STRICT - 192)) | (1L << (STRIP - 192)) | (1L << (SUBSCRIPTION - 192)) | (1L << (SUPPORT - 192)) | (1L << (SYSID - 192)) | (1L << (SYSTEM - 192)) | (1L << (TABLES - 192)) | (1L << (TABLESPACE - 192)) | (1L << (TEMP - 192)) | (1L << (TEMPLATE - 192)) | (1L << (TEMPORARY - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (TEXT - 256)) | (1L << (TIES - 256)) | (1L << (TRANSACTION - 256)) | (1L << (TRANSFORM - 256)) | (1L << (TRIGGER - 256)) | (1L << (TRUNCATE - 256)) | (1L << (TRUSTED - 256)) | (1L << (TYPE - 256)) | (1L << (TYPES - 256)) | (1L << (UNBOUNDED - 256)) | (1L << (UNCOMMITTED - 256)) | (1L << (UNENCRYPTED - 256)) | (1L << (UNKNOWN - 256)) | (1L << (UNLISTEN - 256)) | (1L << (UNLOGGED - 256)) | (1L << (UNTIL - 256)) | (1L << (UPDATE - 256)) | (1L << (VACUUM - 256)) | (1L << (VALID - 256)) | (1L << (VALIDATE - 256)) | (1L << (VALIDATOR - 256)) | (1L << (VALUE - 256)) | (1L << (VARYING - 256)) | (1L << (VERSION - 256)) | (1L << (VIEW - 256)) | (1L << (VIEWS - 256)) | (1L << (VOLATILE - 256)) | (1L << (WHITESPACE - 256)) | (1L << (WITHIN - 256)) | (1L << (WITHOUT - 256)) | (1L << (WORK - 256)) | (1L << (WRAPPER - 256)) | (1L << (WRITE - 256)) | (1L << (XML - 256)) | (1L << (YEAR - 256)) | (1L << (YES - 256)) | (1L << (ZONE - 256)) | (1L << (BETWEEN - 256)) | (1L << (BIGINT - 256)) | (1L << (BIT - 256)) | (1L << (BOOLEAN - 256)) | (1L << (CHAR - 256)) | (1L << (CHARACTER - 256)) | (1L << (COALESCE - 256)) | (1L << (DEC - 256)) | (1L << (DECIMAL - 256)) | (1L << (EXISTS - 256)) | (1L << (EXTRACT - 256)) | (1L << (FLOAT - 256)) | (1L << (GREATEST - 256)) | (1L << (GROUPING - 256)) | (1L << (INOUT - 256)) | (1L << (INT - 256)) | (1L << (INTEGER - 256)) | (1L << (INTERVAL - 256)) | (1L << (LEAST - 256)) | (1L << (NATIONAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NONE - 256)) | (1L << (NULLIF - 256)) | (1L << (NUMERIC - 256)) | (1L << (OUT - 256)) | (1L << (OVERLAY - 256)) | (1L << (POSITION - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (PRECISION - 320)) | (1L << (REAL - 320)) | (1L << (ROW - 320)) | (1L << (SETOF - 320)) | (1L << (SMALLINT - 320)) | (1L << (SUBSTRING - 320)) | (1L << (TIME - 320)) | (1L << (TIMESTAMP - 320)) | (1L << (TREAT - 320)) | (1L << (TRIM - 320)) | (1L << (VALUES - 320)) | (1L << (VARCHAR - 320)) | (1L << (XMLATTRIBUTES - 320)) | (1L << (XMLCONCAT - 320)) | (1L << (XMLELEMENT - 320)) | (1L << (XMLEXISTS - 320)) | (1L << (XMLFOREST - 320)) | (1L << (XMLNAMESPACES - 320)) | (1L << (XMLPARSE - 320)) | (1L << (XMLPI - 320)) | (1L << (XMLROOT - 320)) | (1L << (XMLSERIALIZE - 320)) | (1L << (XMLTABLE - 320)) | (1L << (AUTHORIZATION - 320)) | (1L << (BINARY - 320)) | (1L << (COLLATION - 320)) | (1L << (CONCURRENTLY - 320)) | (1L << (CROSS - 320)) | (1L << (CURRENT_SCHEMA - 320)) | (1L << (FREEZE - 320)) | (1L << (FULL - 320)) | (1L << (ILIKE - 320)) | (1L << (INNER - 320)) | (1L << (IS - 320)) | (1L << (ISNULL - 320)) | (1L << (JOIN - 320)) | (1L << (LEFT - 320)) | (1L << (LIKE - 320)) | (1L << (NATURAL - 320)) | (1L << (NOTNULL - 320)) | (1L << (OUTER - 320)) | (1L << (OVERLAPS - 320)) | (1L << (RIGHT - 320)) | (1L << (SIMILAR - 320)) | (1L << (TABLESAMPLE - 320)) | (1L << (VERBOSE - 320)) | (1L << (ALL - 320)) | (1L << (ANY - 320)) | (1L << (ARRAY - 320)) | (1L << (CASE - 320)) | (1L << (CAST - 320)) | (1L << (CURRENT_CATALOG - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (CURRENT_DATE - 384)) | (1L << (CURRENT_TIME - 384)) | (1L << (CURRENT_TIMESTAMP - 384)) | (1L << (CURRENT_USER - 384)) | (1L << (FALSE - 384)) | (1L << (LOCALTIME - 384)) | (1L << (LOCALTIMESTAMP - 384)) | (1L << (NOT - 384)) | (1L << (NULL - 384)) | (1L << (ON - 384)) | (1L << (SESSION_USER - 384)) | (1L << (SOME - 384)) | (1L << (TRUE - 384)) | (1L << (USER - 384)) | (1L << (ALIGNMENT - 384)) | (1L << (BASETYPE - 384)) | (1L << (BUFFERS - 384)) | (1L << (BYPASSRLS - 384)) | (1L << (CANONICAL - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (CATEGORY - 448)) | (1L << (COLLATABLE - 448)) | (1L << (COMBINEFUNC - 448)) | (1L << (COMMUTATOR - 448)) | (1L << (CONNECT - 448)) | (1L << (COSTS - 448)) | (1L << (CREATEDB - 448)) | (1L << (CREATEROLE - 448)) | (1L << (DESERIALFUNC - 448)) | (1L << (DETERMINISTIC - 448)) | (1L << (DISABLE_PAGE_SKIPPING - 448)) | (1L << (ELEMENT - 448)) | (1L << (EXTENDED - 448)) | (1L << (FINALFUNC - 448)) | (1L << (FINALFUNC_EXTRA - 448)) | (1L << (FINALFUNC_MODIFY - 448)) | (1L << (FORCE_NOT_NULL - 448)) | (1L << (FORCE_NULL - 448)) | (1L << (FORCE_QUOTE - 448)) | (1L << (FORMAT - 448)) | (1L << (GETTOKEN - 448)) | (1L << (HASH - 448)) | (1L << (HASHES - 448)) | (1L << (HEADLINE - 448)) | (1L << (HYPOTHETICAL - 448)) | (1L << (INDEX_CLEANUP - 448)) | (1L << (INIT - 448)) | (1L << (INITCOND - 448)) | (1L << (INTERNALLENGTH - 448)) | (1L << (JSON - 448)) | (1L << (LC_COLLATE - 448)) | (1L << (LC_CTYPE - 448)) | (1L << (LEFTARG - 448)) | (1L << (LEXIZE - 448)) | (1L << (LEXTYPES - 448)) | (1L << (LIST - 448)) | (1L << (LOCALE - 448)) | (1L << (LOGIN - 448)) | (1L << (MAIN - 448)) | (1L << (MERGES - 448)) | (1L << (MFINALFUNC - 448)) | (1L << (MFINALFUNC_EXTRA - 448)) | (1L << (MFINALFUNC_MODIFY - 448)) | (1L << (MINITCOND - 448)) | (1L << (MINVFUNC - 448)) | (1L << (MODULUS - 448)) | (1L << (MSFUNC - 448)) | (1L << (MSSPACE - 448)) | (1L << (MSTYPE - 448)) | (1L << (NEGATOR - 448)) | (1L << (NOBYPASSRLS - 448)) | (1L << (NOCREATEDB - 448)) | (1L << (NOCREATEROLE - 448)) | (1L << (NOINHERIT - 448)) | (1L << (NOLOGIN - 448)) | (1L << (NOREPLICATION - 448)) | (1L << (NOSUPERUSER - 448)) | (1L << (OUTPUT - 448)) | (1L << (PASSEDBYVALUE - 448)) | (1L << (PATH - 448)) | (1L << (PERMISSIVE - 448)) | (1L << (PLAIN - 448)) | (1L << (PREFERRED - 448)) | (1L << (PROVIDER - 448)))) != 0) || ((((_la - 512)) & ~0x3f) == 0 && ((1L << (_la - 512)) & ((1L << (READ_ONLY - 512)) | (1L << (READ_WRITE - 512)) | (1L << (RECEIVE - 512)) | (1L << (REMAINDER - 512)) | (1L << (REPLICATION - 512)) | (1L << (RESTRICTED - 512)) | (1L << (RESTRICTIVE - 512)) | (1L << (RIGHTARG - 512)) | (1L << (SAFE - 512)) | (1L << (SEND - 512)) | (1L << (SERIALFUNC - 512)) | (1L << (SETTINGS - 512)) | (1L << (SFUNC - 512)) | (1L << (SHAREABLE - 512)) | (1L << (SKIP_LOCKED - 512)) | (1L << (SORTOP - 512)) | (1L << (SSPACE - 512)) | (1L << (STYPE - 512)) | (1L << (SUBTYPE_DIFF - 512)) | (1L << (SUBTYPE_OPCLASS - 512)) | (1L << (SUBTYPE - 512)) | (1L << (SUMMARY - 512)) | (1L << (SUPERUSER - 512)) | (1L << (TIMING - 512)) | (1L << (TYPMOD_IN - 512)) | (1L << (TYPMOD_OUT - 512)) | (1L << (UNSAFE - 512)) | (1L << (USAGE - 512)) | (1L << (VARIABLE - 512)) | (1L << (YAML - 512)) | (1L << (ALIAS - 512)) | (1L << (ASSERT - 512)) | (1L << (CONSTANT - 512)) | (1L << (DATATYPE - 512)) | (1L << (DEBUG - 512)) | (1L << (DETAIL - 512)) | (1L << (DIAGNOSTICS - 512)) | (1L << (ELSEIF - 512)) | (1L << (ELSIF - 512)) | (1L << (ERRCODE - 512)) | (1L << (EXIT - 512)) | (1L << (EXCEPTION - 512)) | (1L << (FOREACH - 512)) | (1L << (GET - 512)) | (1L << (HINT - 512)) | (1L << (INFO - 512)) | (1L << (LOG - 512)) | (1L << (LOOP - 512)) | (1L << (MESSAGE - 512)) | (1L << (NOTICE - 512)) | (1L << (OPEN - 512)) | (1L << (PERFORM - 512)) | (1L << (QUERY - 512)) | (1L << (RAISE - 512)) | (1L << (RECORD - 512)) | (1L << (RETURN - 512)) | (1L << (REVERSE - 512)) | (1L << (ROWTYPE - 512)) | (1L << (SLICE - 512)) | (1L << (SQLSTATE - 512)) | (1L << (STACKED - 512)) | (1L << (WARNING - 512)) | (1L << (WHILE - 512)))) != 0) || ((((_la - 585)) & ~0x3f) == 0 && ((1L << (_la - 585)) & ((1L << (LEFT_PAREN - 585)) | (1L << (PLUS - 585)) | (1L << (MINUS - 585)) | (1L << (MULTIPLY - 585)) | (1L << (LESS_LESS - 585)) | (1L << (GREATER_GREATER - 585)) | (1L << (HASH_SIGN - 585)) | (1L << (OP_CHARS - 585)) | (1L << (NUMBER_LITERAL - 585)) | (1L << (REAL_NUMBER - 585)) | (1L << (DOLLAR_NUMBER - 585)) | (1L << (Identifier - 585)) | (1L << (QuotedIdentifier - 585)) | (1L << (Character_String_Literal - 585)) | (1L << (BeginDollarStringConstant - 585)))) != 0)) {
					{
					State = 1433; vex(0);
					State = 1438;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					while (_la==COMMA) {
						{
						{
						State = 1434; Match(COMMA);
						State = 1435; vex(0);
						}
						}
						State = 1440;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					}
					}
				}

				State = 1443; Match(RIGHT_PAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Filter_clauseContext : ParserRuleContext {
		public ITerminalNode FILTER() { return GetToken(PlPgSqlParser.FILTER, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlPgSqlParser.LEFT_PAREN, 0); }
		public ITerminalNode WHERE() { return GetToken(PlPgSqlParser.WHERE, 0); }
		public VexContext vex() {
			return GetRuleContext<VexContext>(0);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlPgSqlParser.RIGHT_PAREN, 0); }
		public Filter_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_filter_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFilter_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Filter_clauseContext filter_clause() {
		Filter_clauseContext _localctx = new Filter_clauseContext(Context, State);
		EnterRule(_localctx, 106, RULE_filter_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1446; Match(FILTER);
			State = 1447; Match(LEFT_PAREN);
			State = 1448; Match(WHERE);
			State = 1449; vex(0);
			State = 1450; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Vex_or_named_notationContext : ParserRuleContext {
		public IdentifierContext argname;
		public VexContext vex() {
			return GetRuleContext<VexContext>(0);
		}
		public ITerminalNode VARIADIC() { return GetToken(PlPgSqlParser.VARIADIC, 0); }
		public PointerContext pointer() {
			return GetRuleContext<PointerContext>(0);
		}
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Vex_or_named_notationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_vex_or_named_notation; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVex_or_named_notation(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Vex_or_named_notationContext vex_or_named_notation() {
		Vex_or_named_notationContext _localctx = new Vex_or_named_notationContext(Context, State);
		EnterRule(_localctx, 108, RULE_vex_or_named_notation);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1453;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==VARIADIC) {
				{
				State = 1452; Match(VARIADIC);
				}
			}

			State = 1458;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,188,Context) ) {
			case 1:
				{
				State = 1455; _localctx.argname = identifier();
				State = 1456; pointer();
				}
				break;
			}
			State = 1460; vex(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PointerContext : ParserRuleContext {
		public ITerminalNode EQUAL_GTH() { return GetToken(PlPgSqlParser.EQUAL_GTH, 0); }
		public ITerminalNode COLON_EQUAL() { return GetToken(PlPgSqlParser.COLON_EQUAL, 0); }
		public PointerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pointer; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPointer(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PointerContext pointer() {
		PointerContext _localctx = new PointerContext(Context, State);
		EnterRule(_localctx, 110, RULE_pointer);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1462;
			_la = TokenStream.LA(1);
			if ( !(_la==EQUAL_GTH || _la==COLON_EQUAL) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Table_subqueryContext : ParserRuleContext {
		public ITerminalNode LEFT_PAREN() { return GetToken(PlPgSqlParser.LEFT_PAREN, 0); }
		public Select_stmtContext select_stmt() {
			return GetRuleContext<Select_stmtContext>(0);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlPgSqlParser.RIGHT_PAREN, 0); }
		public Table_subqueryContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_table_subquery; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTable_subquery(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Table_subqueryContext table_subquery() {
		Table_subqueryContext _localctx = new Table_subqueryContext(Context, State);
		EnterRule(_localctx, 112, RULE_table_subquery);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1464; Match(LEFT_PAREN);
			State = 1465; select_stmt();
			State = 1466; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Names_in_parensContext : ParserRuleContext {
		public ITerminalNode LEFT_PAREN() { return GetToken(PlPgSqlParser.LEFT_PAREN, 0); }
		public Names_referencesContext names_references() {
			return GetRuleContext<Names_referencesContext>(0);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlPgSqlParser.RIGHT_PAREN, 0); }
		public Names_in_parensContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_names_in_parens; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNames_in_parens(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Names_in_parensContext names_in_parens() {
		Names_in_parensContext _localctx = new Names_in_parensContext(Context, State);
		EnterRule(_localctx, 114, RULE_names_in_parens);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1468; Match(LEFT_PAREN);
			State = 1469; names_references();
			State = 1470; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Names_referencesContext : ParserRuleContext {
		public Schema_qualified_nameContext[] schema_qualified_name() {
			return GetRuleContexts<Schema_qualified_nameContext>();
		}
		public Schema_qualified_nameContext schema_qualified_name(int i) {
			return GetRuleContext<Schema_qualified_nameContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlPgSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlPgSqlParser.COMMA, i);
		}
		public Names_referencesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_names_references; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNames_references(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Names_referencesContext names_references() {
		Names_referencesContext _localctx = new Names_referencesContext(Context, State);
		EnterRule(_localctx, 116, RULE_names_references);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1472; schema_qualified_name();
			State = 1477;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 1473; Match(COMMA);
				State = 1474; schema_qualified_name();
				}
				}
				State = 1479;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Alias_clauseContext : ParserRuleContext {
		public IdentifierContext alias;
		public IdentifierContext _identifier;
		public IList<IdentifierContext> _column_alias = new List<IdentifierContext>();
		public IdentifierContext[] identifier() {
			return GetRuleContexts<IdentifierContext>();
		}
		public IdentifierContext identifier(int i) {
			return GetRuleContext<IdentifierContext>(i);
		}
		public ITerminalNode AS() { return GetToken(PlPgSqlParser.AS, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlPgSqlParser.LEFT_PAREN, 0); }
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlPgSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(PlPgSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlPgSqlParser.COMMA, i);
		}
		public Alias_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alias_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlias_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Alias_clauseContext alias_clause() {
		Alias_clauseContext _localctx = new Alias_clauseContext(Context, State);
		EnterRule(_localctx, 118, RULE_alias_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1481;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AS) {
				{
				State = 1480; Match(AS);
				}
			}

			State = 1483; _localctx.alias = identifier();
			State = 1495;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,192,Context) ) {
			case 1:
				{
				State = 1484; Match(LEFT_PAREN);
				State = 1485; _localctx._identifier = identifier();
				_localctx._column_alias.Add(_localctx._identifier);
				State = 1490;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 1486; Match(COMMA);
					State = 1487; _localctx._identifier = identifier();
					_localctx._column_alias.Add(_localctx._identifier);
					}
					}
					State = 1492;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 1493; Match(RIGHT_PAREN);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Into_tableContext : ParserRuleContext {
		public ITerminalNode INTO() { return GetToken(PlPgSqlParser.INTO, 0); }
		public Schema_qualified_nameContext[] schema_qualified_name() {
			return GetRuleContexts<Schema_qualified_nameContext>();
		}
		public Schema_qualified_nameContext schema_qualified_name(int i) {
			return GetRuleContext<Schema_qualified_nameContext>(i);
		}
		public ITerminalNode TABLE() { return GetToken(PlPgSqlParser.TABLE, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(PlPgSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlPgSqlParser.COMMA, i);
		}
		public ITerminalNode TEMPORARY() { return GetToken(PlPgSqlParser.TEMPORARY, 0); }
		public ITerminalNode TEMP() { return GetToken(PlPgSqlParser.TEMP, 0); }
		public ITerminalNode UNLOGGED() { return GetToken(PlPgSqlParser.UNLOGGED, 0); }
		public Into_tableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_into_table; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInto_table(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Into_tableContext into_table() {
		Into_tableContext _localctx = new Into_tableContext(Context, State);
		EnterRule(_localctx, 120, RULE_into_table);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1497; Match(INTO);
			State = 1499;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,193,Context) ) {
			case 1:
				{
				State = 1498;
				_la = TokenStream.LA(1);
				if ( !(((((_la - 253)) & ~0x3f) == 0 && ((1L << (_la - 253)) & ((1L << (TEMP - 253)) | (1L << (TEMPORARY - 253)) | (1L << (UNLOGGED - 253)))) != 0)) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			}
			State = 1502;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==TABLE) {
				{
				State = 1501; Match(TABLE);
				}
			}

			State = 1504; schema_qualified_name();
			State = 1509;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,195,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 1505; Match(COMMA);
					State = 1506; schema_qualified_name();
					}
					} 
				}
				State = 1511;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,195,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Set_qualifierContext : ParserRuleContext {
		public ITerminalNode DISTINCT() { return GetToken(PlPgSqlParser.DISTINCT, 0); }
		public ITerminalNode ALL() { return GetToken(PlPgSqlParser.ALL, 0); }
		public Set_qualifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_set_qualifier; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSet_qualifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Set_qualifierContext set_qualifier() {
		Set_qualifierContext _localctx = new Set_qualifierContext(Context, State);
		EnterRule(_localctx, 122, RULE_set_qualifier);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1512;
			_la = TokenStream.LA(1);
			if ( !(_la==ALL || _la==DISTINCT) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class With_clauseContext : ParserRuleContext {
		public ITerminalNode WITH() { return GetToken(PlPgSqlParser.WITH, 0); }
		public With_queryContext[] with_query() {
			return GetRuleContexts<With_queryContext>();
		}
		public With_queryContext with_query(int i) {
			return GetRuleContext<With_queryContext>(i);
		}
		public ITerminalNode RECURSIVE() { return GetToken(PlPgSqlParser.RECURSIVE, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(PlPgSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlPgSqlParser.COMMA, i);
		}
		public With_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_with_clause; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWith_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public With_clauseContext with_clause() {
		With_clauseContext _localctx = new With_clauseContext(Context, State);
		EnterRule(_localctx, 124, RULE_with_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1514; Match(WITH);
			State = 1516;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,196,Context) ) {
			case 1:
				{
				State = 1515; Match(RECURSIVE);
				}
				break;
			}
			State = 1518; with_query();
			State = 1523;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 1519; Match(COMMA);
				State = 1520; with_query();
				}
				}
				State = 1525;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class With_queryContext : ParserRuleContext {
		public IdentifierContext query_name;
		public IdentifierContext _identifier;
		public IList<IdentifierContext> _column_name = new List<IdentifierContext>();
		public ITerminalNode AS() { return GetToken(PlPgSqlParser.AS, 0); }
		public ITerminalNode[] LEFT_PAREN() { return GetTokens(PlPgSqlParser.LEFT_PAREN); }
		public ITerminalNode LEFT_PAREN(int i) {
			return GetToken(PlPgSqlParser.LEFT_PAREN, i);
		}
		public ITerminalNode[] RIGHT_PAREN() { return GetTokens(PlPgSqlParser.RIGHT_PAREN); }
		public ITerminalNode RIGHT_PAREN(int i) {
			return GetToken(PlPgSqlParser.RIGHT_PAREN, i);
		}
		public IdentifierContext[] identifier() {
			return GetRuleContexts<IdentifierContext>();
		}
		public IdentifierContext identifier(int i) {
			return GetRuleContext<IdentifierContext>(i);
		}
		public Select_stmtContext select_stmt() {
			return GetRuleContext<Select_stmtContext>(0);
		}
		public Insert_stmt_for_psqlContext insert_stmt_for_psql() {
			return GetRuleContext<Insert_stmt_for_psqlContext>(0);
		}
		public Update_stmt_for_psqlContext update_stmt_for_psql() {
			return GetRuleContext<Update_stmt_for_psqlContext>(0);
		}
		public Delete_stmt_for_psqlContext delete_stmt_for_psql() {
			return GetRuleContext<Delete_stmt_for_psqlContext>(0);
		}
		public ITerminalNode MATERIALIZED() { return GetToken(PlPgSqlParser.MATERIALIZED, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(PlPgSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlPgSqlParser.COMMA, i);
		}
		public ITerminalNode NOT() { return GetToken(PlPgSqlParser.NOT, 0); }
		public With_queryContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_with_query; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWith_query(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public With_queryContext with_query() {
		With_queryContext _localctx = new With_queryContext(Context, State);
		EnterRule(_localctx, 126, RULE_with_query);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1526; _localctx.query_name = identifier();
			State = 1538;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LEFT_PAREN) {
				{
				State = 1527; Match(LEFT_PAREN);
				State = 1528; _localctx._identifier = identifier();
				_localctx._column_name.Add(_localctx._identifier);
				State = 1533;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 1529; Match(COMMA);
					State = 1530; _localctx._identifier = identifier();
					_localctx._column_name.Add(_localctx._identifier);
					}
					}
					State = 1535;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 1536; Match(RIGHT_PAREN);
				}
			}

			State = 1540; Match(AS);
			State = 1545;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==MATERIALIZED || _la==NOT) {
				{
				State = 1542;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==NOT) {
					{
					State = 1541; Match(NOT);
					}
				}

				State = 1544; Match(MATERIALIZED);
				}
			}

			State = 1547; Match(LEFT_PAREN);
			State = 1552;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,202,Context) ) {
			case 1:
				{
				State = 1548; select_stmt();
				}
				break;
			case 2:
				{
				State = 1549; insert_stmt_for_psql();
				}
				break;
			case 3:
				{
				State = 1550; update_stmt_for_psql();
				}
				break;
			case 4:
				{
				State = 1551; delete_stmt_for_psql();
				}
				break;
			}
			State = 1554; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Delete_stmt_for_psqlContext : ParserRuleContext {
		public Schema_qualified_nameContext delete_table_name;
		public IdentifierContext alias;
		public IdentifierContext cursor;
		public ITerminalNode DELETE() { return GetToken(PlPgSqlParser.DELETE, 0); }
		public ITerminalNode FROM() { return GetToken(PlPgSqlParser.FROM, 0); }
		public Schema_qualified_nameContext schema_qualified_name() {
			return GetRuleContext<Schema_qualified_nameContext>(0);
		}
		public With_clauseContext with_clause() {
			return GetRuleContext<With_clauseContext>(0);
		}
		public ITerminalNode ONLY() { return GetToken(PlPgSqlParser.ONLY, 0); }
		public ITerminalNode MULTIPLY() { return GetToken(PlPgSqlParser.MULTIPLY, 0); }
		public ITerminalNode USING() { return GetToken(PlPgSqlParser.USING, 0); }
		public From_itemContext[] from_item() {
			return GetRuleContexts<From_itemContext>();
		}
		public From_itemContext from_item(int i) {
			return GetRuleContext<From_itemContext>(i);
		}
		public ITerminalNode WHERE() { return GetToken(PlPgSqlParser.WHERE, 0); }
		public ITerminalNode RETURNING() { return GetToken(PlPgSqlParser.RETURNING, 0); }
		public Select_listContext select_list() {
			return GetRuleContext<Select_listContext>(0);
		}
		public IdentifierContext[] identifier() {
			return GetRuleContexts<IdentifierContext>();
		}
		public IdentifierContext identifier(int i) {
			return GetRuleContext<IdentifierContext>(i);
		}
		public VexContext vex() {
			return GetRuleContext<VexContext>(0);
		}
		public ITerminalNode CURRENT() { return GetToken(PlPgSqlParser.CURRENT, 0); }
		public ITerminalNode OF() { return GetToken(PlPgSqlParser.OF, 0); }
		public ITerminalNode AS() { return GetToken(PlPgSqlParser.AS, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(PlPgSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlPgSqlParser.COMMA, i);
		}
		public Delete_stmt_for_psqlContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_delete_stmt_for_psql; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDelete_stmt_for_psql(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Delete_stmt_for_psqlContext delete_stmt_for_psql() {
		Delete_stmt_for_psqlContext _localctx = new Delete_stmt_for_psqlContext(Context, State);
		EnterRule(_localctx, 128, RULE_delete_stmt_for_psql);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1557;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WITH) {
				{
				State = 1556; with_clause();
				}
			}

			State = 1559; Match(DELETE);
			State = 1560; Match(FROM);
			State = 1562;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ONLY) {
				{
				State = 1561; Match(ONLY);
				}
			}

			State = 1564; _localctx.delete_table_name = schema_qualified_name();
			State = 1566;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==MULTIPLY) {
				{
				State = 1565; Match(MULTIPLY);
				}
			}

			State = 1572;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,207,Context) ) {
			case 1:
				{
				State = 1569;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==AS) {
					{
					State = 1568; Match(AS);
					}
				}

				State = 1571; _localctx.alias = identifier();
				}
				break;
			}
			State = 1583;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==USING) {
				{
				State = 1574; Match(USING);
				State = 1575; from_item(0);
				State = 1580;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 1576; Match(COMMA);
					State = 1577; from_item(0);
					}
					}
					State = 1582;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
			}

			State = 1592;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE) {
				{
				State = 1585; Match(WHERE);
				State = 1590;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,210,Context) ) {
				case 1:
					{
					State = 1586; vex(0);
					}
					break;
				case 2:
					{
					State = 1587; Match(CURRENT);
					State = 1588; Match(OF);
					State = 1589; _localctx.cursor = identifier();
					}
					break;
				}
				}
			}

			State = 1596;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==RETURNING) {
				{
				State = 1594; Match(RETURNING);
				State = 1595; select_list();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Update_stmt_for_psqlContext : ParserRuleContext {
		public Schema_qualified_nameContext update_table_name;
		public IdentifierContext alias;
		public IdentifierContext cursor;
		public ITerminalNode UPDATE() { return GetToken(PlPgSqlParser.UPDATE, 0); }
		public ITerminalNode SET() { return GetToken(PlPgSqlParser.SET, 0); }
		public Update_setContext[] update_set() {
			return GetRuleContexts<Update_setContext>();
		}
		public Update_setContext update_set(int i) {
			return GetRuleContext<Update_setContext>(i);
		}
		public Schema_qualified_nameContext schema_qualified_name() {
			return GetRuleContext<Schema_qualified_nameContext>(0);
		}
		public With_clauseContext with_clause() {
			return GetRuleContext<With_clauseContext>(0);
		}
		public ITerminalNode ONLY() { return GetToken(PlPgSqlParser.ONLY, 0); }
		public ITerminalNode MULTIPLY() { return GetToken(PlPgSqlParser.MULTIPLY, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(PlPgSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlPgSqlParser.COMMA, i);
		}
		public ITerminalNode FROM() { return GetToken(PlPgSqlParser.FROM, 0); }
		public From_itemContext[] from_item() {
			return GetRuleContexts<From_itemContext>();
		}
		public From_itemContext from_item(int i) {
			return GetRuleContext<From_itemContext>(i);
		}
		public ITerminalNode WHERE() { return GetToken(PlPgSqlParser.WHERE, 0); }
		public ITerminalNode RETURNING() { return GetToken(PlPgSqlParser.RETURNING, 0); }
		public Select_listContext select_list() {
			return GetRuleContext<Select_listContext>(0);
		}
		public IdentifierContext[] identifier() {
			return GetRuleContexts<IdentifierContext>();
		}
		public IdentifierContext identifier(int i) {
			return GetRuleContext<IdentifierContext>(i);
		}
		public VexContext vex() {
			return GetRuleContext<VexContext>(0);
		}
		public ITerminalNode CURRENT() { return GetToken(PlPgSqlParser.CURRENT, 0); }
		public ITerminalNode OF() { return GetToken(PlPgSqlParser.OF, 0); }
		public ITerminalNode AS() { return GetToken(PlPgSqlParser.AS, 0); }
		public Update_stmt_for_psqlContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_update_stmt_for_psql; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUpdate_stmt_for_psql(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Update_stmt_for_psqlContext update_stmt_for_psql() {
		Update_stmt_for_psqlContext _localctx = new Update_stmt_for_psqlContext(Context, State);
		EnterRule(_localctx, 130, RULE_update_stmt_for_psql);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1599;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WITH) {
				{
				State = 1598; with_clause();
				}
			}

			State = 1601; Match(UPDATE);
			State = 1603;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ONLY) {
				{
				State = 1602; Match(ONLY);
				}
			}

			State = 1605; _localctx.update_table_name = schema_qualified_name();
			State = 1607;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==MULTIPLY) {
				{
				State = 1606; Match(MULTIPLY);
				}
			}

			State = 1613;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,217,Context) ) {
			case 1:
				{
				State = 1610;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==AS) {
					{
					State = 1609; Match(AS);
					}
				}

				State = 1612; _localctx.alias = identifier();
				}
				break;
			}
			State = 1615; Match(SET);
			State = 1616; update_set();
			State = 1621;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 1617; Match(COMMA);
				State = 1618; update_set();
				}
				}
				State = 1623;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 1633;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FROM) {
				{
				State = 1624; Match(FROM);
				State = 1625; from_item(0);
				State = 1630;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 1626; Match(COMMA);
					State = 1627; from_item(0);
					}
					}
					State = 1632;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
			}

			State = 1642;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE) {
				{
				State = 1635; Match(WHERE);
				State = 1640;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,221,Context) ) {
				case 1:
					{
					State = 1636; vex(0);
					}
					break;
				case 2:
					{
					State = 1637; Match(CURRENT);
					State = 1638; Match(OF);
					State = 1639; _localctx.cursor = identifier();
					}
					break;
				}
				}
			}

			State = 1646;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==RETURNING) {
				{
				State = 1644; Match(RETURNING);
				State = 1645; select_list();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Update_setContext : ParserRuleContext {
		public Indirection_identifierContext _indirection_identifier;
		public IList<Indirection_identifierContext> _column = new List<Indirection_identifierContext>();
		public VexContext _vex;
		public IList<VexContext> _value = new List<VexContext>();
		public ITerminalNode EQUAL() { return GetToken(PlPgSqlParser.EQUAL, 0); }
		public Indirection_identifierContext[] indirection_identifier() {
			return GetRuleContexts<Indirection_identifierContext>();
		}
		public Indirection_identifierContext indirection_identifier(int i) {
			return GetRuleContext<Indirection_identifierContext>(i);
		}
		public ITerminalNode[] DEFAULT() { return GetTokens(PlPgSqlParser.DEFAULT); }
		public ITerminalNode DEFAULT(int i) {
			return GetToken(PlPgSqlParser.DEFAULT, i);
		}
		public VexContext[] vex() {
			return GetRuleContexts<VexContext>();
		}
		public VexContext vex(int i) {
			return GetRuleContext<VexContext>(i);
		}
		public ITerminalNode[] LEFT_PAREN() { return GetTokens(PlPgSqlParser.LEFT_PAREN); }
		public ITerminalNode LEFT_PAREN(int i) {
			return GetToken(PlPgSqlParser.LEFT_PAREN, i);
		}
		public ITerminalNode[] RIGHT_PAREN() { return GetTokens(PlPgSqlParser.RIGHT_PAREN); }
		public ITerminalNode RIGHT_PAREN(int i) {
			return GetToken(PlPgSqlParser.RIGHT_PAREN, i);
		}
		public Table_subqueryContext table_subquery() {
			return GetRuleContext<Table_subqueryContext>(0);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlPgSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlPgSqlParser.COMMA, i);
		}
		public ITerminalNode ROW() { return GetToken(PlPgSqlParser.ROW, 0); }
		public Update_setContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_update_set; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUpdate_set(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Update_setContext update_set() {
		Update_setContext _localctx = new Update_setContext(Context, State);
		EnterRule(_localctx, 132, RULE_update_set);
		int _la;
		try {
			State = 1687;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ABORT:
			case ABSOLUTE:
			case ACCESS:
			case ACTION:
			case ADD:
			case ADMIN:
			case AFTER:
			case AGGREGATE:
			case ALSO:
			case ALTER:
			case ALWAYS:
			case ASSERTION:
			case ASSIGNMENT:
			case AT:
			case ATTACH:
			case ATTRIBUTE:
			case BACKWARD:
			case BEFORE:
			case BEGIN:
			case BY:
			case CACHE:
			case CALL:
			case CALLED:
			case CASCADE:
			case CASCADED:
			case CATALOG:
			case CHAIN:
			case CHARACTERISTICS:
			case CHECKPOINT:
			case CLASS:
			case CLOSE:
			case CLUSTER:
			case COLUMNS:
			case COMMENT:
			case COMMENTS:
			case COMMIT:
			case COMMITTED:
			case CONFIGURATION:
			case CONFLICT:
			case CONNECTION:
			case CONSTRAINTS:
			case CONTENT:
			case CONTINUE:
			case CONVERSION:
			case COPY:
			case COST:
			case CSV:
			case CUBE:
			case CURRENT:
			case CURSOR:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DAY:
			case DEALLOCATE:
			case DECLARE:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DELIMITER:
			case DELIMITERS:
			case DEPENDS:
			case DETACH:
			case DICTIONARY:
			case DISABLE:
			case DISCARD:
			case DOCUMENT:
			case DOMAIN:
			case DOUBLE:
			case DROP:
			case EACH:
			case ENABLE:
			case ENCODING:
			case ENCRYPTED:
			case ENUM:
			case ESCAPE:
			case EVENT:
			case EXCLUDE:
			case EXCLUDING:
			case EXCLUSIVE:
			case EXECUTE:
			case EXPLAIN:
			case EXTENSION:
			case EXTERNAL:
			case FAMILY:
			case FILTER:
			case FIRST:
			case FOLLOWING:
			case FORCE:
			case FORWARD:
			case FUNCTION:
			case FUNCTIONS:
			case GENERATED:
			case GLOBAL:
			case GRANTED:
			case GROUPS:
			case HANDLER:
			case HEADER:
			case HOLD:
			case HOUR:
			case IDENTITY:
			case IF:
			case IMMEDIATE:
			case IMMUTABLE:
			case IMPLICIT:
			case IMPORT:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDEX:
			case INDEXES:
			case INHERIT:
			case INHERITS:
			case INLINE:
			case INPUT:
			case INSENSITIVE:
			case INSERT:
			case INSTEAD:
			case INVOKER:
			case ISOLATION:
			case KEY:
			case LABEL:
			case LANGUAGE:
			case LARGE:
			case LAST:
			case LEAKPROOF:
			case LEVEL:
			case LISTEN:
			case LOAD:
			case LOCAL:
			case LOCATION:
			case LOCK:
			case LOCKED:
			case LOGGED:
			case MAPPING:
			case MATCH:
			case MATERIALIZED:
			case MAXVALUE:
			case METHOD:
			case MINUTE:
			case MINVALUE:
			case MODE:
			case MONTH:
			case MOVE:
			case NAME:
			case NAMES:
			case NEW:
			case NEXT:
			case NO:
			case NOTHING:
			case NOTIFY:
			case NOWAIT:
			case NULLS:
			case OBJECT:
			case OF:
			case OFF:
			case OIDS:
			case OLD:
			case OPERATOR:
			case OPTION:
			case OPTIONS:
			case ORDINALITY:
			case OTHERS:
			case OVER:
			case OVERRIDING:
			case OWNED:
			case OWNER:
			case PARALLEL:
			case PARSER:
			case PARTIAL:
			case PARTITION:
			case PASSING:
			case PASSWORD:
			case PLANS:
			case POLICY:
			case PRECEDING:
			case PREPARE:
			case PREPARED:
			case PRESERVE:
			case PRIOR:
			case PRIVILEGES:
			case PROCEDURAL:
			case PROCEDURE:
			case PROCEDURES:
			case PROGRAM:
			case PUBLICATION:
			case QUOTE:
			case RANGE:
			case READ:
			case REASSIGN:
			case RECHECK:
			case RECURSIVE:
			case REF:
			case REFERENCING:
			case REFRESH:
			case REINDEX:
			case RELATIVE:
			case RELEASE:
			case RENAME:
			case REPEATABLE:
			case REPLACE:
			case REPLICA:
			case RESET:
			case RESTART:
			case RESTRICT:
			case RETURNS:
			case REVOKE:
			case ROLE:
			case ROLLBACK:
			case ROLLUP:
			case ROUTINE:
			case ROUTINES:
			case ROWS:
			case RULE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMAS:
			case SCROLL:
			case SEARCH:
			case SECOND:
			case SECURITY:
			case SEQUENCE:
			case SEQUENCES:
			case SERIALIZABLE:
			case SERVER:
			case SESSION:
			case SET:
			case SETS:
			case SHARE:
			case SHOW:
			case SIMPLE:
			case SKIP_:
			case SNAPSHOT:
			case SQL:
			case STABLE:
			case STANDALONE:
			case START:
			case STATEMENT:
			case STATISTICS:
			case STDIN:
			case STDOUT:
			case STORAGE:
			case STORED:
			case STRICT:
			case STRIP:
			case SUBSCRIPTION:
			case SUPPORT:
			case SYSID:
			case SYSTEM:
			case TABLES:
			case TABLESPACE:
			case TEMP:
			case TEMPLATE:
			case TEMPORARY:
			case TEXT:
			case TIES:
			case TRANSACTION:
			case TRANSFORM:
			case TRIGGER:
			case TRUNCATE:
			case TRUSTED:
			case TYPE:
			case TYPES:
			case UNBOUNDED:
			case UNCOMMITTED:
			case UNENCRYPTED:
			case UNKNOWN:
			case UNLISTEN:
			case UNLOGGED:
			case UNTIL:
			case UPDATE:
			case VACUUM:
			case VALID:
			case VALIDATE:
			case VALIDATOR:
			case VALUE:
			case VARYING:
			case VERSION:
			case VIEW:
			case VIEWS:
			case VOLATILE:
			case WHITESPACE:
			case WITHIN:
			case WITHOUT:
			case WORK:
			case WRAPPER:
			case WRITE:
			case XML:
			case YEAR:
			case YES:
			case ZONE:
			case BETWEEN:
			case BIGINT:
			case BIT:
			case BOOLEAN:
			case CHAR:
			case CHARACTER:
			case COALESCE:
			case DEC:
			case DECIMAL:
			case EXISTS:
			case EXTRACT:
			case FLOAT:
			case GREATEST:
			case GROUPING:
			case INOUT:
			case INT:
			case INTEGER:
			case INTERVAL:
			case LEAST:
			case NATIONAL:
			case NCHAR:
			case NONE:
			case NULLIF:
			case NUMERIC:
			case OUT:
			case OVERLAY:
			case POSITION:
			case PRECISION:
			case REAL:
			case ROW:
			case SETOF:
			case SMALLINT:
			case SUBSTRING:
			case TIME:
			case TIMESTAMP:
			case TREAT:
			case TRIM:
			case VALUES:
			case VARCHAR:
			case XMLATTRIBUTES:
			case XMLCONCAT:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case ALIGNMENT:
			case BASETYPE:
			case BUFFERS:
			case BYPASSRLS:
			case CANONICAL:
			case CATEGORY:
			case COLLATABLE:
			case COMBINEFUNC:
			case COMMUTATOR:
			case CONNECT:
			case COSTS:
			case CREATEDB:
			case CREATEROLE:
			case DESERIALFUNC:
			case DETERMINISTIC:
			case DISABLE_PAGE_SKIPPING:
			case ELEMENT:
			case EXTENDED:
			case FINALFUNC:
			case FINALFUNC_EXTRA:
			case FINALFUNC_MODIFY:
			case FORCE_NOT_NULL:
			case FORCE_NULL:
			case FORCE_QUOTE:
			case FORMAT:
			case GETTOKEN:
			case HASH:
			case HASHES:
			case HEADLINE:
			case HYPOTHETICAL:
			case INDEX_CLEANUP:
			case INIT:
			case INITCOND:
			case INTERNALLENGTH:
			case JSON:
			case LC_COLLATE:
			case LC_CTYPE:
			case LEFTARG:
			case LEXIZE:
			case LEXTYPES:
			case LIST:
			case LOCALE:
			case LOGIN:
			case MAIN:
			case MERGES:
			case MFINALFUNC:
			case MFINALFUNC_EXTRA:
			case MFINALFUNC_MODIFY:
			case MINITCOND:
			case MINVFUNC:
			case MODULUS:
			case MSFUNC:
			case MSSPACE:
			case MSTYPE:
			case NEGATOR:
			case NOBYPASSRLS:
			case NOCREATEDB:
			case NOCREATEROLE:
			case NOINHERIT:
			case NOLOGIN:
			case NOREPLICATION:
			case NOSUPERUSER:
			case OUTPUT:
			case PASSEDBYVALUE:
			case PATH:
			case PERMISSIVE:
			case PLAIN:
			case PREFERRED:
			case PROVIDER:
			case READ_ONLY:
			case READ_WRITE:
			case RECEIVE:
			case REMAINDER:
			case REPLICATION:
			case RESTRICTED:
			case RESTRICTIVE:
			case RIGHTARG:
			case SAFE:
			case SEND:
			case SERIALFUNC:
			case SETTINGS:
			case SFUNC:
			case SHAREABLE:
			case SKIP_LOCKED:
			case SORTOP:
			case SSPACE:
			case STYPE:
			case SUBTYPE_DIFF:
			case SUBTYPE_OPCLASS:
			case SUBTYPE:
			case SUMMARY:
			case SUPERUSER:
			case TIMING:
			case TYPMOD_IN:
			case TYPMOD_OUT:
			case UNSAFE:
			case USAGE:
			case VARIABLE:
			case YAML:
			case ALIAS:
			case ASSERT:
			case CONSTANT:
			case DATATYPE:
			case DEBUG:
			case DETAIL:
			case DIAGNOSTICS:
			case ELSEIF:
			case ELSIF:
			case ERRCODE:
			case EXIT:
			case EXCEPTION:
			case FOREACH:
			case GET:
			case HINT:
			case INFO:
			case LOG:
			case LOOP:
			case MESSAGE:
			case NOTICE:
			case OPEN:
			case PERFORM:
			case QUERY:
			case RAISE:
			case RECORD:
			case RETURN:
			case REVERSE:
			case ROWTYPE:
			case SLICE:
			case SQLSTATE:
			case STACKED:
			case WARNING:
			case WHILE:
			case Identifier:
			case QuotedIdentifier:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1648; _localctx._indirection_identifier = indirection_identifier();
				_localctx._column.Add(_localctx._indirection_identifier);
				State = 1649; Match(EQUAL);
				State = 1652;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case ABORT:
				case ABSOLUTE:
				case ACCESS:
				case ACTION:
				case ADD:
				case ADMIN:
				case AFTER:
				case AGGREGATE:
				case ALSO:
				case ALTER:
				case ALWAYS:
				case ASSERTION:
				case ASSIGNMENT:
				case AT:
				case ATTACH:
				case ATTRIBUTE:
				case BACKWARD:
				case BEFORE:
				case BEGIN:
				case BY:
				case CACHE:
				case CALL:
				case CALLED:
				case CASCADE:
				case CASCADED:
				case CATALOG:
				case CHAIN:
				case CHARACTERISTICS:
				case CHECKPOINT:
				case CLASS:
				case CLOSE:
				case CLUSTER:
				case COLUMNS:
				case COMMENT:
				case COMMENTS:
				case COMMIT:
				case COMMITTED:
				case CONFIGURATION:
				case CONFLICT:
				case CONNECTION:
				case CONSTRAINTS:
				case CONTENT:
				case CONTINUE:
				case CONVERSION:
				case COPY:
				case COST:
				case CSV:
				case CUBE:
				case CURRENT:
				case CURSOR:
				case CYCLE:
				case DATA:
				case DATABASE:
				case DAY:
				case DEALLOCATE:
				case DECLARE:
				case DEFAULTS:
				case DEFERRED:
				case DEFINER:
				case DELETE:
				case DELIMITER:
				case DELIMITERS:
				case DEPENDS:
				case DETACH:
				case DICTIONARY:
				case DISABLE:
				case DISCARD:
				case DOCUMENT:
				case DOMAIN:
				case DOUBLE:
				case DROP:
				case EACH:
				case ENABLE:
				case ENCODING:
				case ENCRYPTED:
				case ENUM:
				case ESCAPE:
				case EVENT:
				case EXCLUDE:
				case EXCLUDING:
				case EXCLUSIVE:
				case EXECUTE:
				case EXPLAIN:
				case EXTENSION:
				case EXTERNAL:
				case FAMILY:
				case FILTER:
				case FIRST:
				case FOLLOWING:
				case FORCE:
				case FORWARD:
				case FUNCTION:
				case FUNCTIONS:
				case GENERATED:
				case GLOBAL:
				case GRANTED:
				case GROUPS:
				case HANDLER:
				case HEADER:
				case HOLD:
				case HOUR:
				case IDENTITY:
				case IF:
				case IMMEDIATE:
				case IMMUTABLE:
				case IMPLICIT:
				case IMPORT:
				case INCLUDE:
				case INCLUDING:
				case INCREMENT:
				case INDEX:
				case INDEXES:
				case INHERIT:
				case INHERITS:
				case INLINE:
				case INPUT:
				case INSENSITIVE:
				case INSERT:
				case INSTEAD:
				case INVOKER:
				case ISOLATION:
				case KEY:
				case LABEL:
				case LANGUAGE:
				case LARGE:
				case LAST:
				case LEAKPROOF:
				case LEVEL:
				case LISTEN:
				case LOAD:
				case LOCAL:
				case LOCATION:
				case LOCK:
				case LOCKED:
				case LOGGED:
				case MAPPING:
				case MATCH:
				case MATERIALIZED:
				case MAXVALUE:
				case METHOD:
				case MINUTE:
				case MINVALUE:
				case MODE:
				case MONTH:
				case MOVE:
				case NAME:
				case NAMES:
				case NEW:
				case NEXT:
				case NO:
				case NOTHING:
				case NOTIFY:
				case NOWAIT:
				case NULLS:
				case OBJECT:
				case OF:
				case OFF:
				case OIDS:
				case OLD:
				case OPERATOR:
				case OPTION:
				case OPTIONS:
				case ORDINALITY:
				case OTHERS:
				case OVER:
				case OVERRIDING:
				case OWNED:
				case OWNER:
				case PARALLEL:
				case PARSER:
				case PARTIAL:
				case PARTITION:
				case PASSING:
				case PASSWORD:
				case PLANS:
				case POLICY:
				case PRECEDING:
				case PREPARE:
				case PREPARED:
				case PRESERVE:
				case PRIOR:
				case PRIVILEGES:
				case PROCEDURAL:
				case PROCEDURE:
				case PROCEDURES:
				case PROGRAM:
				case PUBLICATION:
				case QUOTE:
				case RANGE:
				case READ:
				case REASSIGN:
				case RECHECK:
				case RECURSIVE:
				case REF:
				case REFERENCING:
				case REFRESH:
				case REINDEX:
				case RELATIVE:
				case RELEASE:
				case RENAME:
				case REPEATABLE:
				case REPLACE:
				case REPLICA:
				case RESET:
				case RESTART:
				case RESTRICT:
				case RETURNS:
				case REVOKE:
				case ROLE:
				case ROLLBACK:
				case ROLLUP:
				case ROUTINE:
				case ROUTINES:
				case ROWS:
				case RULE:
				case SAVEPOINT:
				case SCHEMA:
				case SCHEMAS:
				case SCROLL:
				case SEARCH:
				case SECOND:
				case SECURITY:
				case SEQUENCE:
				case SEQUENCES:
				case SERIALIZABLE:
				case SERVER:
				case SESSION:
				case SET:
				case SETS:
				case SHARE:
				case SHOW:
				case SIMPLE:
				case SKIP_:
				case SNAPSHOT:
				case SQL:
				case STABLE:
				case STANDALONE:
				case START:
				case STATEMENT:
				case STATISTICS:
				case STDIN:
				case STDOUT:
				case STORAGE:
				case STORED:
				case STRICT:
				case STRIP:
				case SUBSCRIPTION:
				case SUPPORT:
				case SYSID:
				case SYSTEM:
				case TABLES:
				case TABLESPACE:
				case TEMP:
				case TEMPLATE:
				case TEMPORARY:
				case TEXT:
				case TIES:
				case TRANSACTION:
				case TRANSFORM:
				case TRIGGER:
				case TRUNCATE:
				case TRUSTED:
				case TYPE:
				case TYPES:
				case UNBOUNDED:
				case UNCOMMITTED:
				case UNENCRYPTED:
				case UNKNOWN:
				case UNLISTEN:
				case UNLOGGED:
				case UNTIL:
				case UPDATE:
				case VACUUM:
				case VALID:
				case VALIDATE:
				case VALIDATOR:
				case VALUE:
				case VARYING:
				case VERSION:
				case VIEW:
				case VIEWS:
				case VOLATILE:
				case WHITESPACE:
				case WITHIN:
				case WITHOUT:
				case WORK:
				case WRAPPER:
				case WRITE:
				case XML:
				case YEAR:
				case YES:
				case ZONE:
				case BETWEEN:
				case BIGINT:
				case BIT:
				case BOOLEAN:
				case CHAR:
				case CHARACTER:
				case COALESCE:
				case DEC:
				case DECIMAL:
				case EXISTS:
				case EXTRACT:
				case FLOAT:
				case GREATEST:
				case GROUPING:
				case INOUT:
				case INT:
				case INTEGER:
				case INTERVAL:
				case LEAST:
				case NATIONAL:
				case NCHAR:
				case NONE:
				case NULLIF:
				case NUMERIC:
				case OUT:
				case OVERLAY:
				case POSITION:
				case PRECISION:
				case REAL:
				case ROW:
				case SETOF:
				case SMALLINT:
				case SUBSTRING:
				case TIME:
				case TIMESTAMP:
				case TREAT:
				case TRIM:
				case VALUES:
				case VARCHAR:
				case XMLATTRIBUTES:
				case XMLCONCAT:
				case XMLELEMENT:
				case XMLEXISTS:
				case XMLFOREST:
				case XMLNAMESPACES:
				case XMLPARSE:
				case XMLPI:
				case XMLROOT:
				case XMLSERIALIZE:
				case XMLTABLE:
				case AUTHORIZATION:
				case BINARY:
				case COLLATION:
				case CONCURRENTLY:
				case CROSS:
				case CURRENT_SCHEMA:
				case FREEZE:
				case FULL:
				case ILIKE:
				case INNER:
				case IS:
				case ISNULL:
				case JOIN:
				case LEFT:
				case LIKE:
				case NATURAL:
				case NOTNULL:
				case OUTER:
				case OVERLAPS:
				case RIGHT:
				case SIMILAR:
				case TABLESAMPLE:
				case VERBOSE:
				case ALL:
				case ANY:
				case ARRAY:
				case CASE:
				case CAST:
				case CURRENT_CATALOG:
				case CURRENT_DATE:
				case CURRENT_TIME:
				case CURRENT_TIMESTAMP:
				case CURRENT_USER:
				case FALSE:
				case LOCALTIME:
				case LOCALTIMESTAMP:
				case NOT:
				case NULL:
				case ON:
				case SESSION_USER:
				case SOME:
				case TRUE:
				case USER:
				case ALIGNMENT:
				case BASETYPE:
				case BUFFERS:
				case BYPASSRLS:
				case CANONICAL:
				case CATEGORY:
				case COLLATABLE:
				case COMBINEFUNC:
				case COMMUTATOR:
				case CONNECT:
				case COSTS:
				case CREATEDB:
				case CREATEROLE:
				case DESERIALFUNC:
				case DETERMINISTIC:
				case DISABLE_PAGE_SKIPPING:
				case ELEMENT:
				case EXTENDED:
				case FINALFUNC:
				case FINALFUNC_EXTRA:
				case FINALFUNC_MODIFY:
				case FORCE_NOT_NULL:
				case FORCE_NULL:
				case FORCE_QUOTE:
				case FORMAT:
				case GETTOKEN:
				case HASH:
				case HASHES:
				case HEADLINE:
				case HYPOTHETICAL:
				case INDEX_CLEANUP:
				case INIT:
				case INITCOND:
				case INTERNALLENGTH:
				case JSON:
				case LC_COLLATE:
				case LC_CTYPE:
				case LEFTARG:
				case LEXIZE:
				case LEXTYPES:
				case LIST:
				case LOCALE:
				case LOGIN:
				case MAIN:
				case MERGES:
				case MFINALFUNC:
				case MFINALFUNC_EXTRA:
				case MFINALFUNC_MODIFY:
				case MINITCOND:
				case MINVFUNC:
				case MODULUS:
				case MSFUNC:
				case MSSPACE:
				case MSTYPE:
				case NEGATOR:
				case NOBYPASSRLS:
				case NOCREATEDB:
				case NOCREATEROLE:
				case NOINHERIT:
				case NOLOGIN:
				case NOREPLICATION:
				case NOSUPERUSER:
				case OUTPUT:
				case PASSEDBYVALUE:
				case PATH:
				case PERMISSIVE:
				case PLAIN:
				case PREFERRED:
				case PROVIDER:
				case READ_ONLY:
				case READ_WRITE:
				case RECEIVE:
				case REMAINDER:
				case REPLICATION:
				case RESTRICTED:
				case RESTRICTIVE:
				case RIGHTARG:
				case SAFE:
				case SEND:
				case SERIALFUNC:
				case SETTINGS:
				case SFUNC:
				case SHAREABLE:
				case SKIP_LOCKED:
				case SORTOP:
				case SSPACE:
				case STYPE:
				case SUBTYPE_DIFF:
				case SUBTYPE_OPCLASS:
				case SUBTYPE:
				case SUMMARY:
				case SUPERUSER:
				case TIMING:
				case TYPMOD_IN:
				case TYPMOD_OUT:
				case UNSAFE:
				case USAGE:
				case VARIABLE:
				case YAML:
				case ALIAS:
				case ASSERT:
				case CONSTANT:
				case DATATYPE:
				case DEBUG:
				case DETAIL:
				case DIAGNOSTICS:
				case ELSEIF:
				case ELSIF:
				case ERRCODE:
				case EXIT:
				case EXCEPTION:
				case FOREACH:
				case GET:
				case HINT:
				case INFO:
				case LOG:
				case LOOP:
				case MESSAGE:
				case NOTICE:
				case OPEN:
				case PERFORM:
				case QUERY:
				case RAISE:
				case RECORD:
				case RETURN:
				case REVERSE:
				case ROWTYPE:
				case SLICE:
				case SQLSTATE:
				case STACKED:
				case WARNING:
				case WHILE:
				case LEFT_PAREN:
				case PLUS:
				case MINUS:
				case MULTIPLY:
				case LESS_LESS:
				case GREATER_GREATER:
				case HASH_SIGN:
				case OP_CHARS:
				case NUMBER_LITERAL:
				case REAL_NUMBER:
				case DOLLAR_NUMBER:
				case Identifier:
				case QuotedIdentifier:
				case Character_String_Literal:
				case BeginDollarStringConstant:
					{
					State = 1650; _localctx._vex = vex(0);
					_localctx._value.Add(_localctx._vex);
					}
					break;
				case DEFAULT:
					{
					State = 1651; Match(DEFAULT);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case LEFT_PAREN:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1654; Match(LEFT_PAREN);
				State = 1655; _localctx._indirection_identifier = indirection_identifier();
				_localctx._column.Add(_localctx._indirection_identifier);
				State = 1660;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 1656; Match(COMMA);
					State = 1657; _localctx._indirection_identifier = indirection_identifier();
					_localctx._column.Add(_localctx._indirection_identifier);
					}
					}
					State = 1662;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 1663; Match(RIGHT_PAREN);
				State = 1664; Match(EQUAL);
				State = 1666;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ROW) {
					{
					State = 1665; Match(ROW);
					}
				}

				State = 1685;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,230,Context) ) {
				case 1:
					{
					State = 1668; Match(LEFT_PAREN);
					State = 1671;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case ABORT:
					case ABSOLUTE:
					case ACCESS:
					case ACTION:
					case ADD:
					case ADMIN:
					case AFTER:
					case AGGREGATE:
					case ALSO:
					case ALTER:
					case ALWAYS:
					case ASSERTION:
					case ASSIGNMENT:
					case AT:
					case ATTACH:
					case ATTRIBUTE:
					case BACKWARD:
					case BEFORE:
					case BEGIN:
					case BY:
					case CACHE:
					case CALL:
					case CALLED:
					case CASCADE:
					case CASCADED:
					case CATALOG:
					case CHAIN:
					case CHARACTERISTICS:
					case CHECKPOINT:
					case CLASS:
					case CLOSE:
					case CLUSTER:
					case COLUMNS:
					case COMMENT:
					case COMMENTS:
					case COMMIT:
					case COMMITTED:
					case CONFIGURATION:
					case CONFLICT:
					case CONNECTION:
					case CONSTRAINTS:
					case CONTENT:
					case CONTINUE:
					case CONVERSION:
					case COPY:
					case COST:
					case CSV:
					case CUBE:
					case CURRENT:
					case CURSOR:
					case CYCLE:
					case DATA:
					case DATABASE:
					case DAY:
					case DEALLOCATE:
					case DECLARE:
					case DEFAULTS:
					case DEFERRED:
					case DEFINER:
					case DELETE:
					case DELIMITER:
					case DELIMITERS:
					case DEPENDS:
					case DETACH:
					case DICTIONARY:
					case DISABLE:
					case DISCARD:
					case DOCUMENT:
					case DOMAIN:
					case DOUBLE:
					case DROP:
					case EACH:
					case ENABLE:
					case ENCODING:
					case ENCRYPTED:
					case ENUM:
					case ESCAPE:
					case EVENT:
					case EXCLUDE:
					case EXCLUDING:
					case EXCLUSIVE:
					case EXECUTE:
					case EXPLAIN:
					case EXTENSION:
					case EXTERNAL:
					case FAMILY:
					case FILTER:
					case FIRST:
					case FOLLOWING:
					case FORCE:
					case FORWARD:
					case FUNCTION:
					case FUNCTIONS:
					case GENERATED:
					case GLOBAL:
					case GRANTED:
					case GROUPS:
					case HANDLER:
					case HEADER:
					case HOLD:
					case HOUR:
					case IDENTITY:
					case IF:
					case IMMEDIATE:
					case IMMUTABLE:
					case IMPLICIT:
					case IMPORT:
					case INCLUDE:
					case INCLUDING:
					case INCREMENT:
					case INDEX:
					case INDEXES:
					case INHERIT:
					case INHERITS:
					case INLINE:
					case INPUT:
					case INSENSITIVE:
					case INSERT:
					case INSTEAD:
					case INVOKER:
					case ISOLATION:
					case KEY:
					case LABEL:
					case LANGUAGE:
					case LARGE:
					case LAST:
					case LEAKPROOF:
					case LEVEL:
					case LISTEN:
					case LOAD:
					case LOCAL:
					case LOCATION:
					case LOCK:
					case LOCKED:
					case LOGGED:
					case MAPPING:
					case MATCH:
					case MATERIALIZED:
					case MAXVALUE:
					case METHOD:
					case MINUTE:
					case MINVALUE:
					case MODE:
					case MONTH:
					case MOVE:
					case NAME:
					case NAMES:
					case NEW:
					case NEXT:
					case NO:
					case NOTHING:
					case NOTIFY:
					case NOWAIT:
					case NULLS:
					case OBJECT:
					case OF:
					case OFF:
					case OIDS:
					case OLD:
					case OPERATOR:
					case OPTION:
					case OPTIONS:
					case ORDINALITY:
					case OTHERS:
					case OVER:
					case OVERRIDING:
					case OWNED:
					case OWNER:
					case PARALLEL:
					case PARSER:
					case PARTIAL:
					case PARTITION:
					case PASSING:
					case PASSWORD:
					case PLANS:
					case POLICY:
					case PRECEDING:
					case PREPARE:
					case PREPARED:
					case PRESERVE:
					case PRIOR:
					case PRIVILEGES:
					case PROCEDURAL:
					case PROCEDURE:
					case PROCEDURES:
					case PROGRAM:
					case PUBLICATION:
					case QUOTE:
					case RANGE:
					case READ:
					case REASSIGN:
					case RECHECK:
					case RECURSIVE:
					case REF:
					case REFERENCING:
					case REFRESH:
					case REINDEX:
					case RELATIVE:
					case RELEASE:
					case RENAME:
					case REPEATABLE:
					case REPLACE:
					case REPLICA:
					case RESET:
					case RESTART:
					case RESTRICT:
					case RETURNS:
					case REVOKE:
					case ROLE:
					case ROLLBACK:
					case ROLLUP:
					case ROUTINE:
					case ROUTINES:
					case ROWS:
					case RULE:
					case SAVEPOINT:
					case SCHEMA:
					case SCHEMAS:
					case SCROLL:
					case SEARCH:
					case SECOND:
					case SECURITY:
					case SEQUENCE:
					case SEQUENCES:
					case SERIALIZABLE:
					case SERVER:
					case SESSION:
					case SET:
					case SETS:
					case SHARE:
					case SHOW:
					case SIMPLE:
					case SKIP_:
					case SNAPSHOT:
					case SQL:
					case STABLE:
					case STANDALONE:
					case START:
					case STATEMENT:
					case STATISTICS:
					case STDIN:
					case STDOUT:
					case STORAGE:
					case STORED:
					case STRICT:
					case STRIP:
					case SUBSCRIPTION:
					case SUPPORT:
					case SYSID:
					case SYSTEM:
					case TABLES:
					case TABLESPACE:
					case TEMP:
					case TEMPLATE:
					case TEMPORARY:
					case TEXT:
					case TIES:
					case TRANSACTION:
					case TRANSFORM:
					case TRIGGER:
					case TRUNCATE:
					case TRUSTED:
					case TYPE:
					case TYPES:
					case UNBOUNDED:
					case UNCOMMITTED:
					case UNENCRYPTED:
					case UNKNOWN:
					case UNLISTEN:
					case UNLOGGED:
					case UNTIL:
					case UPDATE:
					case VACUUM:
					case VALID:
					case VALIDATE:
					case VALIDATOR:
					case VALUE:
					case VARYING:
					case VERSION:
					case VIEW:
					case VIEWS:
					case VOLATILE:
					case WHITESPACE:
					case WITHIN:
					case WITHOUT:
					case WORK:
					case WRAPPER:
					case WRITE:
					case XML:
					case YEAR:
					case YES:
					case ZONE:
					case BETWEEN:
					case BIGINT:
					case BIT:
					case BOOLEAN:
					case CHAR:
					case CHARACTER:
					case COALESCE:
					case DEC:
					case DECIMAL:
					case EXISTS:
					case EXTRACT:
					case FLOAT:
					case GREATEST:
					case GROUPING:
					case INOUT:
					case INT:
					case INTEGER:
					case INTERVAL:
					case LEAST:
					case NATIONAL:
					case NCHAR:
					case NONE:
					case NULLIF:
					case NUMERIC:
					case OUT:
					case OVERLAY:
					case POSITION:
					case PRECISION:
					case REAL:
					case ROW:
					case SETOF:
					case SMALLINT:
					case SUBSTRING:
					case TIME:
					case TIMESTAMP:
					case TREAT:
					case TRIM:
					case VALUES:
					case VARCHAR:
					case XMLATTRIBUTES:
					case XMLCONCAT:
					case XMLELEMENT:
					case XMLEXISTS:
					case XMLFOREST:
					case XMLNAMESPACES:
					case XMLPARSE:
					case XMLPI:
					case XMLROOT:
					case XMLSERIALIZE:
					case XMLTABLE:
					case AUTHORIZATION:
					case BINARY:
					case COLLATION:
					case CONCURRENTLY:
					case CROSS:
					case CURRENT_SCHEMA:
					case FREEZE:
					case FULL:
					case ILIKE:
					case INNER:
					case IS:
					case ISNULL:
					case JOIN:
					case LEFT:
					case LIKE:
					case NATURAL:
					case NOTNULL:
					case OUTER:
					case OVERLAPS:
					case RIGHT:
					case SIMILAR:
					case TABLESAMPLE:
					case VERBOSE:
					case ALL:
					case ANY:
					case ARRAY:
					case CASE:
					case CAST:
					case CURRENT_CATALOG:
					case CURRENT_DATE:
					case CURRENT_TIME:
					case CURRENT_TIMESTAMP:
					case CURRENT_USER:
					case FALSE:
					case LOCALTIME:
					case LOCALTIMESTAMP:
					case NOT:
					case NULL:
					case ON:
					case SESSION_USER:
					case SOME:
					case TRUE:
					case USER:
					case ALIGNMENT:
					case BASETYPE:
					case BUFFERS:
					case BYPASSRLS:
					case CANONICAL:
					case CATEGORY:
					case COLLATABLE:
					case COMBINEFUNC:
					case COMMUTATOR:
					case CONNECT:
					case COSTS:
					case CREATEDB:
					case CREATEROLE:
					case DESERIALFUNC:
					case DETERMINISTIC:
					case DISABLE_PAGE_SKIPPING:
					case ELEMENT:
					case EXTENDED:
					case FINALFUNC:
					case FINALFUNC_EXTRA:
					case FINALFUNC_MODIFY:
					case FORCE_NOT_NULL:
					case FORCE_NULL:
					case FORCE_QUOTE:
					case FORMAT:
					case GETTOKEN:
					case HASH:
					case HASHES:
					case HEADLINE:
					case HYPOTHETICAL:
					case INDEX_CLEANUP:
					case INIT:
					case INITCOND:
					case INTERNALLENGTH:
					case JSON:
					case LC_COLLATE:
					case LC_CTYPE:
					case LEFTARG:
					case LEXIZE:
					case LEXTYPES:
					case LIST:
					case LOCALE:
					case LOGIN:
					case MAIN:
					case MERGES:
					case MFINALFUNC:
					case MFINALFUNC_EXTRA:
					case MFINALFUNC_MODIFY:
					case MINITCOND:
					case MINVFUNC:
					case MODULUS:
					case MSFUNC:
					case MSSPACE:
					case MSTYPE:
					case NEGATOR:
					case NOBYPASSRLS:
					case NOCREATEDB:
					case NOCREATEROLE:
					case NOINHERIT:
					case NOLOGIN:
					case NOREPLICATION:
					case NOSUPERUSER:
					case OUTPUT:
					case PASSEDBYVALUE:
					case PATH:
					case PERMISSIVE:
					case PLAIN:
					case PREFERRED:
					case PROVIDER:
					case READ_ONLY:
					case READ_WRITE:
					case RECEIVE:
					case REMAINDER:
					case REPLICATION:
					case RESTRICTED:
					case RESTRICTIVE:
					case RIGHTARG:
					case SAFE:
					case SEND:
					case SERIALFUNC:
					case SETTINGS:
					case SFUNC:
					case SHAREABLE:
					case SKIP_LOCKED:
					case SORTOP:
					case SSPACE:
					case STYPE:
					case SUBTYPE_DIFF:
					case SUBTYPE_OPCLASS:
					case SUBTYPE:
					case SUMMARY:
					case SUPERUSER:
					case TIMING:
					case TYPMOD_IN:
					case TYPMOD_OUT:
					case UNSAFE:
					case USAGE:
					case VARIABLE:
					case YAML:
					case ALIAS:
					case ASSERT:
					case CONSTANT:
					case DATATYPE:
					case DEBUG:
					case DETAIL:
					case DIAGNOSTICS:
					case ELSEIF:
					case ELSIF:
					case ERRCODE:
					case EXIT:
					case EXCEPTION:
					case FOREACH:
					case GET:
					case HINT:
					case INFO:
					case LOG:
					case LOOP:
					case MESSAGE:
					case NOTICE:
					case OPEN:
					case PERFORM:
					case QUERY:
					case RAISE:
					case RECORD:
					case RETURN:
					case REVERSE:
					case ROWTYPE:
					case SLICE:
					case SQLSTATE:
					case STACKED:
					case WARNING:
					case WHILE:
					case LEFT_PAREN:
					case PLUS:
					case MINUS:
					case MULTIPLY:
					case LESS_LESS:
					case GREATER_GREATER:
					case HASH_SIGN:
					case OP_CHARS:
					case NUMBER_LITERAL:
					case REAL_NUMBER:
					case DOLLAR_NUMBER:
					case Identifier:
					case QuotedIdentifier:
					case Character_String_Literal:
					case BeginDollarStringConstant:
						{
						State = 1669; _localctx._vex = vex(0);
						_localctx._value.Add(_localctx._vex);
						}
						break;
					case DEFAULT:
						{
						State = 1670; Match(DEFAULT);
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 1680;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					while (_la==COMMA) {
						{
						{
						State = 1673; Match(COMMA);
						State = 1676;
						ErrorHandler.Sync(this);
						switch (TokenStream.LA(1)) {
						case ABORT:
						case ABSOLUTE:
						case ACCESS:
						case ACTION:
						case ADD:
						case ADMIN:
						case AFTER:
						case AGGREGATE:
						case ALSO:
						case ALTER:
						case ALWAYS:
						case ASSERTION:
						case ASSIGNMENT:
						case AT:
						case ATTACH:
						case ATTRIBUTE:
						case BACKWARD:
						case BEFORE:
						case BEGIN:
						case BY:
						case CACHE:
						case CALL:
						case CALLED:
						case CASCADE:
						case CASCADED:
						case CATALOG:
						case CHAIN:
						case CHARACTERISTICS:
						case CHECKPOINT:
						case CLASS:
						case CLOSE:
						case CLUSTER:
						case COLUMNS:
						case COMMENT:
						case COMMENTS:
						case COMMIT:
						case COMMITTED:
						case CONFIGURATION:
						case CONFLICT:
						case CONNECTION:
						case CONSTRAINTS:
						case CONTENT:
						case CONTINUE:
						case CONVERSION:
						case COPY:
						case COST:
						case CSV:
						case CUBE:
						case CURRENT:
						case CURSOR:
						case CYCLE:
						case DATA:
						case DATABASE:
						case DAY:
						case DEALLOCATE:
						case DECLARE:
						case DEFAULTS:
						case DEFERRED:
						case DEFINER:
						case DELETE:
						case DELIMITER:
						case DELIMITERS:
						case DEPENDS:
						case DETACH:
						case DICTIONARY:
						case DISABLE:
						case DISCARD:
						case DOCUMENT:
						case DOMAIN:
						case DOUBLE:
						case DROP:
						case EACH:
						case ENABLE:
						case ENCODING:
						case ENCRYPTED:
						case ENUM:
						case ESCAPE:
						case EVENT:
						case EXCLUDE:
						case EXCLUDING:
						case EXCLUSIVE:
						case EXECUTE:
						case EXPLAIN:
						case EXTENSION:
						case EXTERNAL:
						case FAMILY:
						case FILTER:
						case FIRST:
						case FOLLOWING:
						case FORCE:
						case FORWARD:
						case FUNCTION:
						case FUNCTIONS:
						case GENERATED:
						case GLOBAL:
						case GRANTED:
						case GROUPS:
						case HANDLER:
						case HEADER:
						case HOLD:
						case HOUR:
						case IDENTITY:
						case IF:
						case IMMEDIATE:
						case IMMUTABLE:
						case IMPLICIT:
						case IMPORT:
						case INCLUDE:
						case INCLUDING:
						case INCREMENT:
						case INDEX:
						case INDEXES:
						case INHERIT:
						case INHERITS:
						case INLINE:
						case INPUT:
						case INSENSITIVE:
						case INSERT:
						case INSTEAD:
						case INVOKER:
						case ISOLATION:
						case KEY:
						case LABEL:
						case LANGUAGE:
						case LARGE:
						case LAST:
						case LEAKPROOF:
						case LEVEL:
						case LISTEN:
						case LOAD:
						case LOCAL:
						case LOCATION:
						case LOCK:
						case LOCKED:
						case LOGGED:
						case MAPPING:
						case MATCH:
						case MATERIALIZED:
						case MAXVALUE:
						case METHOD:
						case MINUTE:
						case MINVALUE:
						case MODE:
						case MONTH:
						case MOVE:
						case NAME:
						case NAMES:
						case NEW:
						case NEXT:
						case NO:
						case NOTHING:
						case NOTIFY:
						case NOWAIT:
						case NULLS:
						case OBJECT:
						case OF:
						case OFF:
						case OIDS:
						case OLD:
						case OPERATOR:
						case OPTION:
						case OPTIONS:
						case ORDINALITY:
						case OTHERS:
						case OVER:
						case OVERRIDING:
						case OWNED:
						case OWNER:
						case PARALLEL:
						case PARSER:
						case PARTIAL:
						case PARTITION:
						case PASSING:
						case PASSWORD:
						case PLANS:
						case POLICY:
						case PRECEDING:
						case PREPARE:
						case PREPARED:
						case PRESERVE:
						case PRIOR:
						case PRIVILEGES:
						case PROCEDURAL:
						case PROCEDURE:
						case PROCEDURES:
						case PROGRAM:
						case PUBLICATION:
						case QUOTE:
						case RANGE:
						case READ:
						case REASSIGN:
						case RECHECK:
						case RECURSIVE:
						case REF:
						case REFERENCING:
						case REFRESH:
						case REINDEX:
						case RELATIVE:
						case RELEASE:
						case RENAME:
						case REPEATABLE:
						case REPLACE:
						case REPLICA:
						case RESET:
						case RESTART:
						case RESTRICT:
						case RETURNS:
						case REVOKE:
						case ROLE:
						case ROLLBACK:
						case ROLLUP:
						case ROUTINE:
						case ROUTINES:
						case ROWS:
						case RULE:
						case SAVEPOINT:
						case SCHEMA:
						case SCHEMAS:
						case SCROLL:
						case SEARCH:
						case SECOND:
						case SECURITY:
						case SEQUENCE:
						case SEQUENCES:
						case SERIALIZABLE:
						case SERVER:
						case SESSION:
						case SET:
						case SETS:
						case SHARE:
						case SHOW:
						case SIMPLE:
						case SKIP_:
						case SNAPSHOT:
						case SQL:
						case STABLE:
						case STANDALONE:
						case START:
						case STATEMENT:
						case STATISTICS:
						case STDIN:
						case STDOUT:
						case STORAGE:
						case STORED:
						case STRICT:
						case STRIP:
						case SUBSCRIPTION:
						case SUPPORT:
						case SYSID:
						case SYSTEM:
						case TABLES:
						case TABLESPACE:
						case TEMP:
						case TEMPLATE:
						case TEMPORARY:
						case TEXT:
						case TIES:
						case TRANSACTION:
						case TRANSFORM:
						case TRIGGER:
						case TRUNCATE:
						case TRUSTED:
						case TYPE:
						case TYPES:
						case UNBOUNDED:
						case UNCOMMITTED:
						case UNENCRYPTED:
						case UNKNOWN:
						case UNLISTEN:
						case UNLOGGED:
						case UNTIL:
						case UPDATE:
						case VACUUM:
						case VALID:
						case VALIDATE:
						case VALIDATOR:
						case VALUE:
						case VARYING:
						case VERSION:
						case VIEW:
						case VIEWS:
						case VOLATILE:
						case WHITESPACE:
						case WITHIN:
						case WITHOUT:
						case WORK:
						case WRAPPER:
						case WRITE:
						case XML:
						case YEAR:
						case YES:
						case ZONE:
						case BETWEEN:
						case BIGINT:
						case BIT:
						case BOOLEAN:
						case CHAR:
						case CHARACTER:
						case COALESCE:
						case DEC:
						case DECIMAL:
						case EXISTS:
						case EXTRACT:
						case FLOAT:
						case GREATEST:
						case GROUPING:
						case INOUT:
						case INT:
						case INTEGER:
						case INTERVAL:
						case LEAST:
						case NATIONAL:
						case NCHAR:
						case NONE:
						case NULLIF:
						case NUMERIC:
						case OUT:
						case OVERLAY:
						case POSITION:
						case PRECISION:
						case REAL:
						case ROW:
						case SETOF:
						case SMALLINT:
						case SUBSTRING:
						case TIME:
						case TIMESTAMP:
						case TREAT:
						case TRIM:
						case VALUES:
						case VARCHAR:
						case XMLATTRIBUTES:
						case XMLCONCAT:
						case XMLELEMENT:
						case XMLEXISTS:
						case XMLFOREST:
						case XMLNAMESPACES:
						case XMLPARSE:
						case XMLPI:
						case XMLROOT:
						case XMLSERIALIZE:
						case XMLTABLE:
						case AUTHORIZATION:
						case BINARY:
						case COLLATION:
						case CONCURRENTLY:
						case CROSS:
						case CURRENT_SCHEMA:
						case FREEZE:
						case FULL:
						case ILIKE:
						case INNER:
						case IS:
						case ISNULL:
						case JOIN:
						case LEFT:
						case LIKE:
						case NATURAL:
						case NOTNULL:
						case OUTER:
						case OVERLAPS:
						case RIGHT:
						case SIMILAR:
						case TABLESAMPLE:
						case VERBOSE:
						case ALL:
						case ANY:
						case ARRAY:
						case CASE:
						case CAST:
						case CURRENT_CATALOG:
						case CURRENT_DATE:
						case CURRENT_TIME:
						case CURRENT_TIMESTAMP:
						case CURRENT_USER:
						case FALSE:
						case LOCALTIME:
						case LOCALTIMESTAMP:
						case NOT:
						case NULL:
						case ON:
						case SESSION_USER:
						case SOME:
						case TRUE:
						case USER:
						case ALIGNMENT:
						case BASETYPE:
						case BUFFERS:
						case BYPASSRLS:
						case CANONICAL:
						case CATEGORY:
						case COLLATABLE:
						case COMBINEFUNC:
						case COMMUTATOR:
						case CONNECT:
						case COSTS:
						case CREATEDB:
						case CREATEROLE:
						case DESERIALFUNC:
						case DETERMINISTIC:
						case DISABLE_PAGE_SKIPPING:
						case ELEMENT:
						case EXTENDED:
						case FINALFUNC:
						case FINALFUNC_EXTRA:
						case FINALFUNC_MODIFY:
						case FORCE_NOT_NULL:
						case FORCE_NULL:
						case FORCE_QUOTE:
						case FORMAT:
						case GETTOKEN:
						case HASH:
						case HASHES:
						case HEADLINE:
						case HYPOTHETICAL:
						case INDEX_CLEANUP:
						case INIT:
						case INITCOND:
						case INTERNALLENGTH:
						case JSON:
						case LC_COLLATE:
						case LC_CTYPE:
						case LEFTARG:
						case LEXIZE:
						case LEXTYPES:
						case LIST:
						case LOCALE:
						case LOGIN:
						case MAIN:
						case MERGES:
						case MFINALFUNC:
						case MFINALFUNC_EXTRA:
						case MFINALFUNC_MODIFY:
						case MINITCOND:
						case MINVFUNC:
						case MODULUS:
						case MSFUNC:
						case MSSPACE:
						case MSTYPE:
						case NEGATOR:
						case NOBYPASSRLS:
						case NOCREATEDB:
						case NOCREATEROLE:
						case NOINHERIT:
						case NOLOGIN:
						case NOREPLICATION:
						case NOSUPERUSER:
						case OUTPUT:
						case PASSEDBYVALUE:
						case PATH:
						case PERMISSIVE:
						case PLAIN:
						case PREFERRED:
						case PROVIDER:
						case READ_ONLY:
						case READ_WRITE:
						case RECEIVE:
						case REMAINDER:
						case REPLICATION:
						case RESTRICTED:
						case RESTRICTIVE:
						case RIGHTARG:
						case SAFE:
						case SEND:
						case SERIALFUNC:
						case SETTINGS:
						case SFUNC:
						case SHAREABLE:
						case SKIP_LOCKED:
						case SORTOP:
						case SSPACE:
						case STYPE:
						case SUBTYPE_DIFF:
						case SUBTYPE_OPCLASS:
						case SUBTYPE:
						case SUMMARY:
						case SUPERUSER:
						case TIMING:
						case TYPMOD_IN:
						case TYPMOD_OUT:
						case UNSAFE:
						case USAGE:
						case VARIABLE:
						case YAML:
						case ALIAS:
						case ASSERT:
						case CONSTANT:
						case DATATYPE:
						case DEBUG:
						case DETAIL:
						case DIAGNOSTICS:
						case ELSEIF:
						case ELSIF:
						case ERRCODE:
						case EXIT:
						case EXCEPTION:
						case FOREACH:
						case GET:
						case HINT:
						case INFO:
						case LOG:
						case LOOP:
						case MESSAGE:
						case NOTICE:
						case OPEN:
						case PERFORM:
						case QUERY:
						case RAISE:
						case RECORD:
						case RETURN:
						case REVERSE:
						case ROWTYPE:
						case SLICE:
						case SQLSTATE:
						case STACKED:
						case WARNING:
						case WHILE:
						case LEFT_PAREN:
						case PLUS:
						case MINUS:
						case MULTIPLY:
						case LESS_LESS:
						case GREATER_GREATER:
						case HASH_SIGN:
						case OP_CHARS:
						case NUMBER_LITERAL:
						case REAL_NUMBER:
						case DOLLAR_NUMBER:
						case Identifier:
						case QuotedIdentifier:
						case Character_String_Literal:
						case BeginDollarStringConstant:
							{
							State = 1674; _localctx._vex = vex(0);
							_localctx._value.Add(_localctx._vex);
							}
							break;
						case DEFAULT:
							{
							State = 1675; Match(DEFAULT);
							}
							break;
						default:
							throw new NoViableAltException(this);
						}
						}
						}
						State = 1682;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					}
					State = 1683; Match(RIGHT_PAREN);
					}
					break;
				case 2:
					{
					State = 1684; table_subquery();
					}
					break;
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Indirection_identifierContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Indirection_listContext indirection_list() {
			return GetRuleContext<Indirection_listContext>(0);
		}
		public Indirection_identifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indirection_identifier; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIndirection_identifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Indirection_identifierContext indirection_identifier() {
		Indirection_identifierContext _localctx = new Indirection_identifierContext(Context, State);
		EnterRule(_localctx, 134, RULE_indirection_identifier);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1689; identifier();
			State = 1691;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DOT || _la==LEFT_BRACKET) {
				{
				State = 1690; indirection_list();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Indirection_listContext : ParserRuleContext {
		public IndirectionContext[] indirection() {
			return GetRuleContexts<IndirectionContext>();
		}
		public IndirectionContext indirection(int i) {
			return GetRuleContext<IndirectionContext>(i);
		}
		public ITerminalNode DOT() { return GetToken(PlPgSqlParser.DOT, 0); }
		public ITerminalNode MULTIPLY() { return GetToken(PlPgSqlParser.MULTIPLY, 0); }
		public Indirection_listContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indirection_list; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIndirection_list(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Indirection_listContext indirection_list() {
		Indirection_listContext _localctx = new Indirection_listContext(Context, State);
		EnterRule(_localctx, 136, RULE_indirection_list);
		try {
			int _alt;
			State = 1706;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,235,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1694;
				ErrorHandler.Sync(this);
				_alt = 1;
				do {
					switch (_alt) {
					case 1:
						{
						{
						State = 1693; indirection();
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 1696;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,233,Context);
				} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1701;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,234,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 1698; indirection();
						}
						} 
					}
					State = 1703;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,234,Context);
				}
				State = 1704; Match(DOT);
				State = 1705; Match(MULTIPLY);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndirectionContext : ParserRuleContext {
		public ITerminalNode DOT() { return GetToken(PlPgSqlParser.DOT, 0); }
		public Col_labelContext col_label() {
			return GetRuleContext<Col_labelContext>(0);
		}
		public ITerminalNode LEFT_BRACKET() { return GetToken(PlPgSqlParser.LEFT_BRACKET, 0); }
		public VexContext[] vex() {
			return GetRuleContexts<VexContext>();
		}
		public VexContext vex(int i) {
			return GetRuleContext<VexContext>(i);
		}
		public ITerminalNode RIGHT_BRACKET() { return GetToken(PlPgSqlParser.RIGHT_BRACKET, 0); }
		public ITerminalNode COLON() { return GetToken(PlPgSqlParser.COLON, 0); }
		public IndirectionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indirection; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIndirection(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IndirectionContext indirection() {
		IndirectionContext _localctx = new IndirectionContext(Context, State);
		EnterRule(_localctx, 138, RULE_indirection);
		int _la;
		try {
			State = 1723;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,238,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1708; Match(DOT);
				State = 1709; col_label();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1710; Match(LEFT_BRACKET);
				State = 1711; vex(0);
				State = 1712; Match(RIGHT_BRACKET);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1714; Match(LEFT_BRACKET);
				State = 1716;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ABORT) | (1L << ABSOLUTE) | (1L << ACCESS) | (1L << ACTION) | (1L << ADD) | (1L << ADMIN) | (1L << AFTER) | (1L << AGGREGATE) | (1L << ALSO) | (1L << ALTER) | (1L << ALWAYS) | (1L << ASSERTION) | (1L << ASSIGNMENT) | (1L << AT) | (1L << ATTACH) | (1L << ATTRIBUTE) | (1L << BACKWARD) | (1L << BEFORE) | (1L << BEGIN) | (1L << BY) | (1L << CACHE) | (1L << CALL) | (1L << CALLED) | (1L << CASCADE) | (1L << CASCADED) | (1L << CATALOG) | (1L << CHAIN) | (1L << CHARACTERISTICS) | (1L << CHECKPOINT) | (1L << CLASS) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMENTS) | (1L << COMMIT) | (1L << COMMITTED) | (1L << CONFIGURATION) | (1L << CONFLICT) | (1L << CONNECTION) | (1L << CONSTRAINTS) | (1L << CONTENT) | (1L << CONTINUE) | (1L << CONVERSION) | (1L << COPY) | (1L << COST) | (1L << CSV) | (1L << CUBE) | (1L << CURRENT) | (1L << CURSOR) | (1L << CYCLE) | (1L << DATA) | (1L << DATABASE) | (1L << DAY) | (1L << DEALLOCATE) | (1L << DECLARE) | (1L << DEFAULTS) | (1L << DEFERRED) | (1L << DEFINER) | (1L << DELETE) | (1L << DELIMITER) | (1L << DELIMITERS) | (1L << DEPENDS))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (DETACH - 64)) | (1L << (DICTIONARY - 64)) | (1L << (DISABLE - 64)) | (1L << (DISCARD - 64)) | (1L << (DOCUMENT - 64)) | (1L << (DOMAIN - 64)) | (1L << (DOUBLE - 64)) | (1L << (DROP - 64)) | (1L << (EACH - 64)) | (1L << (ENABLE - 64)) | (1L << (ENCODING - 64)) | (1L << (ENCRYPTED - 64)) | (1L << (ENUM - 64)) | (1L << (ESCAPE - 64)) | (1L << (EVENT - 64)) | (1L << (EXCLUDE - 64)) | (1L << (EXCLUDING - 64)) | (1L << (EXCLUSIVE - 64)) | (1L << (EXECUTE - 64)) | (1L << (EXPLAIN - 64)) | (1L << (EXTENSION - 64)) | (1L << (EXTERNAL - 64)) | (1L << (FAMILY - 64)) | (1L << (FILTER - 64)) | (1L << (FIRST - 64)) | (1L << (FOLLOWING - 64)) | (1L << (FORCE - 64)) | (1L << (FORWARD - 64)) | (1L << (FUNCTION - 64)) | (1L << (FUNCTIONS - 64)) | (1L << (GENERATED - 64)) | (1L << (GLOBAL - 64)) | (1L << (GRANTED - 64)) | (1L << (GROUPS - 64)) | (1L << (HANDLER - 64)) | (1L << (HEADER - 64)) | (1L << (HOLD - 64)) | (1L << (HOUR - 64)) | (1L << (IDENTITY - 64)) | (1L << (IF - 64)) | (1L << (IMMEDIATE - 64)) | (1L << (IMMUTABLE - 64)) | (1L << (IMPLICIT - 64)) | (1L << (IMPORT - 64)) | (1L << (INCLUDE - 64)) | (1L << (INCLUDING - 64)) | (1L << (INCREMENT - 64)) | (1L << (INDEX - 64)) | (1L << (INDEXES - 64)) | (1L << (INHERIT - 64)) | (1L << (INHERITS - 64)) | (1L << (INLINE - 64)) | (1L << (INPUT - 64)) | (1L << (INSENSITIVE - 64)) | (1L << (INSERT - 64)) | (1L << (INSTEAD - 64)) | (1L << (INVOKER - 64)) | (1L << (ISOLATION - 64)) | (1L << (KEY - 64)) | (1L << (LABEL - 64)) | (1L << (LANGUAGE - 64)) | (1L << (LARGE - 64)) | (1L << (LAST - 64)) | (1L << (LEAKPROOF - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (LEVEL - 128)) | (1L << (LISTEN - 128)) | (1L << (LOAD - 128)) | (1L << (LOCAL - 128)) | (1L << (LOCATION - 128)) | (1L << (LOCK - 128)) | (1L << (LOCKED - 128)) | (1L << (LOGGED - 128)) | (1L << (MAPPING - 128)) | (1L << (MATCH - 128)) | (1L << (MATERIALIZED - 128)) | (1L << (MAXVALUE - 128)) | (1L << (METHOD - 128)) | (1L << (MINUTE - 128)) | (1L << (MINVALUE - 128)) | (1L << (MODE - 128)) | (1L << (MONTH - 128)) | (1L << (MOVE - 128)) | (1L << (NAME - 128)) | (1L << (NAMES - 128)) | (1L << (NEW - 128)) | (1L << (NEXT - 128)) | (1L << (NO - 128)) | (1L << (NOTHING - 128)) | (1L << (NOTIFY - 128)) | (1L << (NOWAIT - 128)) | (1L << (NULLS - 128)) | (1L << (OBJECT - 128)) | (1L << (OF - 128)) | (1L << (OFF - 128)) | (1L << (OIDS - 128)) | (1L << (OLD - 128)) | (1L << (OPERATOR - 128)) | (1L << (OPTION - 128)) | (1L << (OPTIONS - 128)) | (1L << (ORDINALITY - 128)) | (1L << (OTHERS - 128)) | (1L << (OVER - 128)) | (1L << (OVERRIDING - 128)) | (1L << (OWNED - 128)) | (1L << (OWNER - 128)) | (1L << (PARALLEL - 128)) | (1L << (PARSER - 128)) | (1L << (PARTIAL - 128)) | (1L << (PARTITION - 128)) | (1L << (PASSING - 128)) | (1L << (PASSWORD - 128)) | (1L << (PLANS - 128)) | (1L << (POLICY - 128)) | (1L << (PRECEDING - 128)) | (1L << (PREPARE - 128)) | (1L << (PREPARED - 128)) | (1L << (PRESERVE - 128)) | (1L << (PRIOR - 128)) | (1L << (PRIVILEGES - 128)) | (1L << (PROCEDURAL - 128)) | (1L << (PROCEDURE - 128)) | (1L << (PROCEDURES - 128)) | (1L << (PROGRAM - 128)) | (1L << (PUBLICATION - 128)) | (1L << (QUOTE - 128)) | (1L << (RANGE - 128)) | (1L << (READ - 128)) | (1L << (REASSIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (RECHECK - 192)) | (1L << (RECURSIVE - 192)) | (1L << (REF - 192)) | (1L << (REFERENCING - 192)) | (1L << (REFRESH - 192)) | (1L << (REINDEX - 192)) | (1L << (RELATIVE - 192)) | (1L << (RELEASE - 192)) | (1L << (RENAME - 192)) | (1L << (REPEATABLE - 192)) | (1L << (REPLACE - 192)) | (1L << (REPLICA - 192)) | (1L << (RESET - 192)) | (1L << (RESTART - 192)) | (1L << (RESTRICT - 192)) | (1L << (RETURNS - 192)) | (1L << (REVOKE - 192)) | (1L << (ROLE - 192)) | (1L << (ROLLBACK - 192)) | (1L << (ROLLUP - 192)) | (1L << (ROUTINE - 192)) | (1L << (ROUTINES - 192)) | (1L << (ROWS - 192)) | (1L << (RULE - 192)) | (1L << (SAVEPOINT - 192)) | (1L << (SCHEMA - 192)) | (1L << (SCHEMAS - 192)) | (1L << (SCROLL - 192)) | (1L << (SEARCH - 192)) | (1L << (SECOND - 192)) | (1L << (SECURITY - 192)) | (1L << (SEQUENCE - 192)) | (1L << (SEQUENCES - 192)) | (1L << (SERIALIZABLE - 192)) | (1L << (SERVER - 192)) | (1L << (SESSION - 192)) | (1L << (SET - 192)) | (1L << (SETS - 192)) | (1L << (SHARE - 192)) | (1L << (SHOW - 192)) | (1L << (SIMPLE - 192)) | (1L << (SKIP_ - 192)) | (1L << (SNAPSHOT - 192)) | (1L << (SQL - 192)) | (1L << (STABLE - 192)) | (1L << (STANDALONE - 192)) | (1L << (START - 192)) | (1L << (STATEMENT - 192)) | (1L << (STATISTICS - 192)) | (1L << (STDIN - 192)) | (1L << (STDOUT - 192)) | (1L << (STORAGE - 192)) | (1L << (STORED - 192)) | (1L << (STRICT - 192)) | (1L << (STRIP - 192)) | (1L << (SUBSCRIPTION - 192)) | (1L << (SUPPORT - 192)) | (1L << (SYSID - 192)) | (1L << (SYSTEM - 192)) | (1L << (TABLES - 192)) | (1L << (TABLESPACE - 192)) | (1L << (TEMP - 192)) | (1L << (TEMPLATE - 192)) | (1L << (TEMPORARY - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (TEXT - 256)) | (1L << (TIES - 256)) | (1L << (TRANSACTION - 256)) | (1L << (TRANSFORM - 256)) | (1L << (TRIGGER - 256)) | (1L << (TRUNCATE - 256)) | (1L << (TRUSTED - 256)) | (1L << (TYPE - 256)) | (1L << (TYPES - 256)) | (1L << (UNBOUNDED - 256)) | (1L << (UNCOMMITTED - 256)) | (1L << (UNENCRYPTED - 256)) | (1L << (UNKNOWN - 256)) | (1L << (UNLISTEN - 256)) | (1L << (UNLOGGED - 256)) | (1L << (UNTIL - 256)) | (1L << (UPDATE - 256)) | (1L << (VACUUM - 256)) | (1L << (VALID - 256)) | (1L << (VALIDATE - 256)) | (1L << (VALIDATOR - 256)) | (1L << (VALUE - 256)) | (1L << (VARYING - 256)) | (1L << (VERSION - 256)) | (1L << (VIEW - 256)) | (1L << (VIEWS - 256)) | (1L << (VOLATILE - 256)) | (1L << (WHITESPACE - 256)) | (1L << (WITHIN - 256)) | (1L << (WITHOUT - 256)) | (1L << (WORK - 256)) | (1L << (WRAPPER - 256)) | (1L << (WRITE - 256)) | (1L << (XML - 256)) | (1L << (YEAR - 256)) | (1L << (YES - 256)) | (1L << (ZONE - 256)) | (1L << (BETWEEN - 256)) | (1L << (BIGINT - 256)) | (1L << (BIT - 256)) | (1L << (BOOLEAN - 256)) | (1L << (CHAR - 256)) | (1L << (CHARACTER - 256)) | (1L << (COALESCE - 256)) | (1L << (DEC - 256)) | (1L << (DECIMAL - 256)) | (1L << (EXISTS - 256)) | (1L << (EXTRACT - 256)) | (1L << (FLOAT - 256)) | (1L << (GREATEST - 256)) | (1L << (GROUPING - 256)) | (1L << (INOUT - 256)) | (1L << (INT - 256)) | (1L << (INTEGER - 256)) | (1L << (INTERVAL - 256)) | (1L << (LEAST - 256)) | (1L << (NATIONAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NONE - 256)) | (1L << (NULLIF - 256)) | (1L << (NUMERIC - 256)) | (1L << (OUT - 256)) | (1L << (OVERLAY - 256)) | (1L << (POSITION - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (PRECISION - 320)) | (1L << (REAL - 320)) | (1L << (ROW - 320)) | (1L << (SETOF - 320)) | (1L << (SMALLINT - 320)) | (1L << (SUBSTRING - 320)) | (1L << (TIME - 320)) | (1L << (TIMESTAMP - 320)) | (1L << (TREAT - 320)) | (1L << (TRIM - 320)) | (1L << (VALUES - 320)) | (1L << (VARCHAR - 320)) | (1L << (XMLATTRIBUTES - 320)) | (1L << (XMLCONCAT - 320)) | (1L << (XMLELEMENT - 320)) | (1L << (XMLEXISTS - 320)) | (1L << (XMLFOREST - 320)) | (1L << (XMLNAMESPACES - 320)) | (1L << (XMLPARSE - 320)) | (1L << (XMLPI - 320)) | (1L << (XMLROOT - 320)) | (1L << (XMLSERIALIZE - 320)) | (1L << (XMLTABLE - 320)) | (1L << (AUTHORIZATION - 320)) | (1L << (BINARY - 320)) | (1L << (COLLATION - 320)) | (1L << (CONCURRENTLY - 320)) | (1L << (CROSS - 320)) | (1L << (CURRENT_SCHEMA - 320)) | (1L << (FREEZE - 320)) | (1L << (FULL - 320)) | (1L << (ILIKE - 320)) | (1L << (INNER - 320)) | (1L << (IS - 320)) | (1L << (ISNULL - 320)) | (1L << (JOIN - 320)) | (1L << (LEFT - 320)) | (1L << (LIKE - 320)) | (1L << (NATURAL - 320)) | (1L << (NOTNULL - 320)) | (1L << (OUTER - 320)) | (1L << (OVERLAPS - 320)) | (1L << (RIGHT - 320)) | (1L << (SIMILAR - 320)) | (1L << (TABLESAMPLE - 320)) | (1L << (VERBOSE - 320)) | (1L << (ALL - 320)) | (1L << (ANY - 320)) | (1L << (ARRAY - 320)) | (1L << (CASE - 320)) | (1L << (CAST - 320)) | (1L << (CURRENT_CATALOG - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (CURRENT_DATE - 384)) | (1L << (CURRENT_TIME - 384)) | (1L << (CURRENT_TIMESTAMP - 384)) | (1L << (CURRENT_USER - 384)) | (1L << (FALSE - 384)) | (1L << (LOCALTIME - 384)) | (1L << (LOCALTIMESTAMP - 384)) | (1L << (NOT - 384)) | (1L << (NULL - 384)) | (1L << (ON - 384)) | (1L << (SESSION_USER - 384)) | (1L << (SOME - 384)) | (1L << (TRUE - 384)) | (1L << (USER - 384)) | (1L << (ALIGNMENT - 384)) | (1L << (BASETYPE - 384)) | (1L << (BUFFERS - 384)) | (1L << (BYPASSRLS - 384)) | (1L << (CANONICAL - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (CATEGORY - 448)) | (1L << (COLLATABLE - 448)) | (1L << (COMBINEFUNC - 448)) | (1L << (COMMUTATOR - 448)) | (1L << (CONNECT - 448)) | (1L << (COSTS - 448)) | (1L << (CREATEDB - 448)) | (1L << (CREATEROLE - 448)) | (1L << (DESERIALFUNC - 448)) | (1L << (DETERMINISTIC - 448)) | (1L << (DISABLE_PAGE_SKIPPING - 448)) | (1L << (ELEMENT - 448)) | (1L << (EXTENDED - 448)) | (1L << (FINALFUNC - 448)) | (1L << (FINALFUNC_EXTRA - 448)) | (1L << (FINALFUNC_MODIFY - 448)) | (1L << (FORCE_NOT_NULL - 448)) | (1L << (FORCE_NULL - 448)) | (1L << (FORCE_QUOTE - 448)) | (1L << (FORMAT - 448)) | (1L << (GETTOKEN - 448)) | (1L << (HASH - 448)) | (1L << (HASHES - 448)) | (1L << (HEADLINE - 448)) | (1L << (HYPOTHETICAL - 448)) | (1L << (INDEX_CLEANUP - 448)) | (1L << (INIT - 448)) | (1L << (INITCOND - 448)) | (1L << (INTERNALLENGTH - 448)) | (1L << (JSON - 448)) | (1L << (LC_COLLATE - 448)) | (1L << (LC_CTYPE - 448)) | (1L << (LEFTARG - 448)) | (1L << (LEXIZE - 448)) | (1L << (LEXTYPES - 448)) | (1L << (LIST - 448)) | (1L << (LOCALE - 448)) | (1L << (LOGIN - 448)) | (1L << (MAIN - 448)) | (1L << (MERGES - 448)) | (1L << (MFINALFUNC - 448)) | (1L << (MFINALFUNC_EXTRA - 448)) | (1L << (MFINALFUNC_MODIFY - 448)) | (1L << (MINITCOND - 448)) | (1L << (MINVFUNC - 448)) | (1L << (MODULUS - 448)) | (1L << (MSFUNC - 448)) | (1L << (MSSPACE - 448)) | (1L << (MSTYPE - 448)) | (1L << (NEGATOR - 448)) | (1L << (NOBYPASSRLS - 448)) | (1L << (NOCREATEDB - 448)) | (1L << (NOCREATEROLE - 448)) | (1L << (NOINHERIT - 448)) | (1L << (NOLOGIN - 448)) | (1L << (NOREPLICATION - 448)) | (1L << (NOSUPERUSER - 448)) | (1L << (OUTPUT - 448)) | (1L << (PASSEDBYVALUE - 448)) | (1L << (PATH - 448)) | (1L << (PERMISSIVE - 448)) | (1L << (PLAIN - 448)) | (1L << (PREFERRED - 448)) | (1L << (PROVIDER - 448)))) != 0) || ((((_la - 512)) & ~0x3f) == 0 && ((1L << (_la - 512)) & ((1L << (READ_ONLY - 512)) | (1L << (READ_WRITE - 512)) | (1L << (RECEIVE - 512)) | (1L << (REMAINDER - 512)) | (1L << (REPLICATION - 512)) | (1L << (RESTRICTED - 512)) | (1L << (RESTRICTIVE - 512)) | (1L << (RIGHTARG - 512)) | (1L << (SAFE - 512)) | (1L << (SEND - 512)) | (1L << (SERIALFUNC - 512)) | (1L << (SETTINGS - 512)) | (1L << (SFUNC - 512)) | (1L << (SHAREABLE - 512)) | (1L << (SKIP_LOCKED - 512)) | (1L << (SORTOP - 512)) | (1L << (SSPACE - 512)) | (1L << (STYPE - 512)) | (1L << (SUBTYPE_DIFF - 512)) | (1L << (SUBTYPE_OPCLASS - 512)) | (1L << (SUBTYPE - 512)) | (1L << (SUMMARY - 512)) | (1L << (SUPERUSER - 512)) | (1L << (TIMING - 512)) | (1L << (TYPMOD_IN - 512)) | (1L << (TYPMOD_OUT - 512)) | (1L << (UNSAFE - 512)) | (1L << (USAGE - 512)) | (1L << (VARIABLE - 512)) | (1L << (YAML - 512)) | (1L << (ALIAS - 512)) | (1L << (ASSERT - 512)) | (1L << (CONSTANT - 512)) | (1L << (DATATYPE - 512)) | (1L << (DEBUG - 512)) | (1L << (DETAIL - 512)) | (1L << (DIAGNOSTICS - 512)) | (1L << (ELSEIF - 512)) | (1L << (ELSIF - 512)) | (1L << (ERRCODE - 512)) | (1L << (EXIT - 512)) | (1L << (EXCEPTION - 512)) | (1L << (FOREACH - 512)) | (1L << (GET - 512)) | (1L << (HINT - 512)) | (1L << (INFO - 512)) | (1L << (LOG - 512)) | (1L << (LOOP - 512)) | (1L << (MESSAGE - 512)) | (1L << (NOTICE - 512)) | (1L << (OPEN - 512)) | (1L << (PERFORM - 512)) | (1L << (QUERY - 512)) | (1L << (RAISE - 512)) | (1L << (RECORD - 512)) | (1L << (RETURN - 512)) | (1L << (REVERSE - 512)) | (1L << (ROWTYPE - 512)) | (1L << (SLICE - 512)) | (1L << (SQLSTATE - 512)) | (1L << (STACKED - 512)) | (1L << (WARNING - 512)) | (1L << (WHILE - 512)))) != 0) || ((((_la - 585)) & ~0x3f) == 0 && ((1L << (_la - 585)) & ((1L << (LEFT_PAREN - 585)) | (1L << (PLUS - 585)) | (1L << (MINUS - 585)) | (1L << (MULTIPLY - 585)) | (1L << (LESS_LESS - 585)) | (1L << (GREATER_GREATER - 585)) | (1L << (HASH_SIGN - 585)) | (1L << (OP_CHARS - 585)) | (1L << (NUMBER_LITERAL - 585)) | (1L << (REAL_NUMBER - 585)) | (1L << (DOLLAR_NUMBER - 585)) | (1L << (Identifier - 585)) | (1L << (QuotedIdentifier - 585)) | (1L << (Character_String_Literal - 585)) | (1L << (BeginDollarStringConstant - 585)))) != 0)) {
					{
					State = 1715; vex(0);
					}
				}

				State = 1718; Match(COLON);
				State = 1720;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ABORT) | (1L << ABSOLUTE) | (1L << ACCESS) | (1L << ACTION) | (1L << ADD) | (1L << ADMIN) | (1L << AFTER) | (1L << AGGREGATE) | (1L << ALSO) | (1L << ALTER) | (1L << ALWAYS) | (1L << ASSERTION) | (1L << ASSIGNMENT) | (1L << AT) | (1L << ATTACH) | (1L << ATTRIBUTE) | (1L << BACKWARD) | (1L << BEFORE) | (1L << BEGIN) | (1L << BY) | (1L << CACHE) | (1L << CALL) | (1L << CALLED) | (1L << CASCADE) | (1L << CASCADED) | (1L << CATALOG) | (1L << CHAIN) | (1L << CHARACTERISTICS) | (1L << CHECKPOINT) | (1L << CLASS) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMENTS) | (1L << COMMIT) | (1L << COMMITTED) | (1L << CONFIGURATION) | (1L << CONFLICT) | (1L << CONNECTION) | (1L << CONSTRAINTS) | (1L << CONTENT) | (1L << CONTINUE) | (1L << CONVERSION) | (1L << COPY) | (1L << COST) | (1L << CSV) | (1L << CUBE) | (1L << CURRENT) | (1L << CURSOR) | (1L << CYCLE) | (1L << DATA) | (1L << DATABASE) | (1L << DAY) | (1L << DEALLOCATE) | (1L << DECLARE) | (1L << DEFAULTS) | (1L << DEFERRED) | (1L << DEFINER) | (1L << DELETE) | (1L << DELIMITER) | (1L << DELIMITERS) | (1L << DEPENDS))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (DETACH - 64)) | (1L << (DICTIONARY - 64)) | (1L << (DISABLE - 64)) | (1L << (DISCARD - 64)) | (1L << (DOCUMENT - 64)) | (1L << (DOMAIN - 64)) | (1L << (DOUBLE - 64)) | (1L << (DROP - 64)) | (1L << (EACH - 64)) | (1L << (ENABLE - 64)) | (1L << (ENCODING - 64)) | (1L << (ENCRYPTED - 64)) | (1L << (ENUM - 64)) | (1L << (ESCAPE - 64)) | (1L << (EVENT - 64)) | (1L << (EXCLUDE - 64)) | (1L << (EXCLUDING - 64)) | (1L << (EXCLUSIVE - 64)) | (1L << (EXECUTE - 64)) | (1L << (EXPLAIN - 64)) | (1L << (EXTENSION - 64)) | (1L << (EXTERNAL - 64)) | (1L << (FAMILY - 64)) | (1L << (FILTER - 64)) | (1L << (FIRST - 64)) | (1L << (FOLLOWING - 64)) | (1L << (FORCE - 64)) | (1L << (FORWARD - 64)) | (1L << (FUNCTION - 64)) | (1L << (FUNCTIONS - 64)) | (1L << (GENERATED - 64)) | (1L << (GLOBAL - 64)) | (1L << (GRANTED - 64)) | (1L << (GROUPS - 64)) | (1L << (HANDLER - 64)) | (1L << (HEADER - 64)) | (1L << (HOLD - 64)) | (1L << (HOUR - 64)) | (1L << (IDENTITY - 64)) | (1L << (IF - 64)) | (1L << (IMMEDIATE - 64)) | (1L << (IMMUTABLE - 64)) | (1L << (IMPLICIT - 64)) | (1L << (IMPORT - 64)) | (1L << (INCLUDE - 64)) | (1L << (INCLUDING - 64)) | (1L << (INCREMENT - 64)) | (1L << (INDEX - 64)) | (1L << (INDEXES - 64)) | (1L << (INHERIT - 64)) | (1L << (INHERITS - 64)) | (1L << (INLINE - 64)) | (1L << (INPUT - 64)) | (1L << (INSENSITIVE - 64)) | (1L << (INSERT - 64)) | (1L << (INSTEAD - 64)) | (1L << (INVOKER - 64)) | (1L << (ISOLATION - 64)) | (1L << (KEY - 64)) | (1L << (LABEL - 64)) | (1L << (LANGUAGE - 64)) | (1L << (LARGE - 64)) | (1L << (LAST - 64)) | (1L << (LEAKPROOF - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (LEVEL - 128)) | (1L << (LISTEN - 128)) | (1L << (LOAD - 128)) | (1L << (LOCAL - 128)) | (1L << (LOCATION - 128)) | (1L << (LOCK - 128)) | (1L << (LOCKED - 128)) | (1L << (LOGGED - 128)) | (1L << (MAPPING - 128)) | (1L << (MATCH - 128)) | (1L << (MATERIALIZED - 128)) | (1L << (MAXVALUE - 128)) | (1L << (METHOD - 128)) | (1L << (MINUTE - 128)) | (1L << (MINVALUE - 128)) | (1L << (MODE - 128)) | (1L << (MONTH - 128)) | (1L << (MOVE - 128)) | (1L << (NAME - 128)) | (1L << (NAMES - 128)) | (1L << (NEW - 128)) | (1L << (NEXT - 128)) | (1L << (NO - 128)) | (1L << (NOTHING - 128)) | (1L << (NOTIFY - 128)) | (1L << (NOWAIT - 128)) | (1L << (NULLS - 128)) | (1L << (OBJECT - 128)) | (1L << (OF - 128)) | (1L << (OFF - 128)) | (1L << (OIDS - 128)) | (1L << (OLD - 128)) | (1L << (OPERATOR - 128)) | (1L << (OPTION - 128)) | (1L << (OPTIONS - 128)) | (1L << (ORDINALITY - 128)) | (1L << (OTHERS - 128)) | (1L << (OVER - 128)) | (1L << (OVERRIDING - 128)) | (1L << (OWNED - 128)) | (1L << (OWNER - 128)) | (1L << (PARALLEL - 128)) | (1L << (PARSER - 128)) | (1L << (PARTIAL - 128)) | (1L << (PARTITION - 128)) | (1L << (PASSING - 128)) | (1L << (PASSWORD - 128)) | (1L << (PLANS - 128)) | (1L << (POLICY - 128)) | (1L << (PRECEDING - 128)) | (1L << (PREPARE - 128)) | (1L << (PREPARED - 128)) | (1L << (PRESERVE - 128)) | (1L << (PRIOR - 128)) | (1L << (PRIVILEGES - 128)) | (1L << (PROCEDURAL - 128)) | (1L << (PROCEDURE - 128)) | (1L << (PROCEDURES - 128)) | (1L << (PROGRAM - 128)) | (1L << (PUBLICATION - 128)) | (1L << (QUOTE - 128)) | (1L << (RANGE - 128)) | (1L << (READ - 128)) | (1L << (REASSIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (RECHECK - 192)) | (1L << (RECURSIVE - 192)) | (1L << (REF - 192)) | (1L << (REFERENCING - 192)) | (1L << (REFRESH - 192)) | (1L << (REINDEX - 192)) | (1L << (RELATIVE - 192)) | (1L << (RELEASE - 192)) | (1L << (RENAME - 192)) | (1L << (REPEATABLE - 192)) | (1L << (REPLACE - 192)) | (1L << (REPLICA - 192)) | (1L << (RESET - 192)) | (1L << (RESTART - 192)) | (1L << (RESTRICT - 192)) | (1L << (RETURNS - 192)) | (1L << (REVOKE - 192)) | (1L << (ROLE - 192)) | (1L << (ROLLBACK - 192)) | (1L << (ROLLUP - 192)) | (1L << (ROUTINE - 192)) | (1L << (ROUTINES - 192)) | (1L << (ROWS - 192)) | (1L << (RULE - 192)) | (1L << (SAVEPOINT - 192)) | (1L << (SCHEMA - 192)) | (1L << (SCHEMAS - 192)) | (1L << (SCROLL - 192)) | (1L << (SEARCH - 192)) | (1L << (SECOND - 192)) | (1L << (SECURITY - 192)) | (1L << (SEQUENCE - 192)) | (1L << (SEQUENCES - 192)) | (1L << (SERIALIZABLE - 192)) | (1L << (SERVER - 192)) | (1L << (SESSION - 192)) | (1L << (SET - 192)) | (1L << (SETS - 192)) | (1L << (SHARE - 192)) | (1L << (SHOW - 192)) | (1L << (SIMPLE - 192)) | (1L << (SKIP_ - 192)) | (1L << (SNAPSHOT - 192)) | (1L << (SQL - 192)) | (1L << (STABLE - 192)) | (1L << (STANDALONE - 192)) | (1L << (START - 192)) | (1L << (STATEMENT - 192)) | (1L << (STATISTICS - 192)) | (1L << (STDIN - 192)) | (1L << (STDOUT - 192)) | (1L << (STORAGE - 192)) | (1L << (STORED - 192)) | (1L << (STRICT - 192)) | (1L << (STRIP - 192)) | (1L << (SUBSCRIPTION - 192)) | (1L << (SUPPORT - 192)) | (1L << (SYSID - 192)) | (1L << (SYSTEM - 192)) | (1L << (TABLES - 192)) | (1L << (TABLESPACE - 192)) | (1L << (TEMP - 192)) | (1L << (TEMPLATE - 192)) | (1L << (TEMPORARY - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (TEXT - 256)) | (1L << (TIES - 256)) | (1L << (TRANSACTION - 256)) | (1L << (TRANSFORM - 256)) | (1L << (TRIGGER - 256)) | (1L << (TRUNCATE - 256)) | (1L << (TRUSTED - 256)) | (1L << (TYPE - 256)) | (1L << (TYPES - 256)) | (1L << (UNBOUNDED - 256)) | (1L << (UNCOMMITTED - 256)) | (1L << (UNENCRYPTED - 256)) | (1L << (UNKNOWN - 256)) | (1L << (UNLISTEN - 256)) | (1L << (UNLOGGED - 256)) | (1L << (UNTIL - 256)) | (1L << (UPDATE - 256)) | (1L << (VACUUM - 256)) | (1L << (VALID - 256)) | (1L << (VALIDATE - 256)) | (1L << (VALIDATOR - 256)) | (1L << (VALUE - 256)) | (1L << (VARYING - 256)) | (1L << (VERSION - 256)) | (1L << (VIEW - 256)) | (1L << (VIEWS - 256)) | (1L << (VOLATILE - 256)) | (1L << (WHITESPACE - 256)) | (1L << (WITHIN - 256)) | (1L << (WITHOUT - 256)) | (1L << (WORK - 256)) | (1L << (WRAPPER - 256)) | (1L << (WRITE - 256)) | (1L << (XML - 256)) | (1L << (YEAR - 256)) | (1L << (YES - 256)) | (1L << (ZONE - 256)) | (1L << (BETWEEN - 256)) | (1L << (BIGINT - 256)) | (1L << (BIT - 256)) | (1L << (BOOLEAN - 256)) | (1L << (CHAR - 256)) | (1L << (CHARACTER - 256)) | (1L << (COALESCE - 256)) | (1L << (DEC - 256)) | (1L << (DECIMAL - 256)) | (1L << (EXISTS - 256)) | (1L << (EXTRACT - 256)) | (1L << (FLOAT - 256)) | (1L << (GREATEST - 256)) | (1L << (GROUPING - 256)) | (1L << (INOUT - 256)) | (1L << (INT - 256)) | (1L << (INTEGER - 256)) | (1L << (INTERVAL - 256)) | (1L << (LEAST - 256)) | (1L << (NATIONAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NONE - 256)) | (1L << (NULLIF - 256)) | (1L << (NUMERIC - 256)) | (1L << (OUT - 256)) | (1L << (OVERLAY - 256)) | (1L << (POSITION - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (PRECISION - 320)) | (1L << (REAL - 320)) | (1L << (ROW - 320)) | (1L << (SETOF - 320)) | (1L << (SMALLINT - 320)) | (1L << (SUBSTRING - 320)) | (1L << (TIME - 320)) | (1L << (TIMESTAMP - 320)) | (1L << (TREAT - 320)) | (1L << (TRIM - 320)) | (1L << (VALUES - 320)) | (1L << (VARCHAR - 320)) | (1L << (XMLATTRIBUTES - 320)) | (1L << (XMLCONCAT - 320)) | (1L << (XMLELEMENT - 320)) | (1L << (XMLEXISTS - 320)) | (1L << (XMLFOREST - 320)) | (1L << (XMLNAMESPACES - 320)) | (1L << (XMLPARSE - 320)) | (1L << (XMLPI - 320)) | (1L << (XMLROOT - 320)) | (1L << (XMLSERIALIZE - 320)) | (1L << (XMLTABLE - 320)) | (1L << (AUTHORIZATION - 320)) | (1L << (BINARY - 320)) | (1L << (COLLATION - 320)) | (1L << (CONCURRENTLY - 320)) | (1L << (CROSS - 320)) | (1L << (CURRENT_SCHEMA - 320)) | (1L << (FREEZE - 320)) | (1L << (FULL - 320)) | (1L << (ILIKE - 320)) | (1L << (INNER - 320)) | (1L << (IS - 320)) | (1L << (ISNULL - 320)) | (1L << (JOIN - 320)) | (1L << (LEFT - 320)) | (1L << (LIKE - 320)) | (1L << (NATURAL - 320)) | (1L << (NOTNULL - 320)) | (1L << (OUTER - 320)) | (1L << (OVERLAPS - 320)) | (1L << (RIGHT - 320)) | (1L << (SIMILAR - 320)) | (1L << (TABLESAMPLE - 320)) | (1L << (VERBOSE - 320)) | (1L << (ALL - 320)) | (1L << (ANY - 320)) | (1L << (ARRAY - 320)) | (1L << (CASE - 320)) | (1L << (CAST - 320)) | (1L << (CURRENT_CATALOG - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (CURRENT_DATE - 384)) | (1L << (CURRENT_TIME - 384)) | (1L << (CURRENT_TIMESTAMP - 384)) | (1L << (CURRENT_USER - 384)) | (1L << (FALSE - 384)) | (1L << (LOCALTIME - 384)) | (1L << (LOCALTIMESTAMP - 384)) | (1L << (NOT - 384)) | (1L << (NULL - 384)) | (1L << (ON - 384)) | (1L << (SESSION_USER - 384)) | (1L << (SOME - 384)) | (1L << (TRUE - 384)) | (1L << (USER - 384)) | (1L << (ALIGNMENT - 384)) | (1L << (BASETYPE - 384)) | (1L << (BUFFERS - 384)) | (1L << (BYPASSRLS - 384)) | (1L << (CANONICAL - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (CATEGORY - 448)) | (1L << (COLLATABLE - 448)) | (1L << (COMBINEFUNC - 448)) | (1L << (COMMUTATOR - 448)) | (1L << (CONNECT - 448)) | (1L << (COSTS - 448)) | (1L << (CREATEDB - 448)) | (1L << (CREATEROLE - 448)) | (1L << (DESERIALFUNC - 448)) | (1L << (DETERMINISTIC - 448)) | (1L << (DISABLE_PAGE_SKIPPING - 448)) | (1L << (ELEMENT - 448)) | (1L << (EXTENDED - 448)) | (1L << (FINALFUNC - 448)) | (1L << (FINALFUNC_EXTRA - 448)) | (1L << (FINALFUNC_MODIFY - 448)) | (1L << (FORCE_NOT_NULL - 448)) | (1L << (FORCE_NULL - 448)) | (1L << (FORCE_QUOTE - 448)) | (1L << (FORMAT - 448)) | (1L << (GETTOKEN - 448)) | (1L << (HASH - 448)) | (1L << (HASHES - 448)) | (1L << (HEADLINE - 448)) | (1L << (HYPOTHETICAL - 448)) | (1L << (INDEX_CLEANUP - 448)) | (1L << (INIT - 448)) | (1L << (INITCOND - 448)) | (1L << (INTERNALLENGTH - 448)) | (1L << (JSON - 448)) | (1L << (LC_COLLATE - 448)) | (1L << (LC_CTYPE - 448)) | (1L << (LEFTARG - 448)) | (1L << (LEXIZE - 448)) | (1L << (LEXTYPES - 448)) | (1L << (LIST - 448)) | (1L << (LOCALE - 448)) | (1L << (LOGIN - 448)) | (1L << (MAIN - 448)) | (1L << (MERGES - 448)) | (1L << (MFINALFUNC - 448)) | (1L << (MFINALFUNC_EXTRA - 448)) | (1L << (MFINALFUNC_MODIFY - 448)) | (1L << (MINITCOND - 448)) | (1L << (MINVFUNC - 448)) | (1L << (MODULUS - 448)) | (1L << (MSFUNC - 448)) | (1L << (MSSPACE - 448)) | (1L << (MSTYPE - 448)) | (1L << (NEGATOR - 448)) | (1L << (NOBYPASSRLS - 448)) | (1L << (NOCREATEDB - 448)) | (1L << (NOCREATEROLE - 448)) | (1L << (NOINHERIT - 448)) | (1L << (NOLOGIN - 448)) | (1L << (NOREPLICATION - 448)) | (1L << (NOSUPERUSER - 448)) | (1L << (OUTPUT - 448)) | (1L << (PASSEDBYVALUE - 448)) | (1L << (PATH - 448)) | (1L << (PERMISSIVE - 448)) | (1L << (PLAIN - 448)) | (1L << (PREFERRED - 448)) | (1L << (PROVIDER - 448)))) != 0) || ((((_la - 512)) & ~0x3f) == 0 && ((1L << (_la - 512)) & ((1L << (READ_ONLY - 512)) | (1L << (READ_WRITE - 512)) | (1L << (RECEIVE - 512)) | (1L << (REMAINDER - 512)) | (1L << (REPLICATION - 512)) | (1L << (RESTRICTED - 512)) | (1L << (RESTRICTIVE - 512)) | (1L << (RIGHTARG - 512)) | (1L << (SAFE - 512)) | (1L << (SEND - 512)) | (1L << (SERIALFUNC - 512)) | (1L << (SETTINGS - 512)) | (1L << (SFUNC - 512)) | (1L << (SHAREABLE - 512)) | (1L << (SKIP_LOCKED - 512)) | (1L << (SORTOP - 512)) | (1L << (SSPACE - 512)) | (1L << (STYPE - 512)) | (1L << (SUBTYPE_DIFF - 512)) | (1L << (SUBTYPE_OPCLASS - 512)) | (1L << (SUBTYPE - 512)) | (1L << (SUMMARY - 512)) | (1L << (SUPERUSER - 512)) | (1L << (TIMING - 512)) | (1L << (TYPMOD_IN - 512)) | (1L << (TYPMOD_OUT - 512)) | (1L << (UNSAFE - 512)) | (1L << (USAGE - 512)) | (1L << (VARIABLE - 512)) | (1L << (YAML - 512)) | (1L << (ALIAS - 512)) | (1L << (ASSERT - 512)) | (1L << (CONSTANT - 512)) | (1L << (DATATYPE - 512)) | (1L << (DEBUG - 512)) | (1L << (DETAIL - 512)) | (1L << (DIAGNOSTICS - 512)) | (1L << (ELSEIF - 512)) | (1L << (ELSIF - 512)) | (1L << (ERRCODE - 512)) | (1L << (EXIT - 512)) | (1L << (EXCEPTION - 512)) | (1L << (FOREACH - 512)) | (1L << (GET - 512)) | (1L << (HINT - 512)) | (1L << (INFO - 512)) | (1L << (LOG - 512)) | (1L << (LOOP - 512)) | (1L << (MESSAGE - 512)) | (1L << (NOTICE - 512)) | (1L << (OPEN - 512)) | (1L << (PERFORM - 512)) | (1L << (QUERY - 512)) | (1L << (RAISE - 512)) | (1L << (RECORD - 512)) | (1L << (RETURN - 512)) | (1L << (REVERSE - 512)) | (1L << (ROWTYPE - 512)) | (1L << (SLICE - 512)) | (1L << (SQLSTATE - 512)) | (1L << (STACKED - 512)) | (1L << (WARNING - 512)) | (1L << (WHILE - 512)))) != 0) || ((((_la - 585)) & ~0x3f) == 0 && ((1L << (_la - 585)) & ((1L << (LEFT_PAREN - 585)) | (1L << (PLUS - 585)) | (1L << (MINUS - 585)) | (1L << (MULTIPLY - 585)) | (1L << (LESS_LESS - 585)) | (1L << (GREATER_GREATER - 585)) | (1L << (HASH_SIGN - 585)) | (1L << (OP_CHARS - 585)) | (1L << (NUMBER_LITERAL - 585)) | (1L << (REAL_NUMBER - 585)) | (1L << (DOLLAR_NUMBER - 585)) | (1L << (Identifier - 585)) | (1L << (QuotedIdentifier - 585)) | (1L << (Character_String_Literal - 585)) | (1L << (BeginDollarStringConstant - 585)))) != 0)) {
					{
					State = 1719; vex(0);
					}
				}

				State = 1722; Match(RIGHT_BRACKET);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Insert_stmt_for_psqlContext : ParserRuleContext {
		public Schema_qualified_nameContext insert_table_name;
		public IdentifierContext alias;
		public ITerminalNode INSERT() { return GetToken(PlPgSqlParser.INSERT, 0); }
		public ITerminalNode INTO() { return GetToken(PlPgSqlParser.INTO, 0); }
		public Schema_qualified_nameContext schema_qualified_name() {
			return GetRuleContext<Schema_qualified_nameContext>(0);
		}
		public Select_stmtContext select_stmt() {
			return GetRuleContext<Select_stmtContext>(0);
		}
		public ITerminalNode DEFAULT() { return GetToken(PlPgSqlParser.DEFAULT, 0); }
		public ITerminalNode VALUES() { return GetToken(PlPgSqlParser.VALUES, 0); }
		public With_clauseContext with_clause() {
			return GetRuleContext<With_clauseContext>(0);
		}
		public ITerminalNode AS() { return GetToken(PlPgSqlParser.AS, 0); }
		public ITerminalNode OVERRIDING() { return GetToken(PlPgSqlParser.OVERRIDING, 0); }
		public ITerminalNode VALUE() { return GetToken(PlPgSqlParser.VALUE, 0); }
		public Insert_columnsContext insert_columns() {
			return GetRuleContext<Insert_columnsContext>(0);
		}
		public ITerminalNode ON() { return GetToken(PlPgSqlParser.ON, 0); }
		public ITerminalNode CONFLICT() { return GetToken(PlPgSqlParser.CONFLICT, 0); }
		public Conflict_actionContext conflict_action() {
			return GetRuleContext<Conflict_actionContext>(0);
		}
		public ITerminalNode RETURNING() { return GetToken(PlPgSqlParser.RETURNING, 0); }
		public Select_listContext select_list() {
			return GetRuleContext<Select_listContext>(0);
		}
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ITerminalNode SYSTEM() { return GetToken(PlPgSqlParser.SYSTEM, 0); }
		public ITerminalNode USER() { return GetToken(PlPgSqlParser.USER, 0); }
		public Conflict_objectContext conflict_object() {
			return GetRuleContext<Conflict_objectContext>(0);
		}
		public Insert_stmt_for_psqlContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_insert_stmt_for_psql; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInsert_stmt_for_psql(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Insert_stmt_for_psqlContext insert_stmt_for_psql() {
		Insert_stmt_for_psqlContext _localctx = new Insert_stmt_for_psqlContext(Context, State);
		EnterRule(_localctx, 140, RULE_insert_stmt_for_psql);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1726;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WITH) {
				{
				State = 1725; with_clause();
				}
			}

			State = 1728; Match(INSERT);
			State = 1729; Match(INTO);
			State = 1730; _localctx.insert_table_name = schema_qualified_name();
			State = 1733;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AS) {
				{
				State = 1731; Match(AS);
				State = 1732; _localctx.alias = identifier();
				}
			}

			State = 1738;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OVERRIDING) {
				{
				State = 1735; Match(OVERRIDING);
				State = 1736;
				_la = TokenStream.LA(1);
				if ( !(_la==SYSTEM || _la==USER) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 1737; Match(VALUE);
				}
			}

			State = 1741;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,242,Context) ) {
			case 1:
				{
				State = 1740; insert_columns();
				}
				break;
			}
			State = 1746;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case VALUES:
			case SELECT:
			case TABLE:
			case WITH:
			case LEFT_PAREN:
				{
				State = 1743; select_stmt();
				}
				break;
			case DEFAULT:
				{
				State = 1744; Match(DEFAULT);
				State = 1745; Match(VALUES);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 1754;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ON) {
				{
				State = 1748; Match(ON);
				State = 1749; Match(CONFLICT);
				State = 1751;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ON || _la==LEFT_PAREN) {
					{
					State = 1750; conflict_object();
					}
				}

				State = 1753; conflict_action();
				}
			}

			State = 1758;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==RETURNING) {
				{
				State = 1756; Match(RETURNING);
				State = 1757; select_list();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Conflict_actionContext : ParserRuleContext {
		public ITerminalNode DO() { return GetToken(PlPgSqlParser.DO, 0); }
		public ITerminalNode NOTHING() { return GetToken(PlPgSqlParser.NOTHING, 0); }
		public ITerminalNode UPDATE() { return GetToken(PlPgSqlParser.UPDATE, 0); }
		public ITerminalNode SET() { return GetToken(PlPgSqlParser.SET, 0); }
		public Update_setContext[] update_set() {
			return GetRuleContexts<Update_setContext>();
		}
		public Update_setContext update_set(int i) {
			return GetRuleContext<Update_setContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlPgSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlPgSqlParser.COMMA, i);
		}
		public ITerminalNode WHERE() { return GetToken(PlPgSqlParser.WHERE, 0); }
		public VexContext vex() {
			return GetRuleContext<VexContext>(0);
		}
		public Conflict_actionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_conflict_action; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConflict_action(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Conflict_actionContext conflict_action() {
		Conflict_actionContext _localctx = new Conflict_actionContext(Context, State);
		EnterRule(_localctx, 142, RULE_conflict_action);
		int _la;
		try {
			State = 1777;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,249,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1760; Match(DO);
				State = 1761; Match(NOTHING);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1762; Match(DO);
				State = 1763; Match(UPDATE);
				State = 1764; Match(SET);
				State = 1765; update_set();
				State = 1770;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 1766; Match(COMMA);
					State = 1767; update_set();
					}
					}
					State = 1772;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 1775;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==WHERE) {
					{
					State = 1773; Match(WHERE);
					State = 1774; vex(0);
					}
				}

				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Conflict_objectContext : ParserRuleContext {
		public Index_sortContext index_sort() {
			return GetRuleContext<Index_sortContext>(0);
		}
		public Index_whereContext index_where() {
			return GetRuleContext<Index_whereContext>(0);
		}
		public ITerminalNode ON() { return GetToken(PlPgSqlParser.ON, 0); }
		public ITerminalNode CONSTRAINT() { return GetToken(PlPgSqlParser.CONSTRAINT, 0); }
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Conflict_objectContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_conflict_object; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConflict_object(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Conflict_objectContext conflict_object() {
		Conflict_objectContext _localctx = new Conflict_objectContext(Context, State);
		EnterRule(_localctx, 144, RULE_conflict_object);
		int _la;
		try {
			State = 1786;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LEFT_PAREN:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1779; index_sort();
				State = 1781;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==WHERE) {
					{
					State = 1780; index_where();
					}
				}

				}
				break;
			case ON:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1783; Match(ON);
				State = 1784; Match(CONSTRAINT);
				State = 1785; identifier();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Index_whereContext : ParserRuleContext {
		public ITerminalNode WHERE() { return GetToken(PlPgSqlParser.WHERE, 0); }
		public VexContext vex() {
			return GetRuleContext<VexContext>(0);
		}
		public Index_whereContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_index_where; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIndex_where(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Index_whereContext index_where() {
		Index_whereContext _localctx = new Index_whereContext(Context, State);
		EnterRule(_localctx, 146, RULE_index_where);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1788; Match(WHERE);
			State = 1789; vex(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Index_sortContext : ParserRuleContext {
		public ITerminalNode LEFT_PAREN() { return GetToken(PlPgSqlParser.LEFT_PAREN, 0); }
		public Sort_specifier_listContext sort_specifier_list() {
			return GetRuleContext<Sort_specifier_listContext>(0);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlPgSqlParser.RIGHT_PAREN, 0); }
		public Index_sortContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_index_sort; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIndex_sort(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Index_sortContext index_sort() {
		Index_sortContext _localctx = new Index_sortContext(Context, State);
		EnterRule(_localctx, 148, RULE_index_sort);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1791; Match(LEFT_PAREN);
			State = 1792; sort_specifier_list();
			State = 1793; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Insert_columnsContext : ParserRuleContext {
		public ITerminalNode LEFT_PAREN() { return GetToken(PlPgSqlParser.LEFT_PAREN, 0); }
		public Indirection_identifierContext[] indirection_identifier() {
			return GetRuleContexts<Indirection_identifierContext>();
		}
		public Indirection_identifierContext indirection_identifier(int i) {
			return GetRuleContext<Indirection_identifierContext>(i);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlPgSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(PlPgSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlPgSqlParser.COMMA, i);
		}
		public Insert_columnsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_insert_columns; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInsert_columns(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Insert_columnsContext insert_columns() {
		Insert_columnsContext _localctx = new Insert_columnsContext(Context, State);
		EnterRule(_localctx, 150, RULE_insert_columns);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1795; Match(LEFT_PAREN);
			State = 1796; indirection_identifier();
			State = 1801;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 1797; Match(COMMA);
				State = 1798; indirection_identifier();
				}
				}
				State = 1803;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 1804; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class After_opsContext : ParserRuleContext {
		public Orderby_clauseContext orderby_clause() {
			return GetRuleContext<Orderby_clauseContext>(0);
		}
		public ITerminalNode LIMIT() { return GetToken(PlPgSqlParser.LIMIT, 0); }
		public VexContext vex() {
			return GetRuleContext<VexContext>(0);
		}
		public ITerminalNode ALL() { return GetToken(PlPgSqlParser.ALL, 0); }
		public ITerminalNode OFFSET() { return GetToken(PlPgSqlParser.OFFSET, 0); }
		public ITerminalNode ROW() { return GetToken(PlPgSqlParser.ROW, 0); }
		public ITerminalNode ROWS() { return GetToken(PlPgSqlParser.ROWS, 0); }
		public ITerminalNode FETCH() { return GetToken(PlPgSqlParser.FETCH, 0); }
		public ITerminalNode FIRST() { return GetToken(PlPgSqlParser.FIRST, 0); }
		public ITerminalNode NEXT() { return GetToken(PlPgSqlParser.NEXT, 0); }
		public ITerminalNode ONLY() { return GetToken(PlPgSqlParser.ONLY, 0); }
		public ITerminalNode FOR() { return GetToken(PlPgSqlParser.FOR, 0); }
		public ITerminalNode UPDATE() { return GetToken(PlPgSqlParser.UPDATE, 0); }
		public ITerminalNode NO() { return GetToken(PlPgSqlParser.NO, 0); }
		public ITerminalNode KEY() { return GetToken(PlPgSqlParser.KEY, 0); }
		public ITerminalNode SHARE() { return GetToken(PlPgSqlParser.SHARE, 0); }
		public ITerminalNode OF() { return GetToken(PlPgSqlParser.OF, 0); }
		public Schema_qualified_nameContext[] schema_qualified_name() {
			return GetRuleContexts<Schema_qualified_nameContext>();
		}
		public Schema_qualified_nameContext schema_qualified_name(int i) {
			return GetRuleContext<Schema_qualified_nameContext>(i);
		}
		public ITerminalNode NOWAIT() { return GetToken(PlPgSqlParser.NOWAIT, 0); }
		public ITerminalNode SKIP_() { return GetToken(PlPgSqlParser.SKIP_, 0); }
		public ITerminalNode LOCKED() { return GetToken(PlPgSqlParser.LOCKED, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(PlPgSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlPgSqlParser.COMMA, i);
		}
		public After_opsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_after_ops; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAfter_ops(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public After_opsContext after_ops() {
		After_opsContext _localctx = new After_opsContext(Context, State);
		EnterRule(_localctx, 152, RULE_after_ops);
		int _la;
		try {
			State = 1852;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ORDER:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1806; orderby_clause();
				}
				break;
			case LIMIT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1807; Match(LIMIT);
				State = 1810;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,253,Context) ) {
				case 1:
					{
					State = 1808; vex(0);
					}
					break;
				case 2:
					{
					State = 1809; Match(ALL);
					}
					break;
				}
				}
				break;
			case OFFSET:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1812; Match(OFFSET);
				State = 1813; vex(0);
				State = 1815;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,254,Context) ) {
				case 1:
					{
					State = 1814;
					_la = TokenStream.LA(1);
					if ( !(_la==ROWS || _la==ROW) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
					break;
				}
				}
				break;
			case FETCH:
				EnterOuterAlt(_localctx, 4);
				{
				State = 1817; Match(FETCH);
				State = 1818;
				_la = TokenStream.LA(1);
				if ( !(_la==FIRST || _la==NEXT) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 1820;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,255,Context) ) {
				case 1:
					{
					State = 1819; vex(0);
					}
					break;
				}
				State = 1822;
				_la = TokenStream.LA(1);
				if ( !(_la==ROWS || _la==ROW) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 1824;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ONLY) {
					{
					State = 1823; Match(ONLY);
					}
				}

				}
				break;
			case FOR:
				EnterOuterAlt(_localctx, 5);
				{
				State = 1826; Match(FOR);
				State = 1834;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case UPDATE:
					{
					State = 1827; Match(UPDATE);
					}
					break;
				case NO:
					{
					State = 1828; Match(NO);
					State = 1829; Match(KEY);
					State = 1830; Match(UPDATE);
					}
					break;
				case SHARE:
					{
					State = 1831; Match(SHARE);
					}
					break;
				case KEY:
					{
					State = 1832; Match(KEY);
					State = 1833; Match(SHARE);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 1845;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,259,Context) ) {
				case 1:
					{
					State = 1836; Match(OF);
					State = 1837; schema_qualified_name();
					State = 1842;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					while (_la==COMMA) {
						{
						{
						State = 1838; Match(COMMA);
						State = 1839; schema_qualified_name();
						}
						}
						State = 1844;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					}
					}
					break;
				}
				State = 1850;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,260,Context) ) {
				case 1:
					{
					State = 1847; Match(NOWAIT);
					}
					break;
				case 2:
					{
					State = 1848; Match(SKIP_);
					State = 1849; Match(LOCKED);
					}
					break;
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Arguments_listContext : ParserRuleContext {
		public IdentifierContext[] identifier() {
			return GetRuleContexts<IdentifierContext>();
		}
		public IdentifierContext identifier(int i) {
			return GetRuleContext<IdentifierContext>(i);
		}
		public Data_typeContext[] data_type() {
			return GetRuleContexts<Data_typeContext>();
		}
		public Data_typeContext data_type(int i) {
			return GetRuleContext<Data_typeContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlPgSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlPgSqlParser.COMMA, i);
		}
		public Arguments_listContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_arguments_list; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArguments_list(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Arguments_listContext arguments_list() {
		Arguments_listContext _localctx = new Arguments_listContext(Context, State);
		EnterRule(_localctx, 154, RULE_arguments_list);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1854; identifier();
			State = 1855; data_type();
			State = 1862;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 1856; Match(COMMA);
				State = 1857; identifier();
				State = 1858; data_type();
				}
				}
				State = 1864;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Collate_identifierContext : ParserRuleContext {
		public Schema_qualified_nameContext collation;
		public ITerminalNode COLLATE() { return GetToken(PlPgSqlParser.COLLATE, 0); }
		public Schema_qualified_nameContext schema_qualified_name() {
			return GetRuleContext<Schema_qualified_nameContext>(0);
		}
		public Collate_identifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_collate_identifier; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCollate_identifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Collate_identifierContext collate_identifier() {
		Collate_identifierContext _localctx = new Collate_identifierContext(Context, State);
		EnterRule(_localctx, 156, RULE_collate_identifier);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1865; Match(COLLATE);
			State = 1866; _localctx.collation = schema_qualified_name();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Data_type_decContext : ParserRuleContext {
		public Data_typeContext data_type() {
			return GetRuleContext<Data_typeContext>(0);
		}
		public Schema_qualified_nameContext schema_qualified_name() {
			return GetRuleContext<Schema_qualified_nameContext>(0);
		}
		public ITerminalNode MODULAR() { return GetToken(PlPgSqlParser.MODULAR, 0); }
		public ITerminalNode TYPE() { return GetToken(PlPgSqlParser.TYPE, 0); }
		public Schema_qualified_name_nontypeContext schema_qualified_name_nontype() {
			return GetRuleContext<Schema_qualified_name_nontypeContext>(0);
		}
		public ITerminalNode ROWTYPE() { return GetToken(PlPgSqlParser.ROWTYPE, 0); }
		public Data_type_decContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_data_type_dec; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitData_type_dec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Data_type_decContext data_type_dec() {
		Data_type_decContext _localctx = new Data_type_decContext(Context, State);
		EnterRule(_localctx, 158, RULE_data_type_dec);
		try {
			State = 1877;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,263,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1868; data_type();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1869; schema_qualified_name();
				State = 1870; Match(MODULAR);
				State = 1871; Match(TYPE);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1873; schema_qualified_name_nontype();
				State = 1874; Match(MODULAR);
				State = 1875; Match(ROWTYPE);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Exception_statementContext : ParserRuleContext {
		public ITerminalNode EXCEPTION() { return GetToken(PlPgSqlParser.EXCEPTION, 0); }
		public ITerminalNode[] WHEN() { return GetTokens(PlPgSqlParser.WHEN); }
		public ITerminalNode WHEN(int i) {
			return GetToken(PlPgSqlParser.WHEN, i);
		}
		public VexContext[] vex() {
			return GetRuleContexts<VexContext>();
		}
		public VexContext vex(int i) {
			return GetRuleContext<VexContext>(i);
		}
		public ITerminalNode[] THEN() { return GetTokens(PlPgSqlParser.THEN); }
		public ITerminalNode THEN(int i) {
			return GetToken(PlPgSqlParser.THEN, i);
		}
		public Function_statementsContext[] function_statements() {
			return GetRuleContexts<Function_statementsContext>();
		}
		public Function_statementsContext function_statements(int i) {
			return GetRuleContext<Function_statementsContext>(i);
		}
		public Exception_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_exception_statement; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitException_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Exception_statementContext exception_statement() {
		Exception_statementContext _localctx = new Exception_statementContext(Context, State);
		EnterRule(_localctx, 160, RULE_exception_statement);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1879; Match(EXCEPTION);
			State = 1885;
			ErrorHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					{
					State = 1880; Match(WHEN);
					State = 1881; vex(0);
					State = 1882; Match(THEN);
					State = 1883; function_statements();
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 1887;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,264,Context);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Function_statementsContext : ParserRuleContext {
		public Function_statementContext[] function_statement() {
			return GetRuleContexts<Function_statementContext>();
		}
		public Function_statementContext function_statement(int i) {
			return GetRuleContext<Function_statementContext>(i);
		}
		public ITerminalNode[] SEMI_COLON() { return GetTokens(PlPgSqlParser.SEMI_COLON); }
		public ITerminalNode SEMI_COLON(int i) {
			return GetToken(PlPgSqlParser.SEMI_COLON, i);
		}
		public Function_statementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_function_statements; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunction_statements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Function_statementsContext function_statements() {
		Function_statementsContext _localctx = new Function_statementsContext(Context, State);
		EnterRule(_localctx, 162, RULE_function_statements);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1895;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,266,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 1889; function_statement();
					State = 1891;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,265,Context) ) {
					case 1:
						{
						State = 1890; Match(SEMI_COLON);
						}
						break;
					}
					}
					} 
				}
				State = 1897;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,266,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Function_statementContext : ParserRuleContext {
		public Function_blockContext function_block() {
			return GetRuleContext<Function_blockContext>(0);
		}
		public Base_statementContext base_statement() {
			return GetRuleContext<Base_statementContext>(0);
		}
		public Control_statementContext control_statement() {
			return GetRuleContext<Control_statementContext>(0);
		}
		public Transaction_statementContext transaction_statement() {
			return GetRuleContext<Transaction_statementContext>(0);
		}
		public Cursor_statementContext cursor_statement() {
			return GetRuleContext<Cursor_statementContext>(0);
		}
		public Message_statementContext message_statement() {
			return GetRuleContext<Message_statementContext>(0);
		}
		public Data_statementContext data_statement() {
			return GetRuleContext<Data_statementContext>(0);
		}
		public Additional_statementContext additional_statement() {
			return GetRuleContext<Additional_statementContext>(0);
		}
		public Function_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_function_statement; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunction_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Function_statementContext function_statement() {
		Function_statementContext _localctx = new Function_statementContext(Context, State);
		EnterRule(_localctx, 164, RULE_function_statement);
		try {
			State = 1906;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,267,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1898; function_block();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1899; base_statement();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1900; control_statement();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 1901; transaction_statement();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 1902; cursor_statement();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 1903; message_statement();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 1904; data_statement();
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 1905; additional_statement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Base_statementContext : ParserRuleContext {
		public Assign_stmtContext assign_stmt() {
			return GetRuleContext<Assign_stmtContext>(0);
		}
		public ITerminalNode EXECUTE() { return GetToken(PlPgSqlParser.EXECUTE, 0); }
		public VexContext vex() {
			return GetRuleContext<VexContext>(0);
		}
		public Using_vexContext using_vex() {
			return GetRuleContext<Using_vexContext>(0);
		}
		public ITerminalNode PERFORM() { return GetToken(PlPgSqlParser.PERFORM, 0); }
		public Perform_stmtContext perform_stmt() {
			return GetRuleContext<Perform_stmtContext>(0);
		}
		public ITerminalNode GET() { return GetToken(PlPgSqlParser.GET, 0); }
		public ITerminalNode DIAGNOSTICS() { return GetToken(PlPgSqlParser.DIAGNOSTICS, 0); }
		public Diagnostic_optionContext[] diagnostic_option() {
			return GetRuleContexts<Diagnostic_optionContext>();
		}
		public Diagnostic_optionContext diagnostic_option(int i) {
			return GetRuleContext<Diagnostic_optionContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlPgSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlPgSqlParser.COMMA, i);
		}
		public ITerminalNode CURRENT() { return GetToken(PlPgSqlParser.CURRENT, 0); }
		public ITerminalNode STACKED() { return GetToken(PlPgSqlParser.STACKED, 0); }
		public ITerminalNode NULL() { return GetToken(PlPgSqlParser.NULL, 0); }
		public Base_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_base_statement; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBase_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Base_statementContext base_statement() {
		Base_statementContext _localctx = new Base_statementContext(Context, State);
		EnterRule(_localctx, 166, RULE_base_statement);
		int _la;
		try {
			State = 1930;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,271,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1908; assign_stmt();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1909; Match(EXECUTE);
				State = 1910; vex(0);
				State = 1912;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==USING) {
					{
					State = 1911; using_vex();
					}
				}

				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1914; Match(PERFORM);
				State = 1915; perform_stmt();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 1916; Match(GET);
				State = 1918;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==CURRENT || _la==STACKED) {
					{
					State = 1917;
					_la = TokenStream.LA(1);
					if ( !(_la==CURRENT || _la==STACKED) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				State = 1920; Match(DIAGNOSTICS);
				State = 1921; diagnostic_option();
				State = 1926;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 1922; Match(COMMA);
					State = 1923; diagnostic_option();
					}
					}
					State = 1928;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 1929; Match(NULL);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Diagnostic_optionContext : ParserRuleContext {
		public VarContext var() {
			return GetRuleContext<VarContext>(0);
		}
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ITerminalNode COLON_EQUAL() { return GetToken(PlPgSqlParser.COLON_EQUAL, 0); }
		public ITerminalNode EQUAL() { return GetToken(PlPgSqlParser.EQUAL, 0); }
		public Diagnostic_optionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_diagnostic_option; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDiagnostic_option(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Diagnostic_optionContext diagnostic_option() {
		Diagnostic_optionContext _localctx = new Diagnostic_optionContext(Context, State);
		EnterRule(_localctx, 168, RULE_diagnostic_option);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1932; var();
			State = 1933;
			_la = TokenStream.LA(1);
			if ( !(_la==EQUAL || _la==COLON_EQUAL) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 1934; identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VarContext : ParserRuleContext {
		public Schema_qualified_nameContext schema_qualified_name() {
			return GetRuleContext<Schema_qualified_nameContext>(0);
		}
		public ITerminalNode DOLLAR_NUMBER() { return GetToken(PlPgSqlParser.DOLLAR_NUMBER, 0); }
		public ITerminalNode[] LEFT_BRACKET() { return GetTokens(PlPgSqlParser.LEFT_BRACKET); }
		public ITerminalNode LEFT_BRACKET(int i) {
			return GetToken(PlPgSqlParser.LEFT_BRACKET, i);
		}
		public VexContext[] vex() {
			return GetRuleContexts<VexContext>();
		}
		public VexContext vex(int i) {
			return GetRuleContext<VexContext>(i);
		}
		public ITerminalNode[] RIGHT_BRACKET() { return GetTokens(PlPgSqlParser.RIGHT_BRACKET); }
		public ITerminalNode RIGHT_BRACKET(int i) {
			return GetToken(PlPgSqlParser.RIGHT_BRACKET, i);
		}
		public VarContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_var; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVar(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public VarContext var() {
		VarContext _localctx = new VarContext(Context, State);
		EnterRule(_localctx, 170, RULE_var);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1938;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ABORT:
			case ABSOLUTE:
			case ACCESS:
			case ACTION:
			case ADD:
			case ADMIN:
			case AFTER:
			case AGGREGATE:
			case ALSO:
			case ALTER:
			case ALWAYS:
			case ASSERTION:
			case ASSIGNMENT:
			case AT:
			case ATTACH:
			case ATTRIBUTE:
			case BACKWARD:
			case BEFORE:
			case BEGIN:
			case BY:
			case CACHE:
			case CALL:
			case CALLED:
			case CASCADE:
			case CASCADED:
			case CATALOG:
			case CHAIN:
			case CHARACTERISTICS:
			case CHECKPOINT:
			case CLASS:
			case CLOSE:
			case CLUSTER:
			case COLUMNS:
			case COMMENT:
			case COMMENTS:
			case COMMIT:
			case COMMITTED:
			case CONFIGURATION:
			case CONFLICT:
			case CONNECTION:
			case CONSTRAINTS:
			case CONTENT:
			case CONTINUE:
			case CONVERSION:
			case COPY:
			case COST:
			case CSV:
			case CUBE:
			case CURRENT:
			case CURSOR:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DAY:
			case DEALLOCATE:
			case DECLARE:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DELIMITER:
			case DELIMITERS:
			case DEPENDS:
			case DETACH:
			case DICTIONARY:
			case DISABLE:
			case DISCARD:
			case DOCUMENT:
			case DOMAIN:
			case DOUBLE:
			case DROP:
			case EACH:
			case ENABLE:
			case ENCODING:
			case ENCRYPTED:
			case ENUM:
			case ESCAPE:
			case EVENT:
			case EXCLUDE:
			case EXCLUDING:
			case EXCLUSIVE:
			case EXECUTE:
			case EXPLAIN:
			case EXTENSION:
			case EXTERNAL:
			case FAMILY:
			case FILTER:
			case FIRST:
			case FOLLOWING:
			case FORCE:
			case FORWARD:
			case FUNCTION:
			case FUNCTIONS:
			case GENERATED:
			case GLOBAL:
			case GRANTED:
			case GROUPS:
			case HANDLER:
			case HEADER:
			case HOLD:
			case HOUR:
			case IDENTITY:
			case IF:
			case IMMEDIATE:
			case IMMUTABLE:
			case IMPLICIT:
			case IMPORT:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDEX:
			case INDEXES:
			case INHERIT:
			case INHERITS:
			case INLINE:
			case INPUT:
			case INSENSITIVE:
			case INSERT:
			case INSTEAD:
			case INVOKER:
			case ISOLATION:
			case KEY:
			case LABEL:
			case LANGUAGE:
			case LARGE:
			case LAST:
			case LEAKPROOF:
			case LEVEL:
			case LISTEN:
			case LOAD:
			case LOCAL:
			case LOCATION:
			case LOCK:
			case LOCKED:
			case LOGGED:
			case MAPPING:
			case MATCH:
			case MATERIALIZED:
			case MAXVALUE:
			case METHOD:
			case MINUTE:
			case MINVALUE:
			case MODE:
			case MONTH:
			case MOVE:
			case NAME:
			case NAMES:
			case NEW:
			case NEXT:
			case NO:
			case NOTHING:
			case NOTIFY:
			case NOWAIT:
			case NULLS:
			case OBJECT:
			case OF:
			case OFF:
			case OIDS:
			case OLD:
			case OPERATOR:
			case OPTION:
			case OPTIONS:
			case ORDINALITY:
			case OTHERS:
			case OVER:
			case OVERRIDING:
			case OWNED:
			case OWNER:
			case PARALLEL:
			case PARSER:
			case PARTIAL:
			case PARTITION:
			case PASSING:
			case PASSWORD:
			case PLANS:
			case POLICY:
			case PRECEDING:
			case PREPARE:
			case PREPARED:
			case PRESERVE:
			case PRIOR:
			case PRIVILEGES:
			case PROCEDURAL:
			case PROCEDURE:
			case PROCEDURES:
			case PROGRAM:
			case PUBLICATION:
			case QUOTE:
			case RANGE:
			case READ:
			case REASSIGN:
			case RECHECK:
			case RECURSIVE:
			case REF:
			case REFERENCING:
			case REFRESH:
			case REINDEX:
			case RELATIVE:
			case RELEASE:
			case RENAME:
			case REPEATABLE:
			case REPLACE:
			case REPLICA:
			case RESET:
			case RESTART:
			case RESTRICT:
			case RETURNS:
			case REVOKE:
			case ROLE:
			case ROLLBACK:
			case ROLLUP:
			case ROUTINE:
			case ROUTINES:
			case ROWS:
			case RULE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMAS:
			case SCROLL:
			case SEARCH:
			case SECOND:
			case SECURITY:
			case SEQUENCE:
			case SEQUENCES:
			case SERIALIZABLE:
			case SERVER:
			case SESSION:
			case SET:
			case SETS:
			case SHARE:
			case SHOW:
			case SIMPLE:
			case SKIP_:
			case SNAPSHOT:
			case SQL:
			case STABLE:
			case STANDALONE:
			case START:
			case STATEMENT:
			case STATISTICS:
			case STDIN:
			case STDOUT:
			case STORAGE:
			case STORED:
			case STRICT:
			case STRIP:
			case SUBSCRIPTION:
			case SUPPORT:
			case SYSID:
			case SYSTEM:
			case TABLES:
			case TABLESPACE:
			case TEMP:
			case TEMPLATE:
			case TEMPORARY:
			case TEXT:
			case TIES:
			case TRANSACTION:
			case TRANSFORM:
			case TRIGGER:
			case TRUNCATE:
			case TRUSTED:
			case TYPE:
			case TYPES:
			case UNBOUNDED:
			case UNCOMMITTED:
			case UNENCRYPTED:
			case UNKNOWN:
			case UNLISTEN:
			case UNLOGGED:
			case UNTIL:
			case UPDATE:
			case VACUUM:
			case VALID:
			case VALIDATE:
			case VALIDATOR:
			case VALUE:
			case VARYING:
			case VERSION:
			case VIEW:
			case VIEWS:
			case VOLATILE:
			case WHITESPACE:
			case WITHIN:
			case WITHOUT:
			case WORK:
			case WRAPPER:
			case WRITE:
			case XML:
			case YEAR:
			case YES:
			case ZONE:
			case BETWEEN:
			case BIGINT:
			case BIT:
			case BOOLEAN:
			case CHAR:
			case CHARACTER:
			case COALESCE:
			case DEC:
			case DECIMAL:
			case EXISTS:
			case EXTRACT:
			case FLOAT:
			case GREATEST:
			case GROUPING:
			case INOUT:
			case INT:
			case INTEGER:
			case INTERVAL:
			case LEAST:
			case NATIONAL:
			case NCHAR:
			case NONE:
			case NULLIF:
			case NUMERIC:
			case OUT:
			case OVERLAY:
			case POSITION:
			case PRECISION:
			case REAL:
			case ROW:
			case SETOF:
			case SMALLINT:
			case SUBSTRING:
			case TIME:
			case TIMESTAMP:
			case TREAT:
			case TRIM:
			case VALUES:
			case VARCHAR:
			case XMLATTRIBUTES:
			case XMLCONCAT:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case ALIGNMENT:
			case BASETYPE:
			case BUFFERS:
			case BYPASSRLS:
			case CANONICAL:
			case CATEGORY:
			case COLLATABLE:
			case COMBINEFUNC:
			case COMMUTATOR:
			case CONNECT:
			case COSTS:
			case CREATEDB:
			case CREATEROLE:
			case DESERIALFUNC:
			case DETERMINISTIC:
			case DISABLE_PAGE_SKIPPING:
			case ELEMENT:
			case EXTENDED:
			case FINALFUNC:
			case FINALFUNC_EXTRA:
			case FINALFUNC_MODIFY:
			case FORCE_NOT_NULL:
			case FORCE_NULL:
			case FORCE_QUOTE:
			case FORMAT:
			case GETTOKEN:
			case HASH:
			case HASHES:
			case HEADLINE:
			case HYPOTHETICAL:
			case INDEX_CLEANUP:
			case INIT:
			case INITCOND:
			case INTERNALLENGTH:
			case JSON:
			case LC_COLLATE:
			case LC_CTYPE:
			case LEFTARG:
			case LEXIZE:
			case LEXTYPES:
			case LIST:
			case LOCALE:
			case LOGIN:
			case MAIN:
			case MERGES:
			case MFINALFUNC:
			case MFINALFUNC_EXTRA:
			case MFINALFUNC_MODIFY:
			case MINITCOND:
			case MINVFUNC:
			case MODULUS:
			case MSFUNC:
			case MSSPACE:
			case MSTYPE:
			case NEGATOR:
			case NOBYPASSRLS:
			case NOCREATEDB:
			case NOCREATEROLE:
			case NOINHERIT:
			case NOLOGIN:
			case NOREPLICATION:
			case NOSUPERUSER:
			case OUTPUT:
			case PASSEDBYVALUE:
			case PATH:
			case PERMISSIVE:
			case PLAIN:
			case PREFERRED:
			case PROVIDER:
			case READ_ONLY:
			case READ_WRITE:
			case RECEIVE:
			case REMAINDER:
			case REPLICATION:
			case RESTRICTED:
			case RESTRICTIVE:
			case RIGHTARG:
			case SAFE:
			case SEND:
			case SERIALFUNC:
			case SETTINGS:
			case SFUNC:
			case SHAREABLE:
			case SKIP_LOCKED:
			case SORTOP:
			case SSPACE:
			case STYPE:
			case SUBTYPE_DIFF:
			case SUBTYPE_OPCLASS:
			case SUBTYPE:
			case SUMMARY:
			case SUPERUSER:
			case TIMING:
			case TYPMOD_IN:
			case TYPMOD_OUT:
			case UNSAFE:
			case USAGE:
			case VARIABLE:
			case YAML:
			case ALIAS:
			case ASSERT:
			case CONSTANT:
			case DATATYPE:
			case DEBUG:
			case DETAIL:
			case DIAGNOSTICS:
			case ELSEIF:
			case ELSIF:
			case ERRCODE:
			case EXIT:
			case EXCEPTION:
			case FOREACH:
			case GET:
			case HINT:
			case INFO:
			case LOG:
			case LOOP:
			case MESSAGE:
			case NOTICE:
			case OPEN:
			case PERFORM:
			case QUERY:
			case RAISE:
			case RECORD:
			case RETURN:
			case REVERSE:
			case ROWTYPE:
			case SLICE:
			case SQLSTATE:
			case STACKED:
			case WARNING:
			case WHILE:
			case Identifier:
			case QuotedIdentifier:
				{
				State = 1936; schema_qualified_name();
				}
				break;
			case DOLLAR_NUMBER:
				{
				State = 1937; Match(DOLLAR_NUMBER);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 1946;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==LEFT_BRACKET) {
				{
				{
				State = 1940; Match(LEFT_BRACKET);
				State = 1941; vex(0);
				State = 1942; Match(RIGHT_BRACKET);
				}
				}
				State = 1948;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Perform_stmtContext : ParserRuleContext {
		public Select_listContext select_list() {
			return GetRuleContext<Select_listContext>(0);
		}
		public Set_qualifierContext[] set_qualifier() {
			return GetRuleContexts<Set_qualifierContext>();
		}
		public Set_qualifierContext set_qualifier(int i) {
			return GetRuleContext<Set_qualifierContext>(i);
		}
		public ITerminalNode FROM() { return GetToken(PlPgSqlParser.FROM, 0); }
		public From_itemContext[] from_item() {
			return GetRuleContexts<From_itemContext>();
		}
		public From_itemContext from_item(int i) {
			return GetRuleContext<From_itemContext>(i);
		}
		public ITerminalNode WHERE() { return GetToken(PlPgSqlParser.WHERE, 0); }
		public VexContext[] vex() {
			return GetRuleContexts<VexContext>();
		}
		public VexContext vex(int i) {
			return GetRuleContext<VexContext>(i);
		}
		public Groupby_clauseContext groupby_clause() {
			return GetRuleContext<Groupby_clauseContext>(0);
		}
		public ITerminalNode HAVING() { return GetToken(PlPgSqlParser.HAVING, 0); }
		public ITerminalNode WINDOW() { return GetToken(PlPgSqlParser.WINDOW, 0); }
		public IdentifierContext[] identifier() {
			return GetRuleContexts<IdentifierContext>();
		}
		public IdentifierContext identifier(int i) {
			return GetRuleContext<IdentifierContext>(i);
		}
		public ITerminalNode[] AS() { return GetTokens(PlPgSqlParser.AS); }
		public ITerminalNode AS(int i) {
			return GetToken(PlPgSqlParser.AS, i);
		}
		public Window_definitionContext[] window_definition() {
			return GetRuleContexts<Window_definitionContext>();
		}
		public Window_definitionContext window_definition(int i) {
			return GetRuleContext<Window_definitionContext>(i);
		}
		public Select_opsContext select_ops() {
			return GetRuleContext<Select_opsContext>(0);
		}
		public After_opsContext[] after_ops() {
			return GetRuleContexts<After_opsContext>();
		}
		public After_opsContext after_ops(int i) {
			return GetRuleContext<After_opsContext>(i);
		}
		public ITerminalNode INTERSECT() { return GetToken(PlPgSqlParser.INTERSECT, 0); }
		public ITerminalNode UNION() { return GetToken(PlPgSqlParser.UNION, 0); }
		public ITerminalNode EXCEPT() { return GetToken(PlPgSqlParser.EXCEPT, 0); }
		public ITerminalNode ON() { return GetToken(PlPgSqlParser.ON, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlPgSqlParser.LEFT_PAREN, 0); }
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlPgSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(PlPgSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlPgSqlParser.COMMA, i);
		}
		public Perform_stmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_perform_stmt; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPerform_stmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Perform_stmtContext perform_stmt() {
		Perform_stmtContext _localctx = new Perform_stmtContext(Context, State);
		EnterRule(_localctx, 172, RULE_perform_stmt);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1964;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,276,Context) ) {
			case 1:
				{
				State = 1949; set_qualifier();
				State = 1962;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,275,Context) ) {
				case 1:
					{
					State = 1950; Match(ON);
					State = 1951; Match(LEFT_PAREN);
					State = 1952; vex(0);
					State = 1957;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					while (_la==COMMA) {
						{
						{
						State = 1953; Match(COMMA);
						State = 1954; vex(0);
						}
						}
						State = 1959;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					}
					State = 1960; Match(RIGHT_PAREN);
					}
					break;
				}
				}
				break;
			}
			State = 1966; select_list();
			State = 1976;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FROM) {
				{
				State = 1967; Match(FROM);
				State = 1968; from_item(0);
				State = 1973;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 1969; Match(COMMA);
					State = 1970; from_item(0);
					}
					}
					State = 1975;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
			}

			State = 1980;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE) {
				{
				State = 1978; Match(WHERE);
				State = 1979; vex(0);
				}
			}

			State = 1983;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==GROUP) {
				{
				State = 1982; groupby_clause();
				}
			}

			State = 1987;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==HAVING) {
				{
				State = 1985; Match(HAVING);
				State = 1986; vex(0);
				}
			}

			State = 2003;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WINDOW) {
				{
				State = 1989; Match(WINDOW);
				State = 1990; identifier();
				State = 1991; Match(AS);
				State = 1992; window_definition();
				State = 2000;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 1993; Match(COMMA);
					State = 1994; identifier();
					State = 1995; Match(AS);
					State = 1996; window_definition();
					}
					}
					State = 2002;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
			}

			State = 2010;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (((((_la - 396)) & ~0x3f) == 0 && ((1L << (_la - 396)) & ((1L << (EXCEPT - 396)) | (1L << (INTERSECT - 396)) | (1L << (UNION - 396)))) != 0)) {
				{
				State = 2005;
				_la = TokenStream.LA(1);
				if ( !(((((_la - 396)) & ~0x3f) == 0 && ((1L << (_la - 396)) & ((1L << (EXCEPT - 396)) | (1L << (INTERSECT - 396)) | (1L << (UNION - 396)))) != 0)) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 2007;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ALL || _la==DISTINCT) {
					{
					State = 2006; set_qualifier();
					}
				}

				State = 2009; select_ops(0);
				}
			}

			State = 2015;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,286,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 2012; after_ops();
					}
					} 
				}
				State = 2017;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,286,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Control_statementContext : ParserRuleContext {
		public Return_stmtContext return_stmt() {
			return GetRuleContext<Return_stmtContext>(0);
		}
		public ITerminalNode CALL() { return GetToken(PlPgSqlParser.CALL, 0); }
		public Function_callContext function_call() {
			return GetRuleContext<Function_callContext>(0);
		}
		public If_statementContext if_statement() {
			return GetRuleContext<If_statementContext>(0);
		}
		public Case_statementContext case_statement() {
			return GetRuleContext<Case_statementContext>(0);
		}
		public Loop_statementContext loop_statement() {
			return GetRuleContext<Loop_statementContext>(0);
		}
		public Control_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_control_statement; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitControl_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Control_statementContext control_statement() {
		Control_statementContext _localctx = new Control_statementContext(Context, State);
		EnterRule(_localctx, 174, RULE_control_statement);
		try {
			State = 2024;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case RETURN:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2018; return_stmt();
				}
				break;
			case CALL:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2019; Match(CALL);
				State = 2020; function_call();
				}
				break;
			case IF:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2021; if_statement();
				}
				break;
			case CASE:
				EnterOuterAlt(_localctx, 4);
				{
				State = 2022; case_statement();
				}
				break;
			case CONTINUE:
			case FOR:
			case EXIT:
			case FOREACH:
			case LOOP:
			case WHILE:
			case LESS_LESS:
				EnterOuterAlt(_localctx, 5);
				{
				State = 2023; loop_statement();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Return_stmtContext : ParserRuleContext {
		public ITerminalNode RETURN() { return GetToken(PlPgSqlParser.RETURN, 0); }
		public ITerminalNode QUERY() { return GetToken(PlPgSqlParser.QUERY, 0); }
		public Select_stmtContext select_stmt() {
			return GetRuleContext<Select_stmtContext>(0);
		}
		public Execute_stmtContext execute_stmt() {
			return GetRuleContext<Execute_stmtContext>(0);
		}
		public Show_statementContext show_statement() {
			return GetRuleContext<Show_statementContext>(0);
		}
		public Explain_statementContext explain_statement() {
			return GetRuleContext<Explain_statementContext>(0);
		}
		public ITerminalNode NEXT() { return GetToken(PlPgSqlParser.NEXT, 0); }
		public VexContext vex() {
			return GetRuleContext<VexContext>(0);
		}
		public Perform_stmtContext perform_stmt() {
			return GetRuleContext<Perform_stmtContext>(0);
		}
		public Return_stmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_return_stmt; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReturn_stmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Return_stmtContext return_stmt() {
		Return_stmtContext _localctx = new Return_stmtContext(Context, State);
		EnterRule(_localctx, 176, RULE_return_stmt);
		try {
			State = 2041;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,290,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2026; Match(RETURN);
				State = 2027; Match(QUERY);
				State = 2032;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case VALUES:
				case SELECT:
				case TABLE:
				case WITH:
				case LEFT_PAREN:
					{
					State = 2028; select_stmt();
					}
					break;
				case EXECUTE:
					{
					State = 2029; execute_stmt();
					}
					break;
				case SHOW:
					{
					State = 2030; show_statement();
					}
					break;
				case EXPLAIN:
					{
					State = 2031; explain_statement();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2034; Match(RETURN);
				State = 2035; Match(NEXT);
				State = 2036; vex(0);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2037; Match(RETURN);
				State = 2039;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,289,Context) ) {
				case 1:
					{
					State = 2038; perform_stmt();
					}
					break;
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Explain_statementContext : ParserRuleContext {
		public ITerminalNode EXPLAIN() { return GetToken(PlPgSqlParser.EXPLAIN, 0); }
		public Explain_queryContext explain_query() {
			return GetRuleContext<Explain_queryContext>(0);
		}
		public ITerminalNode LEFT_PAREN() { return GetToken(PlPgSqlParser.LEFT_PAREN, 0); }
		public Explain_optionContext[] explain_option() {
			return GetRuleContexts<Explain_optionContext>();
		}
		public Explain_optionContext explain_option(int i) {
			return GetRuleContext<Explain_optionContext>(i);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlPgSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode ANALYZE() { return GetToken(PlPgSqlParser.ANALYZE, 0); }
		public ITerminalNode VERBOSE() { return GetToken(PlPgSqlParser.VERBOSE, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(PlPgSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlPgSqlParser.COMMA, i);
		}
		public Explain_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_explain_statement; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExplain_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Explain_statementContext explain_statement() {
		Explain_statementContext _localctx = new Explain_statementContext(Context, State);
		EnterRule(_localctx, 178, RULE_explain_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2043; Match(EXPLAIN);
			State = 2061;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,294,Context) ) {
			case 1:
				{
				State = 2045;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ANALYZE) {
					{
					State = 2044; Match(ANALYZE);
					}
				}

				State = 2048;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==VERBOSE) {
					{
					State = 2047; Match(VERBOSE);
					}
				}

				}
				break;
			case 2:
				{
				State = 2050; Match(LEFT_PAREN);
				State = 2051; explain_option();
				State = 2056;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 2052; Match(COMMA);
					State = 2053; explain_option();
					}
					}
					State = 2058;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 2059; Match(RIGHT_PAREN);
				}
				break;
			}
			State = 2063; explain_query();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Explain_queryContext : ParserRuleContext {
		public Data_statementContext data_statement() {
			return GetRuleContext<Data_statementContext>(0);
		}
		public Values_stmtContext values_stmt() {
			return GetRuleContext<Values_stmtContext>(0);
		}
		public Execute_statementContext execute_statement() {
			return GetRuleContext<Execute_statementContext>(0);
		}
		public Declare_statementContext declare_statement() {
			return GetRuleContext<Declare_statementContext>(0);
		}
		public ITerminalNode CREATE() { return GetToken(PlPgSqlParser.CREATE, 0); }
		public Create_table_as_statementContext create_table_as_statement() {
			return GetRuleContext<Create_table_as_statementContext>(0);
		}
		public Create_view_statementContext create_view_statement() {
			return GetRuleContext<Create_view_statementContext>(0);
		}
		public Explain_queryContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_explain_query; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExplain_query(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Explain_queryContext explain_query() {
		Explain_queryContext _localctx = new Explain_queryContext(Context, State);
		EnterRule(_localctx, 180, RULE_explain_query);
		try {
			State = 2074;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,296,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2065; data_statement();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2066; values_stmt();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2067; execute_statement();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 2068; declare_statement();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 2069; Match(CREATE);
				State = 2072;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,295,Context) ) {
				case 1:
					{
					State = 2070; create_table_as_statement();
					}
					break;
				case 2:
					{
					State = 2071; create_view_statement();
					}
					break;
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Create_table_as_statementContext : ParserRuleContext {
		public Schema_qualified_nameContext name;
		public ITerminalNode TABLE() { return GetToken(PlPgSqlParser.TABLE, 0); }
		public ITerminalNode AS() { return GetToken(PlPgSqlParser.AS, 0); }
		public Schema_qualified_nameContext schema_qualified_name() {
			return GetRuleContext<Schema_qualified_nameContext>(0);
		}
		public Select_stmtContext select_stmt() {
			return GetRuleContext<Select_stmtContext>(0);
		}
		public ITerminalNode EXECUTE() { return GetToken(PlPgSqlParser.EXECUTE, 0); }
		public Function_callContext function_call() {
			return GetRuleContext<Function_callContext>(0);
		}
		public ITerminalNode UNLOGGED() { return GetToken(PlPgSqlParser.UNLOGGED, 0); }
		public If_not_existsContext if_not_exists() {
			return GetRuleContext<If_not_existsContext>(0);
		}
		public Names_in_parensContext names_in_parens() {
			return GetRuleContext<Names_in_parensContext>(0);
		}
		public ITerminalNode USING() { return GetToken(PlPgSqlParser.USING, 0); }
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Storage_parameter_oidContext storage_parameter_oid() {
			return GetRuleContext<Storage_parameter_oidContext>(0);
		}
		public On_commitContext on_commit() {
			return GetRuleContext<On_commitContext>(0);
		}
		public Table_spaceContext table_space() {
			return GetRuleContext<Table_spaceContext>(0);
		}
		public ITerminalNode WITH() { return GetToken(PlPgSqlParser.WITH, 0); }
		public ITerminalNode DATA() { return GetToken(PlPgSqlParser.DATA, 0); }
		public ITerminalNode TEMPORARY() { return GetToken(PlPgSqlParser.TEMPORARY, 0); }
		public ITerminalNode TEMP() { return GetToken(PlPgSqlParser.TEMP, 0); }
		public ITerminalNode NO() { return GetToken(PlPgSqlParser.NO, 0); }
		public ITerminalNode GLOBAL() { return GetToken(PlPgSqlParser.GLOBAL, 0); }
		public ITerminalNode LOCAL() { return GetToken(PlPgSqlParser.LOCAL, 0); }
		public Create_table_as_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_create_table_as_statement; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreate_table_as_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Create_table_as_statementContext create_table_as_statement() {
		Create_table_as_statementContext _localctx = new Create_table_as_statementContext(Context, State);
		EnterRule(_localctx, 182, RULE_create_table_as_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2081;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case GLOBAL:
			case LOCAL:
			case TEMP:
			case TEMPORARY:
				{
				State = 2077;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==GLOBAL || _la==LOCAL) {
					{
					State = 2076;
					_la = TokenStream.LA(1);
					if ( !(_la==GLOBAL || _la==LOCAL) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				State = 2079;
				_la = TokenStream.LA(1);
				if ( !(_la==TEMP || _la==TEMPORARY) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case UNLOGGED:
				{
				State = 2080; Match(UNLOGGED);
				}
				break;
			case TABLE:
				break;
			default:
				break;
			}
			State = 2083; Match(TABLE);
			State = 2085;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,299,Context) ) {
			case 1:
				{
				State = 2084; if_not_exists();
				}
				break;
			}
			State = 2087; _localctx.name = schema_qualified_name();
			State = 2089;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LEFT_PAREN) {
				{
				State = 2088; names_in_parens();
				}
			}

			State = 2093;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==USING) {
				{
				State = 2091; Match(USING);
				State = 2092; identifier();
				}
			}

			State = 2096;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WITHOUT || _la==WITH) {
				{
				State = 2095; storage_parameter_oid();
				}
			}

			State = 2099;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ON) {
				{
				State = 2098; on_commit();
				}
			}

			State = 2102;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==TABLESPACE) {
				{
				State = 2101; table_space();
				}
			}

			State = 2104; Match(AS);
			State = 2108;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case VALUES:
			case SELECT:
			case TABLE:
			case WITH:
			case LEFT_PAREN:
				{
				State = 2105; select_stmt();
				}
				break;
			case EXECUTE:
				{
				State = 2106; Match(EXECUTE);
				State = 2107; function_call();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2115;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,307,Context) ) {
			case 1:
				{
				State = 2110; Match(WITH);
				State = 2112;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==NO) {
					{
					State = 2111; Match(NO);
					}
				}

				State = 2114; Match(DATA);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Storage_parameter_oidContext : ParserRuleContext {
		public With_storage_parameterContext with_storage_parameter() {
			return GetRuleContext<With_storage_parameterContext>(0);
		}
		public ITerminalNode WITH() { return GetToken(PlPgSqlParser.WITH, 0); }
		public ITerminalNode OIDS() { return GetToken(PlPgSqlParser.OIDS, 0); }
		public ITerminalNode WITHOUT() { return GetToken(PlPgSqlParser.WITHOUT, 0); }
		public Storage_parameter_oidContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_storage_parameter_oid; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStorage_parameter_oid(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Storage_parameter_oidContext storage_parameter_oid() {
		Storage_parameter_oidContext _localctx = new Storage_parameter_oidContext(Context, State);
		EnterRule(_localctx, 184, RULE_storage_parameter_oid);
		try {
			State = 2122;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,308,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2117; with_storage_parameter();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				{
				State = 2118; Match(WITH);
				State = 2119; Match(OIDS);
				}
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				{
				State = 2120; Match(WITHOUT);
				State = 2121; Match(OIDS);
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class With_storage_parameterContext : ParserRuleContext {
		public ITerminalNode WITH() { return GetToken(PlPgSqlParser.WITH, 0); }
		public Storage_parameterContext storage_parameter() {
			return GetRuleContext<Storage_parameterContext>(0);
		}
		public With_storage_parameterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_with_storage_parameter; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWith_storage_parameter(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public With_storage_parameterContext with_storage_parameter() {
		With_storage_parameterContext _localctx = new With_storage_parameterContext(Context, State);
		EnterRule(_localctx, 186, RULE_with_storage_parameter);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2124; Match(WITH);
			State = 2125; storage_parameter();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Storage_parameterContext : ParserRuleContext {
		public ITerminalNode LEFT_PAREN() { return GetToken(PlPgSqlParser.LEFT_PAREN, 0); }
		public Storage_parameter_optionContext[] storage_parameter_option() {
			return GetRuleContexts<Storage_parameter_optionContext>();
		}
		public Storage_parameter_optionContext storage_parameter_option(int i) {
			return GetRuleContext<Storage_parameter_optionContext>(i);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlPgSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(PlPgSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlPgSqlParser.COMMA, i);
		}
		public Storage_parameterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_storage_parameter; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStorage_parameter(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Storage_parameterContext storage_parameter() {
		Storage_parameterContext _localctx = new Storage_parameterContext(Context, State);
		EnterRule(_localctx, 188, RULE_storage_parameter);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2127; Match(LEFT_PAREN);
			State = 2128; storage_parameter_option();
			State = 2133;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 2129; Match(COMMA);
				State = 2130; storage_parameter_option();
				}
				}
				State = 2135;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 2136; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Storage_parameter_optionContext : ParserRuleContext {
		public Schema_qualified_nameContext schema_qualified_name() {
			return GetRuleContext<Schema_qualified_nameContext>(0);
		}
		public ITerminalNode EQUAL() { return GetToken(PlPgSqlParser.EQUAL, 0); }
		public VexContext vex() {
			return GetRuleContext<VexContext>(0);
		}
		public Storage_parameter_optionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_storage_parameter_option; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStorage_parameter_option(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Storage_parameter_optionContext storage_parameter_option() {
		Storage_parameter_optionContext _localctx = new Storage_parameter_optionContext(Context, State);
		EnterRule(_localctx, 190, RULE_storage_parameter_option);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2138; schema_qualified_name();
			State = 2141;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==EQUAL) {
				{
				State = 2139; Match(EQUAL);
				State = 2140; vex(0);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class On_commitContext : ParserRuleContext {
		public ITerminalNode ON() { return GetToken(PlPgSqlParser.ON, 0); }
		public ITerminalNode COMMIT() { return GetToken(PlPgSqlParser.COMMIT, 0); }
		public ITerminalNode PRESERVE() { return GetToken(PlPgSqlParser.PRESERVE, 0); }
		public ITerminalNode ROWS() { return GetToken(PlPgSqlParser.ROWS, 0); }
		public ITerminalNode DELETE() { return GetToken(PlPgSqlParser.DELETE, 0); }
		public ITerminalNode DROP() { return GetToken(PlPgSqlParser.DROP, 0); }
		public On_commitContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_on_commit; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOn_commit(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public On_commitContext on_commit() {
		On_commitContext _localctx = new On_commitContext(Context, State);
		EnterRule(_localctx, 192, RULE_on_commit);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2143; Match(ON);
			State = 2144; Match(COMMIT);
			State = 2150;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case PRESERVE:
				{
				State = 2145; Match(PRESERVE);
				State = 2146; Match(ROWS);
				}
				break;
			case DELETE:
				{
				State = 2147; Match(DELETE);
				State = 2148; Match(ROWS);
				}
				break;
			case DROP:
				{
				State = 2149; Match(DROP);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Table_spaceContext : ParserRuleContext {
		public ITerminalNode TABLESPACE() { return GetToken(PlPgSqlParser.TABLESPACE, 0); }
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Table_spaceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_table_space; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTable_space(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Table_spaceContext table_space() {
		Table_spaceContext _localctx = new Table_spaceContext(Context, State);
		EnterRule(_localctx, 194, RULE_table_space);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2152; Match(TABLESPACE);
			State = 2153; identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class If_not_existsContext : ParserRuleContext {
		public ITerminalNode IF() { return GetToken(PlPgSqlParser.IF, 0); }
		public ITerminalNode NOT() { return GetToken(PlPgSqlParser.NOT, 0); }
		public ITerminalNode EXISTS() { return GetToken(PlPgSqlParser.EXISTS, 0); }
		public If_not_existsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_if_not_exists; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIf_not_exists(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public If_not_existsContext if_not_exists() {
		If_not_existsContext _localctx = new If_not_existsContext(Context, State);
		EnterRule(_localctx, 196, RULE_if_not_exists);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2155; Match(IF);
			State = 2156; Match(NOT);
			State = 2157; Match(EXISTS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Create_view_statementContext : ParserRuleContext {
		public Schema_qualified_nameContext name;
		public View_columnsContext column_names;
		public Select_stmtContext v_query;
		public ITerminalNode VIEW() { return GetToken(PlPgSqlParser.VIEW, 0); }
		public ITerminalNode AS() { return GetToken(PlPgSqlParser.AS, 0); }
		public Schema_qualified_nameContext schema_qualified_name() {
			return GetRuleContext<Schema_qualified_nameContext>(0);
		}
		public Select_stmtContext select_stmt() {
			return GetRuleContext<Select_stmtContext>(0);
		}
		public ITerminalNode OR() { return GetToken(PlPgSqlParser.OR, 0); }
		public ITerminalNode REPLACE() { return GetToken(PlPgSqlParser.REPLACE, 0); }
		public ITerminalNode RECURSIVE() { return GetToken(PlPgSqlParser.RECURSIVE, 0); }
		public ITerminalNode MATERIALIZED() { return GetToken(PlPgSqlParser.MATERIALIZED, 0); }
		public If_not_existsContext if_not_exists() {
			return GetRuleContext<If_not_existsContext>(0);
		}
		public ITerminalNode USING() { return GetToken(PlPgSqlParser.USING, 0); }
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ITerminalNode[] WITH() { return GetTokens(PlPgSqlParser.WITH); }
		public ITerminalNode WITH(int i) {
			return GetToken(PlPgSqlParser.WITH, i);
		}
		public Storage_parameterContext storage_parameter() {
			return GetRuleContext<Storage_parameterContext>(0);
		}
		public Table_spaceContext table_space() {
			return GetRuleContext<Table_spaceContext>(0);
		}
		public With_check_optionContext with_check_option() {
			return GetRuleContext<With_check_optionContext>(0);
		}
		public ITerminalNode DATA() { return GetToken(PlPgSqlParser.DATA, 0); }
		public ITerminalNode TEMP() { return GetToken(PlPgSqlParser.TEMP, 0); }
		public ITerminalNode TEMPORARY() { return GetToken(PlPgSqlParser.TEMPORARY, 0); }
		public View_columnsContext view_columns() {
			return GetRuleContext<View_columnsContext>(0);
		}
		public ITerminalNode NO() { return GetToken(PlPgSqlParser.NO, 0); }
		public Create_view_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_create_view_statement; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreate_view_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Create_view_statementContext create_view_statement() {
		Create_view_statementContext _localctx = new Create_view_statementContext(Context, State);
		EnterRule(_localctx, 198, RULE_create_view_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2161;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OR) {
				{
				State = 2159; Match(OR);
				State = 2160; Match(REPLACE);
				}
			}

			State = 2164;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==TEMP || _la==TEMPORARY) {
				{
				State = 2163;
				_la = TokenStream.LA(1);
				if ( !(_la==TEMP || _la==TEMPORARY) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 2167;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==RECURSIVE) {
				{
				State = 2166; Match(RECURSIVE);
				}
			}

			State = 2170;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==MATERIALIZED) {
				{
				State = 2169; Match(MATERIALIZED);
				}
			}

			State = 2172; Match(VIEW);
			State = 2174;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,316,Context) ) {
			case 1:
				{
				State = 2173; if_not_exists();
				}
				break;
			}
			State = 2176; _localctx.name = schema_qualified_name();
			State = 2178;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LEFT_PAREN) {
				{
				State = 2177; _localctx.column_names = view_columns();
				}
			}

			State = 2182;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==USING) {
				{
				State = 2180; Match(USING);
				State = 2181; identifier();
				}
			}

			State = 2186;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WITH) {
				{
				State = 2184; Match(WITH);
				State = 2185; storage_parameter();
				}
			}

			State = 2189;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==TABLESPACE) {
				{
				State = 2188; table_space();
				}
			}

			State = 2191; Match(AS);
			State = 2192; _localctx.v_query = select_stmt();
			State = 2194;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,321,Context) ) {
			case 1:
				{
				State = 2193; with_check_option();
				}
				break;
			}
			State = 2201;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,323,Context) ) {
			case 1:
				{
				State = 2196; Match(WITH);
				State = 2198;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==NO) {
					{
					State = 2197; Match(NO);
					}
				}

				State = 2200; Match(DATA);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class View_columnsContext : ParserRuleContext {
		public ITerminalNode LEFT_PAREN() { return GetToken(PlPgSqlParser.LEFT_PAREN, 0); }
		public IdentifierContext[] identifier() {
			return GetRuleContexts<IdentifierContext>();
		}
		public IdentifierContext identifier(int i) {
			return GetRuleContext<IdentifierContext>(i);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlPgSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(PlPgSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlPgSqlParser.COMMA, i);
		}
		public View_columnsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_view_columns; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitView_columns(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public View_columnsContext view_columns() {
		View_columnsContext _localctx = new View_columnsContext(Context, State);
		EnterRule(_localctx, 200, RULE_view_columns);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2203; Match(LEFT_PAREN);
			State = 2204; identifier();
			State = 2209;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 2205; Match(COMMA);
				State = 2206; identifier();
				}
				}
				State = 2211;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 2212; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class With_check_optionContext : ParserRuleContext {
		public ITerminalNode WITH() { return GetToken(PlPgSqlParser.WITH, 0); }
		public ITerminalNode CHECK() { return GetToken(PlPgSqlParser.CHECK, 0); }
		public ITerminalNode OPTION() { return GetToken(PlPgSqlParser.OPTION, 0); }
		public ITerminalNode CASCADED() { return GetToken(PlPgSqlParser.CASCADED, 0); }
		public ITerminalNode LOCAL() { return GetToken(PlPgSqlParser.LOCAL, 0); }
		public With_check_optionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_with_check_option; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWith_check_option(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public With_check_optionContext with_check_option() {
		With_check_optionContext _localctx = new With_check_optionContext(Context, State);
		EnterRule(_localctx, 202, RULE_with_check_option);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2214; Match(WITH);
			State = 2216;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==CASCADED || _la==LOCAL) {
				{
				State = 2215;
				_la = TokenStream.LA(1);
				if ( !(_la==CASCADED || _la==LOCAL) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 2218; Match(CHECK);
			State = 2219; Match(OPTION);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Execute_statementContext : ParserRuleContext {
		public ITerminalNode EXECUTE() { return GetToken(PlPgSqlParser.EXECUTE, 0); }
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ITerminalNode LEFT_PAREN() { return GetToken(PlPgSqlParser.LEFT_PAREN, 0); }
		public VexContext[] vex() {
			return GetRuleContexts<VexContext>();
		}
		public VexContext vex(int i) {
			return GetRuleContext<VexContext>(i);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlPgSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(PlPgSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlPgSqlParser.COMMA, i);
		}
		public Execute_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_execute_statement; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExecute_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Execute_statementContext execute_statement() {
		Execute_statementContext _localctx = new Execute_statementContext(Context, State);
		EnterRule(_localctx, 204, RULE_execute_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2221; Match(EXECUTE);
			State = 2222; identifier();
			State = 2234;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,327,Context) ) {
			case 1:
				{
				State = 2223; Match(LEFT_PAREN);
				State = 2224; vex(0);
				State = 2229;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 2225; Match(COMMA);
					State = 2226; vex(0);
					}
					}
					State = 2231;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 2232; Match(RIGHT_PAREN);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Declare_statementContext : ParserRuleContext {
		public ITerminalNode DECLARE() { return GetToken(PlPgSqlParser.DECLARE, 0); }
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ITerminalNode CURSOR() { return GetToken(PlPgSqlParser.CURSOR, 0); }
		public ITerminalNode FOR() { return GetToken(PlPgSqlParser.FOR, 0); }
		public Select_stmtContext select_stmt() {
			return GetRuleContext<Select_stmtContext>(0);
		}
		public ITerminalNode BINARY() { return GetToken(PlPgSqlParser.BINARY, 0); }
		public ITerminalNode INSENSITIVE() { return GetToken(PlPgSqlParser.INSENSITIVE, 0); }
		public ITerminalNode SCROLL() { return GetToken(PlPgSqlParser.SCROLL, 0); }
		public ITerminalNode HOLD() { return GetToken(PlPgSqlParser.HOLD, 0); }
		public ITerminalNode WITH() { return GetToken(PlPgSqlParser.WITH, 0); }
		public ITerminalNode WITHOUT() { return GetToken(PlPgSqlParser.WITHOUT, 0); }
		public ITerminalNode NO() { return GetToken(PlPgSqlParser.NO, 0); }
		public Declare_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_declare_statement; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeclare_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Declare_statementContext declare_statement() {
		Declare_statementContext _localctx = new Declare_statementContext(Context, State);
		EnterRule(_localctx, 206, RULE_declare_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2236; Match(DECLARE);
			State = 2237; identifier();
			State = 2239;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==BINARY) {
				{
				State = 2238; Match(BINARY);
				}
			}

			State = 2242;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==INSENSITIVE) {
				{
				State = 2241; Match(INSENSITIVE);
				}
			}

			State = 2248;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NO || _la==SCROLL) {
				{
				State = 2245;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==NO) {
					{
					State = 2244; Match(NO);
					}
				}

				State = 2247; Match(SCROLL);
				}
			}

			State = 2250; Match(CURSOR);
			State = 2253;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WITHOUT || _la==WITH) {
				{
				State = 2251;
				_la = TokenStream.LA(1);
				if ( !(_la==WITHOUT || _la==WITH) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 2252; Match(HOLD);
				}
			}

			State = 2255; Match(FOR);
			State = 2256; select_stmt();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Explain_optionContext : ParserRuleContext {
		public ITerminalNode ANALYZE() { return GetToken(PlPgSqlParser.ANALYZE, 0); }
		public ITerminalNode VERBOSE() { return GetToken(PlPgSqlParser.VERBOSE, 0); }
		public ITerminalNode COSTS() { return GetToken(PlPgSqlParser.COSTS, 0); }
		public ITerminalNode SETTINGS() { return GetToken(PlPgSqlParser.SETTINGS, 0); }
		public ITerminalNode BUFFERS() { return GetToken(PlPgSqlParser.BUFFERS, 0); }
		public ITerminalNode TIMING() { return GetToken(PlPgSqlParser.TIMING, 0); }
		public ITerminalNode SUMMARY() { return GetToken(PlPgSqlParser.SUMMARY, 0); }
		public Boolean_valueContext boolean_value() {
			return GetRuleContext<Boolean_valueContext>(0);
		}
		public ITerminalNode FORMAT() { return GetToken(PlPgSqlParser.FORMAT, 0); }
		public ITerminalNode TEXT() { return GetToken(PlPgSqlParser.TEXT, 0); }
		public ITerminalNode XML() { return GetToken(PlPgSqlParser.XML, 0); }
		public ITerminalNode JSON() { return GetToken(PlPgSqlParser.JSON, 0); }
		public ITerminalNode YAML() { return GetToken(PlPgSqlParser.YAML, 0); }
		public Explain_optionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_explain_option; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExplain_option(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Explain_optionContext explain_option() {
		Explain_optionContext _localctx = new Explain_optionContext(Context, State);
		EnterRule(_localctx, 208, RULE_explain_option);
		int _la;
		try {
			State = 2264;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case VERBOSE:
			case ANALYZE:
			case BUFFERS:
			case COSTS:
			case SETTINGS:
			case SUMMARY:
			case TIMING:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2258;
				_la = TokenStream.LA(1);
				if ( !(_la==VERBOSE || _la==ANALYZE || _la==BUFFERS || _la==COSTS || ((((_la - 523)) & ~0x3f) == 0 && ((1L << (_la - 523)) & ((1L << (SETTINGS - 523)) | (1L << (SUMMARY - 523)) | (1L << (TIMING - 523)))) != 0)) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 2260;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==OFF || ((((_la - 397)) & ~0x3f) == 0 && ((1L << (_la - 397)) & ((1L << (FALSE - 397)) | (1L << (ON - 397)) | (1L << (TRUE - 397)))) != 0) || _la==NUMBER_LITERAL) {
					{
					State = 2259; boolean_value();
					}
				}

				}
				break;
			case FORMAT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2262; Match(FORMAT);
				State = 2263;
				_la = TokenStream.LA(1);
				if ( !(_la==TEXT || _la==XML || _la==JSON || _la==YAML) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Boolean_valueContext : ParserRuleContext {
		public ITerminalNode TRUE() { return GetToken(PlPgSqlParser.TRUE, 0); }
		public ITerminalNode FALSE() { return GetToken(PlPgSqlParser.FALSE, 0); }
		public ITerminalNode OFF() { return GetToken(PlPgSqlParser.OFF, 0); }
		public ITerminalNode ON() { return GetToken(PlPgSqlParser.ON, 0); }
		public ITerminalNode NUMBER_LITERAL() { return GetToken(PlPgSqlParser.NUMBER_LITERAL, 0); }
		public Boolean_valueContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_boolean_value; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBoolean_value(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Boolean_valueContext boolean_value() {
		Boolean_valueContext _localctx = new Boolean_valueContext(Context, State);
		EnterRule(_localctx, 210, RULE_boolean_value);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2266;
			_la = TokenStream.LA(1);
			if ( !(_la==OFF || ((((_la - 397)) & ~0x3f) == 0 && ((1L << (_la - 397)) & ((1L << (FALSE - 397)) | (1L << (ON - 397)) | (1L << (TRUE - 397)))) != 0) || _la==NUMBER_LITERAL) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Show_statementContext : ParserRuleContext {
		public ITerminalNode SHOW() { return GetToken(PlPgSqlParser.SHOW, 0); }
		public IdentifierContext[] identifier() {
			return GetRuleContexts<IdentifierContext>();
		}
		public IdentifierContext identifier(int i) {
			return GetRuleContext<IdentifierContext>(i);
		}
		public ITerminalNode ALL() { return GetToken(PlPgSqlParser.ALL, 0); }
		public ITerminalNode TIME() { return GetToken(PlPgSqlParser.TIME, 0); }
		public ITerminalNode ZONE() { return GetToken(PlPgSqlParser.ZONE, 0); }
		public ITerminalNode TRANSACTION() { return GetToken(PlPgSqlParser.TRANSACTION, 0); }
		public ITerminalNode ISOLATION() { return GetToken(PlPgSqlParser.ISOLATION, 0); }
		public ITerminalNode LEVEL() { return GetToken(PlPgSqlParser.LEVEL, 0); }
		public ITerminalNode SESSION() { return GetToken(PlPgSqlParser.SESSION, 0); }
		public ITerminalNode AUTHORIZATION() { return GetToken(PlPgSqlParser.AUTHORIZATION, 0); }
		public ITerminalNode DOT() { return GetToken(PlPgSqlParser.DOT, 0); }
		public Show_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_show_statement; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShow_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Show_statementContext show_statement() {
		Show_statementContext _localctx = new Show_statementContext(Context, State);
		EnterRule(_localctx, 212, RULE_show_statement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2268; Match(SHOW);
			State = 2283;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,336,Context) ) {
			case 1:
				{
				State = 2272;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,335,Context) ) {
				case 1:
					{
					State = 2269; identifier();
					State = 2270; Match(DOT);
					}
					break;
				}
				State = 2274; identifier();
				}
				break;
			case 2:
				{
				State = 2275; Match(ALL);
				}
				break;
			case 3:
				{
				State = 2276; Match(TIME);
				State = 2277; Match(ZONE);
				}
				break;
			case 4:
				{
				State = 2278; Match(TRANSACTION);
				State = 2279; Match(ISOLATION);
				State = 2280; Match(LEVEL);
				}
				break;
			case 5:
				{
				State = 2281; Match(SESSION);
				State = 2282; Match(AUTHORIZATION);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Execute_stmtContext : ParserRuleContext {
		public ITerminalNode EXECUTE() { return GetToken(PlPgSqlParser.EXECUTE, 0); }
		public VexContext vex() {
			return GetRuleContext<VexContext>(0);
		}
		public Using_vexContext using_vex() {
			return GetRuleContext<Using_vexContext>(0);
		}
		public Execute_stmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_execute_stmt; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExecute_stmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Execute_stmtContext execute_stmt() {
		Execute_stmtContext _localctx = new Execute_stmtContext(Context, State);
		EnterRule(_localctx, 214, RULE_execute_stmt);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2285; Match(EXECUTE);
			State = 2286; vex(0);
			State = 2288;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==USING) {
				{
				State = 2287; using_vex();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class If_statementContext : ParserRuleContext {
		public ITerminalNode[] IF() { return GetTokens(PlPgSqlParser.IF); }
		public ITerminalNode IF(int i) {
			return GetToken(PlPgSqlParser.IF, i);
		}
		public VexContext[] vex() {
			return GetRuleContexts<VexContext>();
		}
		public VexContext vex(int i) {
			return GetRuleContext<VexContext>(i);
		}
		public ITerminalNode[] THEN() { return GetTokens(PlPgSqlParser.THEN); }
		public ITerminalNode THEN(int i) {
			return GetToken(PlPgSqlParser.THEN, i);
		}
		public Function_statementsContext[] function_statements() {
			return GetRuleContexts<Function_statementsContext>();
		}
		public Function_statementsContext function_statements(int i) {
			return GetRuleContext<Function_statementsContext>(i);
		}
		public ITerminalNode END() { return GetToken(PlPgSqlParser.END, 0); }
		public ITerminalNode ELSE() { return GetToken(PlPgSqlParser.ELSE, 0); }
		public ITerminalNode[] ELSIF() { return GetTokens(PlPgSqlParser.ELSIF); }
		public ITerminalNode ELSIF(int i) {
			return GetToken(PlPgSqlParser.ELSIF, i);
		}
		public ITerminalNode[] ELSEIF() { return GetTokens(PlPgSqlParser.ELSEIF); }
		public ITerminalNode ELSEIF(int i) {
			return GetToken(PlPgSqlParser.ELSEIF, i);
		}
		public If_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_if_statement; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIf_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public If_statementContext if_statement() {
		If_statementContext _localctx = new If_statementContext(Context, State);
		EnterRule(_localctx, 216, RULE_if_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2290; Match(IF);
			State = 2291; vex(0);
			State = 2292; Match(THEN);
			State = 2293; function_statements();
			State = 2301;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==ELSEIF || _la==ELSIF) {
				{
				{
				State = 2294;
				_la = TokenStream.LA(1);
				if ( !(_la==ELSEIF || _la==ELSIF) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 2295; vex(0);
				State = 2296; Match(THEN);
				State = 2297; function_statements();
				}
				}
				State = 2303;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 2306;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ELSE) {
				{
				State = 2304; Match(ELSE);
				State = 2305; function_statements();
				}
			}

			State = 2308; Match(END);
			State = 2309; Match(IF);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Case_statementContext : ParserRuleContext {
		public ITerminalNode[] CASE() { return GetTokens(PlPgSqlParser.CASE); }
		public ITerminalNode CASE(int i) {
			return GetToken(PlPgSqlParser.CASE, i);
		}
		public ITerminalNode END() { return GetToken(PlPgSqlParser.END, 0); }
		public VexContext[] vex() {
			return GetRuleContexts<VexContext>();
		}
		public VexContext vex(int i) {
			return GetRuleContext<VexContext>(i);
		}
		public ITerminalNode[] WHEN() { return GetTokens(PlPgSqlParser.WHEN); }
		public ITerminalNode WHEN(int i) {
			return GetToken(PlPgSqlParser.WHEN, i);
		}
		public ITerminalNode[] THEN() { return GetTokens(PlPgSqlParser.THEN); }
		public ITerminalNode THEN(int i) {
			return GetToken(PlPgSqlParser.THEN, i);
		}
		public Function_statementsContext[] function_statements() {
			return GetRuleContexts<Function_statementsContext>();
		}
		public Function_statementsContext function_statements(int i) {
			return GetRuleContext<Function_statementsContext>(i);
		}
		public ITerminalNode ELSE() { return GetToken(PlPgSqlParser.ELSE, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(PlPgSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlPgSqlParser.COMMA, i);
		}
		public Case_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_case_statement; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCase_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Case_statementContext case_statement() {
		Case_statementContext _localctx = new Case_statementContext(Context, State);
		EnterRule(_localctx, 218, RULE_case_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2311; Match(CASE);
			State = 2313;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ABORT) | (1L << ABSOLUTE) | (1L << ACCESS) | (1L << ACTION) | (1L << ADD) | (1L << ADMIN) | (1L << AFTER) | (1L << AGGREGATE) | (1L << ALSO) | (1L << ALTER) | (1L << ALWAYS) | (1L << ASSERTION) | (1L << ASSIGNMENT) | (1L << AT) | (1L << ATTACH) | (1L << ATTRIBUTE) | (1L << BACKWARD) | (1L << BEFORE) | (1L << BEGIN) | (1L << BY) | (1L << CACHE) | (1L << CALL) | (1L << CALLED) | (1L << CASCADE) | (1L << CASCADED) | (1L << CATALOG) | (1L << CHAIN) | (1L << CHARACTERISTICS) | (1L << CHECKPOINT) | (1L << CLASS) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMENTS) | (1L << COMMIT) | (1L << COMMITTED) | (1L << CONFIGURATION) | (1L << CONFLICT) | (1L << CONNECTION) | (1L << CONSTRAINTS) | (1L << CONTENT) | (1L << CONTINUE) | (1L << CONVERSION) | (1L << COPY) | (1L << COST) | (1L << CSV) | (1L << CUBE) | (1L << CURRENT) | (1L << CURSOR) | (1L << CYCLE) | (1L << DATA) | (1L << DATABASE) | (1L << DAY) | (1L << DEALLOCATE) | (1L << DECLARE) | (1L << DEFAULTS) | (1L << DEFERRED) | (1L << DEFINER) | (1L << DELETE) | (1L << DELIMITER) | (1L << DELIMITERS) | (1L << DEPENDS))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (DETACH - 64)) | (1L << (DICTIONARY - 64)) | (1L << (DISABLE - 64)) | (1L << (DISCARD - 64)) | (1L << (DOCUMENT - 64)) | (1L << (DOMAIN - 64)) | (1L << (DOUBLE - 64)) | (1L << (DROP - 64)) | (1L << (EACH - 64)) | (1L << (ENABLE - 64)) | (1L << (ENCODING - 64)) | (1L << (ENCRYPTED - 64)) | (1L << (ENUM - 64)) | (1L << (ESCAPE - 64)) | (1L << (EVENT - 64)) | (1L << (EXCLUDE - 64)) | (1L << (EXCLUDING - 64)) | (1L << (EXCLUSIVE - 64)) | (1L << (EXECUTE - 64)) | (1L << (EXPLAIN - 64)) | (1L << (EXTENSION - 64)) | (1L << (EXTERNAL - 64)) | (1L << (FAMILY - 64)) | (1L << (FILTER - 64)) | (1L << (FIRST - 64)) | (1L << (FOLLOWING - 64)) | (1L << (FORCE - 64)) | (1L << (FORWARD - 64)) | (1L << (FUNCTION - 64)) | (1L << (FUNCTIONS - 64)) | (1L << (GENERATED - 64)) | (1L << (GLOBAL - 64)) | (1L << (GRANTED - 64)) | (1L << (GROUPS - 64)) | (1L << (HANDLER - 64)) | (1L << (HEADER - 64)) | (1L << (HOLD - 64)) | (1L << (HOUR - 64)) | (1L << (IDENTITY - 64)) | (1L << (IF - 64)) | (1L << (IMMEDIATE - 64)) | (1L << (IMMUTABLE - 64)) | (1L << (IMPLICIT - 64)) | (1L << (IMPORT - 64)) | (1L << (INCLUDE - 64)) | (1L << (INCLUDING - 64)) | (1L << (INCREMENT - 64)) | (1L << (INDEX - 64)) | (1L << (INDEXES - 64)) | (1L << (INHERIT - 64)) | (1L << (INHERITS - 64)) | (1L << (INLINE - 64)) | (1L << (INPUT - 64)) | (1L << (INSENSITIVE - 64)) | (1L << (INSERT - 64)) | (1L << (INSTEAD - 64)) | (1L << (INVOKER - 64)) | (1L << (ISOLATION - 64)) | (1L << (KEY - 64)) | (1L << (LABEL - 64)) | (1L << (LANGUAGE - 64)) | (1L << (LARGE - 64)) | (1L << (LAST - 64)) | (1L << (LEAKPROOF - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (LEVEL - 128)) | (1L << (LISTEN - 128)) | (1L << (LOAD - 128)) | (1L << (LOCAL - 128)) | (1L << (LOCATION - 128)) | (1L << (LOCK - 128)) | (1L << (LOCKED - 128)) | (1L << (LOGGED - 128)) | (1L << (MAPPING - 128)) | (1L << (MATCH - 128)) | (1L << (MATERIALIZED - 128)) | (1L << (MAXVALUE - 128)) | (1L << (METHOD - 128)) | (1L << (MINUTE - 128)) | (1L << (MINVALUE - 128)) | (1L << (MODE - 128)) | (1L << (MONTH - 128)) | (1L << (MOVE - 128)) | (1L << (NAME - 128)) | (1L << (NAMES - 128)) | (1L << (NEW - 128)) | (1L << (NEXT - 128)) | (1L << (NO - 128)) | (1L << (NOTHING - 128)) | (1L << (NOTIFY - 128)) | (1L << (NOWAIT - 128)) | (1L << (NULLS - 128)) | (1L << (OBJECT - 128)) | (1L << (OF - 128)) | (1L << (OFF - 128)) | (1L << (OIDS - 128)) | (1L << (OLD - 128)) | (1L << (OPERATOR - 128)) | (1L << (OPTION - 128)) | (1L << (OPTIONS - 128)) | (1L << (ORDINALITY - 128)) | (1L << (OTHERS - 128)) | (1L << (OVER - 128)) | (1L << (OVERRIDING - 128)) | (1L << (OWNED - 128)) | (1L << (OWNER - 128)) | (1L << (PARALLEL - 128)) | (1L << (PARSER - 128)) | (1L << (PARTIAL - 128)) | (1L << (PARTITION - 128)) | (1L << (PASSING - 128)) | (1L << (PASSWORD - 128)) | (1L << (PLANS - 128)) | (1L << (POLICY - 128)) | (1L << (PRECEDING - 128)) | (1L << (PREPARE - 128)) | (1L << (PREPARED - 128)) | (1L << (PRESERVE - 128)) | (1L << (PRIOR - 128)) | (1L << (PRIVILEGES - 128)) | (1L << (PROCEDURAL - 128)) | (1L << (PROCEDURE - 128)) | (1L << (PROCEDURES - 128)) | (1L << (PROGRAM - 128)) | (1L << (PUBLICATION - 128)) | (1L << (QUOTE - 128)) | (1L << (RANGE - 128)) | (1L << (READ - 128)) | (1L << (REASSIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (RECHECK - 192)) | (1L << (RECURSIVE - 192)) | (1L << (REF - 192)) | (1L << (REFERENCING - 192)) | (1L << (REFRESH - 192)) | (1L << (REINDEX - 192)) | (1L << (RELATIVE - 192)) | (1L << (RELEASE - 192)) | (1L << (RENAME - 192)) | (1L << (REPEATABLE - 192)) | (1L << (REPLACE - 192)) | (1L << (REPLICA - 192)) | (1L << (RESET - 192)) | (1L << (RESTART - 192)) | (1L << (RESTRICT - 192)) | (1L << (RETURNS - 192)) | (1L << (REVOKE - 192)) | (1L << (ROLE - 192)) | (1L << (ROLLBACK - 192)) | (1L << (ROLLUP - 192)) | (1L << (ROUTINE - 192)) | (1L << (ROUTINES - 192)) | (1L << (ROWS - 192)) | (1L << (RULE - 192)) | (1L << (SAVEPOINT - 192)) | (1L << (SCHEMA - 192)) | (1L << (SCHEMAS - 192)) | (1L << (SCROLL - 192)) | (1L << (SEARCH - 192)) | (1L << (SECOND - 192)) | (1L << (SECURITY - 192)) | (1L << (SEQUENCE - 192)) | (1L << (SEQUENCES - 192)) | (1L << (SERIALIZABLE - 192)) | (1L << (SERVER - 192)) | (1L << (SESSION - 192)) | (1L << (SET - 192)) | (1L << (SETS - 192)) | (1L << (SHARE - 192)) | (1L << (SHOW - 192)) | (1L << (SIMPLE - 192)) | (1L << (SKIP_ - 192)) | (1L << (SNAPSHOT - 192)) | (1L << (SQL - 192)) | (1L << (STABLE - 192)) | (1L << (STANDALONE - 192)) | (1L << (START - 192)) | (1L << (STATEMENT - 192)) | (1L << (STATISTICS - 192)) | (1L << (STDIN - 192)) | (1L << (STDOUT - 192)) | (1L << (STORAGE - 192)) | (1L << (STORED - 192)) | (1L << (STRICT - 192)) | (1L << (STRIP - 192)) | (1L << (SUBSCRIPTION - 192)) | (1L << (SUPPORT - 192)) | (1L << (SYSID - 192)) | (1L << (SYSTEM - 192)) | (1L << (TABLES - 192)) | (1L << (TABLESPACE - 192)) | (1L << (TEMP - 192)) | (1L << (TEMPLATE - 192)) | (1L << (TEMPORARY - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (TEXT - 256)) | (1L << (TIES - 256)) | (1L << (TRANSACTION - 256)) | (1L << (TRANSFORM - 256)) | (1L << (TRIGGER - 256)) | (1L << (TRUNCATE - 256)) | (1L << (TRUSTED - 256)) | (1L << (TYPE - 256)) | (1L << (TYPES - 256)) | (1L << (UNBOUNDED - 256)) | (1L << (UNCOMMITTED - 256)) | (1L << (UNENCRYPTED - 256)) | (1L << (UNKNOWN - 256)) | (1L << (UNLISTEN - 256)) | (1L << (UNLOGGED - 256)) | (1L << (UNTIL - 256)) | (1L << (UPDATE - 256)) | (1L << (VACUUM - 256)) | (1L << (VALID - 256)) | (1L << (VALIDATE - 256)) | (1L << (VALIDATOR - 256)) | (1L << (VALUE - 256)) | (1L << (VARYING - 256)) | (1L << (VERSION - 256)) | (1L << (VIEW - 256)) | (1L << (VIEWS - 256)) | (1L << (VOLATILE - 256)) | (1L << (WHITESPACE - 256)) | (1L << (WITHIN - 256)) | (1L << (WITHOUT - 256)) | (1L << (WORK - 256)) | (1L << (WRAPPER - 256)) | (1L << (WRITE - 256)) | (1L << (XML - 256)) | (1L << (YEAR - 256)) | (1L << (YES - 256)) | (1L << (ZONE - 256)) | (1L << (BETWEEN - 256)) | (1L << (BIGINT - 256)) | (1L << (BIT - 256)) | (1L << (BOOLEAN - 256)) | (1L << (CHAR - 256)) | (1L << (CHARACTER - 256)) | (1L << (COALESCE - 256)) | (1L << (DEC - 256)) | (1L << (DECIMAL - 256)) | (1L << (EXISTS - 256)) | (1L << (EXTRACT - 256)) | (1L << (FLOAT - 256)) | (1L << (GREATEST - 256)) | (1L << (GROUPING - 256)) | (1L << (INOUT - 256)) | (1L << (INT - 256)) | (1L << (INTEGER - 256)) | (1L << (INTERVAL - 256)) | (1L << (LEAST - 256)) | (1L << (NATIONAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NONE - 256)) | (1L << (NULLIF - 256)) | (1L << (NUMERIC - 256)) | (1L << (OUT - 256)) | (1L << (OVERLAY - 256)) | (1L << (POSITION - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (PRECISION - 320)) | (1L << (REAL - 320)) | (1L << (ROW - 320)) | (1L << (SETOF - 320)) | (1L << (SMALLINT - 320)) | (1L << (SUBSTRING - 320)) | (1L << (TIME - 320)) | (1L << (TIMESTAMP - 320)) | (1L << (TREAT - 320)) | (1L << (TRIM - 320)) | (1L << (VALUES - 320)) | (1L << (VARCHAR - 320)) | (1L << (XMLATTRIBUTES - 320)) | (1L << (XMLCONCAT - 320)) | (1L << (XMLELEMENT - 320)) | (1L << (XMLEXISTS - 320)) | (1L << (XMLFOREST - 320)) | (1L << (XMLNAMESPACES - 320)) | (1L << (XMLPARSE - 320)) | (1L << (XMLPI - 320)) | (1L << (XMLROOT - 320)) | (1L << (XMLSERIALIZE - 320)) | (1L << (XMLTABLE - 320)) | (1L << (AUTHORIZATION - 320)) | (1L << (BINARY - 320)) | (1L << (COLLATION - 320)) | (1L << (CONCURRENTLY - 320)) | (1L << (CROSS - 320)) | (1L << (CURRENT_SCHEMA - 320)) | (1L << (FREEZE - 320)) | (1L << (FULL - 320)) | (1L << (ILIKE - 320)) | (1L << (INNER - 320)) | (1L << (IS - 320)) | (1L << (ISNULL - 320)) | (1L << (JOIN - 320)) | (1L << (LEFT - 320)) | (1L << (LIKE - 320)) | (1L << (NATURAL - 320)) | (1L << (NOTNULL - 320)) | (1L << (OUTER - 320)) | (1L << (OVERLAPS - 320)) | (1L << (RIGHT - 320)) | (1L << (SIMILAR - 320)) | (1L << (TABLESAMPLE - 320)) | (1L << (VERBOSE - 320)) | (1L << (ALL - 320)) | (1L << (ANY - 320)) | (1L << (ARRAY - 320)) | (1L << (CASE - 320)) | (1L << (CAST - 320)) | (1L << (CURRENT_CATALOG - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (CURRENT_DATE - 384)) | (1L << (CURRENT_TIME - 384)) | (1L << (CURRENT_TIMESTAMP - 384)) | (1L << (CURRENT_USER - 384)) | (1L << (FALSE - 384)) | (1L << (LOCALTIME - 384)) | (1L << (LOCALTIMESTAMP - 384)) | (1L << (NOT - 384)) | (1L << (NULL - 384)) | (1L << (ON - 384)) | (1L << (SESSION_USER - 384)) | (1L << (SOME - 384)) | (1L << (TRUE - 384)) | (1L << (USER - 384)) | (1L << (ALIGNMENT - 384)) | (1L << (BASETYPE - 384)) | (1L << (BUFFERS - 384)) | (1L << (BYPASSRLS - 384)) | (1L << (CANONICAL - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (CATEGORY - 448)) | (1L << (COLLATABLE - 448)) | (1L << (COMBINEFUNC - 448)) | (1L << (COMMUTATOR - 448)) | (1L << (CONNECT - 448)) | (1L << (COSTS - 448)) | (1L << (CREATEDB - 448)) | (1L << (CREATEROLE - 448)) | (1L << (DESERIALFUNC - 448)) | (1L << (DETERMINISTIC - 448)) | (1L << (DISABLE_PAGE_SKIPPING - 448)) | (1L << (ELEMENT - 448)) | (1L << (EXTENDED - 448)) | (1L << (FINALFUNC - 448)) | (1L << (FINALFUNC_EXTRA - 448)) | (1L << (FINALFUNC_MODIFY - 448)) | (1L << (FORCE_NOT_NULL - 448)) | (1L << (FORCE_NULL - 448)) | (1L << (FORCE_QUOTE - 448)) | (1L << (FORMAT - 448)) | (1L << (GETTOKEN - 448)) | (1L << (HASH - 448)) | (1L << (HASHES - 448)) | (1L << (HEADLINE - 448)) | (1L << (HYPOTHETICAL - 448)) | (1L << (INDEX_CLEANUP - 448)) | (1L << (INIT - 448)) | (1L << (INITCOND - 448)) | (1L << (INTERNALLENGTH - 448)) | (1L << (JSON - 448)) | (1L << (LC_COLLATE - 448)) | (1L << (LC_CTYPE - 448)) | (1L << (LEFTARG - 448)) | (1L << (LEXIZE - 448)) | (1L << (LEXTYPES - 448)) | (1L << (LIST - 448)) | (1L << (LOCALE - 448)) | (1L << (LOGIN - 448)) | (1L << (MAIN - 448)) | (1L << (MERGES - 448)) | (1L << (MFINALFUNC - 448)) | (1L << (MFINALFUNC_EXTRA - 448)) | (1L << (MFINALFUNC_MODIFY - 448)) | (1L << (MINITCOND - 448)) | (1L << (MINVFUNC - 448)) | (1L << (MODULUS - 448)) | (1L << (MSFUNC - 448)) | (1L << (MSSPACE - 448)) | (1L << (MSTYPE - 448)) | (1L << (NEGATOR - 448)) | (1L << (NOBYPASSRLS - 448)) | (1L << (NOCREATEDB - 448)) | (1L << (NOCREATEROLE - 448)) | (1L << (NOINHERIT - 448)) | (1L << (NOLOGIN - 448)) | (1L << (NOREPLICATION - 448)) | (1L << (NOSUPERUSER - 448)) | (1L << (OUTPUT - 448)) | (1L << (PASSEDBYVALUE - 448)) | (1L << (PATH - 448)) | (1L << (PERMISSIVE - 448)) | (1L << (PLAIN - 448)) | (1L << (PREFERRED - 448)) | (1L << (PROVIDER - 448)))) != 0) || ((((_la - 512)) & ~0x3f) == 0 && ((1L << (_la - 512)) & ((1L << (READ_ONLY - 512)) | (1L << (READ_WRITE - 512)) | (1L << (RECEIVE - 512)) | (1L << (REMAINDER - 512)) | (1L << (REPLICATION - 512)) | (1L << (RESTRICTED - 512)) | (1L << (RESTRICTIVE - 512)) | (1L << (RIGHTARG - 512)) | (1L << (SAFE - 512)) | (1L << (SEND - 512)) | (1L << (SERIALFUNC - 512)) | (1L << (SETTINGS - 512)) | (1L << (SFUNC - 512)) | (1L << (SHAREABLE - 512)) | (1L << (SKIP_LOCKED - 512)) | (1L << (SORTOP - 512)) | (1L << (SSPACE - 512)) | (1L << (STYPE - 512)) | (1L << (SUBTYPE_DIFF - 512)) | (1L << (SUBTYPE_OPCLASS - 512)) | (1L << (SUBTYPE - 512)) | (1L << (SUMMARY - 512)) | (1L << (SUPERUSER - 512)) | (1L << (TIMING - 512)) | (1L << (TYPMOD_IN - 512)) | (1L << (TYPMOD_OUT - 512)) | (1L << (UNSAFE - 512)) | (1L << (USAGE - 512)) | (1L << (VARIABLE - 512)) | (1L << (YAML - 512)) | (1L << (ALIAS - 512)) | (1L << (ASSERT - 512)) | (1L << (CONSTANT - 512)) | (1L << (DATATYPE - 512)) | (1L << (DEBUG - 512)) | (1L << (DETAIL - 512)) | (1L << (DIAGNOSTICS - 512)) | (1L << (ELSEIF - 512)) | (1L << (ELSIF - 512)) | (1L << (ERRCODE - 512)) | (1L << (EXIT - 512)) | (1L << (EXCEPTION - 512)) | (1L << (FOREACH - 512)) | (1L << (GET - 512)) | (1L << (HINT - 512)) | (1L << (INFO - 512)) | (1L << (LOG - 512)) | (1L << (LOOP - 512)) | (1L << (MESSAGE - 512)) | (1L << (NOTICE - 512)) | (1L << (OPEN - 512)) | (1L << (PERFORM - 512)) | (1L << (QUERY - 512)) | (1L << (RAISE - 512)) | (1L << (RECORD - 512)) | (1L << (RETURN - 512)) | (1L << (REVERSE - 512)) | (1L << (ROWTYPE - 512)) | (1L << (SLICE - 512)) | (1L << (SQLSTATE - 512)) | (1L << (STACKED - 512)) | (1L << (WARNING - 512)) | (1L << (WHILE - 512)))) != 0) || ((((_la - 585)) & ~0x3f) == 0 && ((1L << (_la - 585)) & ((1L << (LEFT_PAREN - 585)) | (1L << (PLUS - 585)) | (1L << (MINUS - 585)) | (1L << (MULTIPLY - 585)) | (1L << (LESS_LESS - 585)) | (1L << (GREATER_GREATER - 585)) | (1L << (HASH_SIGN - 585)) | (1L << (OP_CHARS - 585)) | (1L << (NUMBER_LITERAL - 585)) | (1L << (REAL_NUMBER - 585)) | (1L << (DOLLAR_NUMBER - 585)) | (1L << (Identifier - 585)) | (1L << (QuotedIdentifier - 585)) | (1L << (Character_String_Literal - 585)) | (1L << (BeginDollarStringConstant - 585)))) != 0)) {
				{
				State = 2312; vex(0);
				}
			}

			State = 2327;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 2315; Match(WHEN);
				State = 2316; vex(0);
				State = 2321;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 2317; Match(COMMA);
					State = 2318; vex(0);
					}
					}
					State = 2323;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 2324; Match(THEN);
				State = 2325; function_statements();
				}
				}
				State = 2329;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==WHEN );
			State = 2333;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ELSE) {
				{
				State = 2331; Match(ELSE);
				State = 2332; function_statements();
				}
			}

			State = 2335; Match(END);
			State = 2336; Match(CASE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Loop_statementContext : ParserRuleContext {
		public ITerminalNode[] LOOP() { return GetTokens(PlPgSqlParser.LOOP); }
		public ITerminalNode LOOP(int i) {
			return GetToken(PlPgSqlParser.LOOP, i);
		}
		public Function_statementsContext function_statements() {
			return GetRuleContext<Function_statementsContext>(0);
		}
		public ITerminalNode END() { return GetToken(PlPgSqlParser.END, 0); }
		public Start_labelContext start_label() {
			return GetRuleContext<Start_labelContext>(0);
		}
		public Loop_startContext loop_start() {
			return GetRuleContext<Loop_startContext>(0);
		}
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ITerminalNode EXIT() { return GetToken(PlPgSqlParser.EXIT, 0); }
		public ITerminalNode CONTINUE() { return GetToken(PlPgSqlParser.CONTINUE, 0); }
		public ITerminalNode WHEN() { return GetToken(PlPgSqlParser.WHEN, 0); }
		public VexContext vex() {
			return GetRuleContext<VexContext>(0);
		}
		public Loop_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_loop_statement; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLoop_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Loop_statementContext loop_statement() {
		Loop_statementContext _localctx = new Loop_statementContext(Context, State);
		EnterRule(_localctx, 220, RULE_loop_statement);
		int _la;
		try {
			State = 2359;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case FOR:
			case FOREACH:
			case LOOP:
			case WHILE:
			case LESS_LESS:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2339;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LESS_LESS) {
					{
					State = 2338; start_label();
					}
				}

				State = 2342;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==FOR || _la==FOREACH || _la==WHILE) {
					{
					State = 2341; loop_start();
					}
				}

				State = 2344; Match(LOOP);
				State = 2345; function_statements();
				State = 2346; Match(END);
				State = 2347; Match(LOOP);
				State = 2349;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,346,Context) ) {
				case 1:
					{
					State = 2348; identifier();
					}
					break;
				}
				}
				break;
			case CONTINUE:
			case EXIT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2351;
				_la = TokenStream.LA(1);
				if ( !(_la==CONTINUE || _la==EXIT) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 2353;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,347,Context) ) {
				case 1:
					{
					State = 2352; identifier();
					}
					break;
				}
				State = 2357;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,348,Context) ) {
				case 1:
					{
					State = 2355; Match(WHEN);
					State = 2356; vex(0);
					}
					break;
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Loop_startContext : ParserRuleContext {
		public IdentifierContext alias;
		public IdentifierContext cursor;
		public ITerminalNode WHILE() { return GetToken(PlPgSqlParser.WHILE, 0); }
		public VexContext[] vex() {
			return GetRuleContexts<VexContext>();
		}
		public VexContext vex(int i) {
			return GetRuleContext<VexContext>(i);
		}
		public ITerminalNode FOR() { return GetToken(PlPgSqlParser.FOR, 0); }
		public ITerminalNode IN() { return GetToken(PlPgSqlParser.IN, 0); }
		public ITerminalNode DOUBLE_DOT() { return GetToken(PlPgSqlParser.DOUBLE_DOT, 0); }
		public IdentifierContext[] identifier() {
			return GetRuleContexts<IdentifierContext>();
		}
		public IdentifierContext identifier(int i) {
			return GetRuleContext<IdentifierContext>(i);
		}
		public ITerminalNode REVERSE() { return GetToken(PlPgSqlParser.REVERSE, 0); }
		public ITerminalNode BY() { return GetToken(PlPgSqlParser.BY, 0); }
		public Identifier_listContext identifier_list() {
			return GetRuleContext<Identifier_listContext>(0);
		}
		public Select_stmtContext select_stmt() {
			return GetRuleContext<Select_stmtContext>(0);
		}
		public Execute_stmtContext execute_stmt() {
			return GetRuleContext<Execute_stmtContext>(0);
		}
		public ITerminalNode LEFT_PAREN() { return GetToken(PlPgSqlParser.LEFT_PAREN, 0); }
		public OptionContext[] option() {
			return GetRuleContexts<OptionContext>();
		}
		public OptionContext option(int i) {
			return GetRuleContext<OptionContext>(i);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlPgSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(PlPgSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlPgSqlParser.COMMA, i);
		}
		public ITerminalNode FOREACH() { return GetToken(PlPgSqlParser.FOREACH, 0); }
		public ITerminalNode ARRAY() { return GetToken(PlPgSqlParser.ARRAY, 0); }
		public ITerminalNode SLICE() { return GetToken(PlPgSqlParser.SLICE, 0); }
		public ITerminalNode NUMBER_LITERAL() { return GetToken(PlPgSqlParser.NUMBER_LITERAL, 0); }
		public Loop_startContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_loop_start; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLoop_start(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Loop_startContext loop_start() {
		Loop_startContext _localctx = new Loop_startContext(Context, State);
		EnterRule(_localctx, 222, RULE_loop_start);
		int _la;
		try {
			State = 2410;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,356,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2361; Match(WHILE);
				State = 2362; vex(0);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2363; Match(FOR);
				State = 2364; _localctx.alias = identifier();
				State = 2365; Match(IN);
				State = 2367;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,350,Context) ) {
				case 1:
					{
					State = 2366; Match(REVERSE);
					}
					break;
				}
				State = 2369; vex(0);
				State = 2370; Match(DOUBLE_DOT);
				State = 2371; vex(0);
				State = 2374;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==BY) {
					{
					State = 2372; Match(BY);
					State = 2373; vex(0);
					}
				}

				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2376; Match(FOR);
				State = 2377; identifier_list();
				State = 2378; Match(IN);
				State = 2381;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case VALUES:
				case SELECT:
				case TABLE:
				case WITH:
				case LEFT_PAREN:
					{
					State = 2379; select_stmt();
					}
					break;
				case EXECUTE:
					{
					State = 2380; execute_stmt();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 2383; Match(FOR);
				State = 2384; _localctx.cursor = identifier();
				State = 2385; Match(IN);
				State = 2386; identifier();
				State = 2398;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LEFT_PAREN) {
					{
					State = 2387; Match(LEFT_PAREN);
					State = 2388; option();
					State = 2393;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					while (_la==COMMA) {
						{
						{
						State = 2389; Match(COMMA);
						State = 2390; option();
						}
						}
						State = 2395;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					}
					State = 2396; Match(RIGHT_PAREN);
					}
				}

				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 2400; Match(FOREACH);
				State = 2401; identifier_list();
				State = 2404;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==SLICE) {
					{
					State = 2402; Match(SLICE);
					State = 2403; Match(NUMBER_LITERAL);
					}
				}

				State = 2406; Match(IN);
				State = 2407; Match(ARRAY);
				State = 2408; vex(0);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OptionContext : ParserRuleContext {
		public VexContext vex() {
			return GetRuleContext<VexContext>(0);
		}
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ITerminalNode COLON_EQUAL() { return GetToken(PlPgSqlParser.COLON_EQUAL, 0); }
		public OptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_option; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOption(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OptionContext option() {
		OptionContext _localctx = new OptionContext(Context, State);
		EnterRule(_localctx, 224, RULE_option);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2415;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,357,Context) ) {
			case 1:
				{
				State = 2412; identifier();
				State = 2413; Match(COLON_EQUAL);
				}
				break;
			}
			State = 2417; vex(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Identifier_listContext : ParserRuleContext {
		public IdentifierContext[] identifier() {
			return GetRuleContexts<IdentifierContext>();
		}
		public IdentifierContext identifier(int i) {
			return GetRuleContext<IdentifierContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlPgSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlPgSqlParser.COMMA, i);
		}
		public Identifier_listContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifier_list; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIdentifier_list(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Identifier_listContext identifier_list() {
		Identifier_listContext _localctx = new Identifier_listContext(Context, State);
		EnterRule(_localctx, 226, RULE_identifier_list);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2419; identifier();
			State = 2424;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,358,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 2420; Match(COMMA);
					State = 2421; identifier();
					}
					} 
				}
				State = 2426;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,358,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Transaction_statementContext : ParserRuleContext {
		public ITerminalNode COMMIT() { return GetToken(PlPgSqlParser.COMMIT, 0); }
		public ITerminalNode ROLLBACK() { return GetToken(PlPgSqlParser.ROLLBACK, 0); }
		public ITerminalNode AND() { return GetToken(PlPgSqlParser.AND, 0); }
		public ITerminalNode CHAIN() { return GetToken(PlPgSqlParser.CHAIN, 0); }
		public ITerminalNode NO() { return GetToken(PlPgSqlParser.NO, 0); }
		public Lock_tableContext lock_table() {
			return GetRuleContext<Lock_tableContext>(0);
		}
		public Transaction_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_transaction_statement; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTransaction_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Transaction_statementContext transaction_statement() {
		Transaction_statementContext _localctx = new Transaction_statementContext(Context, State);
		EnterRule(_localctx, 228, RULE_transaction_statement);
		int _la;
		try {
			State = 2436;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case COMMIT:
			case ROLLBACK:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2427;
				_la = TokenStream.LA(1);
				if ( !(_la==COMMIT || _la==ROLLBACK) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 2433;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==AND) {
					{
					State = 2428; Match(AND);
					State = 2430;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==NO) {
						{
						State = 2429; Match(NO);
						}
					}

					State = 2432; Match(CHAIN);
					}
				}

				}
				break;
			case LOCK:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2435; lock_table();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Lock_tableContext : ParserRuleContext {
		public ITerminalNode LOCK() { return GetToken(PlPgSqlParser.LOCK, 0); }
		public Only_table_multiplyContext[] only_table_multiply() {
			return GetRuleContexts<Only_table_multiplyContext>();
		}
		public Only_table_multiplyContext only_table_multiply(int i) {
			return GetRuleContext<Only_table_multiplyContext>(i);
		}
		public ITerminalNode TABLE() { return GetToken(PlPgSqlParser.TABLE, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(PlPgSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlPgSqlParser.COMMA, i);
		}
		public ITerminalNode IN() { return GetToken(PlPgSqlParser.IN, 0); }
		public Lock_modeContext lock_mode() {
			return GetRuleContext<Lock_modeContext>(0);
		}
		public ITerminalNode MODE() { return GetToken(PlPgSqlParser.MODE, 0); }
		public ITerminalNode NOWAIT() { return GetToken(PlPgSqlParser.NOWAIT, 0); }
		public Lock_tableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lock_table; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLock_table(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Lock_tableContext lock_table() {
		Lock_tableContext _localctx = new Lock_tableContext(Context, State);
		EnterRule(_localctx, 230, RULE_lock_table);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2438; Match(LOCK);
			State = 2440;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==TABLE) {
				{
				State = 2439; Match(TABLE);
				}
			}

			State = 2442; only_table_multiply();
			State = 2447;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 2443; Match(COMMA);
				State = 2444; only_table_multiply();
				}
				}
				State = 2449;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 2454;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IN) {
				{
				State = 2450; Match(IN);
				State = 2451; lock_mode();
				State = 2452; Match(MODE);
				}
			}

			State = 2457;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,365,Context) ) {
			case 1:
				{
				State = 2456; Match(NOWAIT);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Lock_modeContext : ParserRuleContext {
		public ITerminalNode SHARE() { return GetToken(PlPgSqlParser.SHARE, 0); }
		public ITerminalNode ROW() { return GetToken(PlPgSqlParser.ROW, 0); }
		public ITerminalNode ACCESS() { return GetToken(PlPgSqlParser.ACCESS, 0); }
		public ITerminalNode EXCLUSIVE() { return GetToken(PlPgSqlParser.EXCLUSIVE, 0); }
		public ITerminalNode UPDATE() { return GetToken(PlPgSqlParser.UPDATE, 0); }
		public Lock_modeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lock_mode; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLock_mode(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Lock_modeContext lock_mode() {
		Lock_modeContext _localctx = new Lock_modeContext(Context, State);
		EnterRule(_localctx, 232, RULE_lock_mode);
		int _la;
		try {
			State = 2471;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,367,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2459;
				_la = TokenStream.LA(1);
				if ( !(_la==ACCESS || _la==ROW) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 2460; Match(SHARE);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2461; Match(ROW);
				State = 2462; Match(EXCLUSIVE);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2463; Match(SHARE);
				State = 2464;
				_la = TokenStream.LA(1);
				if ( !(_la==UPDATE || _la==ROW) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 2465; Match(EXCLUSIVE);
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 2466; Match(SHARE);
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 2468;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ACCESS) {
					{
					State = 2467; Match(ACCESS);
					}
				}

				State = 2470; Match(EXCLUSIVE);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Only_table_multiplyContext : ParserRuleContext {
		public Schema_qualified_nameContext schema_qualified_name() {
			return GetRuleContext<Schema_qualified_nameContext>(0);
		}
		public ITerminalNode ONLY() { return GetToken(PlPgSqlParser.ONLY, 0); }
		public ITerminalNode MULTIPLY() { return GetToken(PlPgSqlParser.MULTIPLY, 0); }
		public Only_table_multiplyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_only_table_multiply; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOnly_table_multiply(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Only_table_multiplyContext only_table_multiply() {
		Only_table_multiplyContext _localctx = new Only_table_multiplyContext(Context, State);
		EnterRule(_localctx, 234, RULE_only_table_multiply);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2474;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ONLY) {
				{
				State = 2473; Match(ONLY);
				}
			}

			State = 2476; schema_qualified_name();
			State = 2478;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==MULTIPLY) {
				{
				State = 2477; Match(MULTIPLY);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Cursor_statementContext : ParserRuleContext {
		public ITerminalNode OPEN() { return GetToken(PlPgSqlParser.OPEN, 0); }
		public VarContext var() {
			return GetRuleContext<VarContext>(0);
		}
		public ITerminalNode FOR() { return GetToken(PlPgSqlParser.FOR, 0); }
		public Select_stmtContext select_stmt() {
			return GetRuleContext<Select_stmtContext>(0);
		}
		public Execute_stmtContext execute_stmt() {
			return GetRuleContext<Execute_stmtContext>(0);
		}
		public ITerminalNode SCROLL() { return GetToken(PlPgSqlParser.SCROLL, 0); }
		public ITerminalNode NO() { return GetToken(PlPgSqlParser.NO, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlPgSqlParser.LEFT_PAREN, 0); }
		public OptionContext[] option() {
			return GetRuleContexts<OptionContext>();
		}
		public OptionContext option(int i) {
			return GetRuleContext<OptionContext>(i);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlPgSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(PlPgSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlPgSqlParser.COMMA, i);
		}
		public ITerminalNode FETCH() { return GetToken(PlPgSqlParser.FETCH, 0); }
		public Fetch_move_directionContext fetch_move_direction() {
			return GetRuleContext<Fetch_move_directionContext>(0);
		}
		public Into_tableContext into_table() {
			return GetRuleContext<Into_tableContext>(0);
		}
		public ITerminalNode FROM() { return GetToken(PlPgSqlParser.FROM, 0); }
		public ITerminalNode IN() { return GetToken(PlPgSqlParser.IN, 0); }
		public ITerminalNode MOVE() { return GetToken(PlPgSqlParser.MOVE, 0); }
		public ITerminalNode CLOSE() { return GetToken(PlPgSqlParser.CLOSE, 0); }
		public Cursor_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cursor_statement; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCursor_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Cursor_statementContext cursor_statement() {
		Cursor_statementContext _localctx = new Cursor_statementContext(Context, State);
		EnterRule(_localctx, 236, RULE_cursor_statement);
		int _la;
		try {
			State = 2529;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,380,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2480; Match(OPEN);
				State = 2481; var();
				State = 2486;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==NO || _la==SCROLL) {
					{
					State = 2483;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==NO) {
						{
						State = 2482; Match(NO);
						}
					}

					State = 2485; Match(SCROLL);
					}
				}

				State = 2488; Match(FOR);
				State = 2491;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case VALUES:
				case SELECT:
				case TABLE:
				case WITH:
				case LEFT_PAREN:
					{
					State = 2489; select_stmt();
					}
					break;
				case EXECUTE:
					{
					State = 2490; execute_stmt();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2493; Match(OPEN);
				State = 2494; var();
				State = 2506;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,374,Context) ) {
				case 1:
					{
					State = 2495; Match(LEFT_PAREN);
					State = 2496; option();
					State = 2501;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					while (_la==COMMA) {
						{
						{
						State = 2497; Match(COMMA);
						State = 2498; option();
						}
						}
						State = 2503;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					}
					State = 2504; Match(RIGHT_PAREN);
					}
					break;
				}
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2508; Match(FETCH);
				State = 2510;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,375,Context) ) {
				case 1:
					{
					State = 2509; fetch_move_direction();
					}
					break;
				}
				State = 2513;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==FROM || _la==IN) {
					{
					State = 2512;
					_la = TokenStream.LA(1);
					if ( !(_la==FROM || _la==IN) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				State = 2515; var();
				State = 2517;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==INTO) {
					{
					State = 2516; into_table();
					}
				}

				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 2519; Match(MOVE);
				State = 2521;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,378,Context) ) {
				case 1:
					{
					State = 2520; fetch_move_direction();
					}
					break;
				}
				State = 2524;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==FROM || _la==IN) {
					{
					State = 2523;
					_la = TokenStream.LA(1);
					if ( !(_la==FROM || _la==IN) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				State = 2526; var();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 2527; Match(CLOSE);
				State = 2528; var();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Fetch_move_directionContext : ParserRuleContext {
		public ITerminalNode NEXT() { return GetToken(PlPgSqlParser.NEXT, 0); }
		public ITerminalNode PRIOR() { return GetToken(PlPgSqlParser.PRIOR, 0); }
		public ITerminalNode FIRST() { return GetToken(PlPgSqlParser.FIRST, 0); }
		public ITerminalNode LAST() { return GetToken(PlPgSqlParser.LAST, 0); }
		public Signed_number_literalContext signed_number_literal() {
			return GetRuleContext<Signed_number_literalContext>(0);
		}
		public ITerminalNode ABSOLUTE() { return GetToken(PlPgSqlParser.ABSOLUTE, 0); }
		public ITerminalNode RELATIVE() { return GetToken(PlPgSqlParser.RELATIVE, 0); }
		public ITerminalNode ALL() { return GetToken(PlPgSqlParser.ALL, 0); }
		public ITerminalNode FORWARD() { return GetToken(PlPgSqlParser.FORWARD, 0); }
		public ITerminalNode NUMBER_LITERAL() { return GetToken(PlPgSqlParser.NUMBER_LITERAL, 0); }
		public ITerminalNode BACKWARD() { return GetToken(PlPgSqlParser.BACKWARD, 0); }
		public Fetch_move_directionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fetch_move_direction; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFetch_move_direction(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Fetch_move_directionContext fetch_move_direction() {
		Fetch_move_directionContext _localctx = new Fetch_move_directionContext(Context, State);
		EnterRule(_localctx, 238, RULE_fetch_move_direction);
		int _la;
		try {
			State = 2548;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case NEXT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2531; Match(NEXT);
				}
				break;
			case PRIOR:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2532; Match(PRIOR);
				}
				break;
			case FIRST:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2533; Match(FIRST);
				}
				break;
			case LAST:
				EnterOuterAlt(_localctx, 4);
				{
				State = 2534; Match(LAST);
				}
				break;
			case ABSOLUTE:
			case RELATIVE:
			case PLUS:
			case MINUS:
			case NUMBER_LITERAL:
				EnterOuterAlt(_localctx, 5);
				{
				State = 2536;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ABSOLUTE || _la==RELATIVE) {
					{
					State = 2535;
					_la = TokenStream.LA(1);
					if ( !(_la==ABSOLUTE || _la==RELATIVE) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				State = 2538; signed_number_literal();
				}
				break;
			case ALL:
				EnterOuterAlt(_localctx, 6);
				{
				State = 2539; Match(ALL);
				}
				break;
			case FORWARD:
				EnterOuterAlt(_localctx, 7);
				{
				State = 2540; Match(FORWARD);
				State = 2542;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ALL || _la==NUMBER_LITERAL) {
					{
					State = 2541;
					_la = TokenStream.LA(1);
					if ( !(_la==ALL || _la==NUMBER_LITERAL) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				}
				break;
			case BACKWARD:
				EnterOuterAlt(_localctx, 8);
				{
				State = 2544; Match(BACKWARD);
				State = 2546;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ALL || _la==NUMBER_LITERAL) {
					{
					State = 2545;
					_la = TokenStream.LA(1);
					if ( !(_la==ALL || _la==NUMBER_LITERAL) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Signed_number_literalContext : ParserRuleContext {
		public ITerminalNode NUMBER_LITERAL() { return GetToken(PlPgSqlParser.NUMBER_LITERAL, 0); }
		public SignContext sign() {
			return GetRuleContext<SignContext>(0);
		}
		public Signed_number_literalContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_signed_number_literal; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSigned_number_literal(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Signed_number_literalContext signed_number_literal() {
		Signed_number_literalContext _localctx = new Signed_number_literalContext(Context, State);
		EnterRule(_localctx, 240, RULE_signed_number_literal);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2551;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PLUS || _la==MINUS) {
				{
				State = 2550; sign();
				}
			}

			State = 2553; Match(NUMBER_LITERAL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SignContext : ParserRuleContext {
		public ITerminalNode PLUS() { return GetToken(PlPgSqlParser.PLUS, 0); }
		public ITerminalNode MINUS() { return GetToken(PlPgSqlParser.MINUS, 0); }
		public SignContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sign; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSign(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SignContext sign() {
		SignContext _localctx = new SignContext(Context, State);
		EnterRule(_localctx, 242, RULE_sign);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2555;
			_la = TokenStream.LA(1);
			if ( !(_la==PLUS || _la==MINUS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Message_statementContext : ParserRuleContext {
		public ITerminalNode RAISE() { return GetToken(PlPgSqlParser.RAISE, 0); }
		public Log_levelContext log_level() {
			return GetRuleContext<Log_levelContext>(0);
		}
		public Character_stringContext character_string() {
			return GetRuleContext<Character_stringContext>(0);
		}
		public Raise_usingContext raise_using() {
			return GetRuleContext<Raise_usingContext>(0);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlPgSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlPgSqlParser.COMMA, i);
		}
		public VexContext[] vex() {
			return GetRuleContexts<VexContext>();
		}
		public VexContext vex(int i) {
			return GetRuleContext<VexContext>(i);
		}
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ITerminalNode SQLSTATE() { return GetToken(PlPgSqlParser.SQLSTATE, 0); }
		public ITerminalNode ASSERT() { return GetToken(PlPgSqlParser.ASSERT, 0); }
		public Message_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_message_statement; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMessage_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Message_statementContext message_statement() {
		Message_statementContext _localctx = new Message_statementContext(Context, State);
		EnterRule(_localctx, 244, RULE_message_statement);
		int _la;
		try {
			State = 2597;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,395,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2557; Match(RAISE);
				State = 2559;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,386,Context) ) {
				case 1:
					{
					State = 2558; log_level();
					}
					break;
				}
				State = 2569;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==Character_String_Literal || _la==BeginDollarStringConstant) {
					{
					State = 2561; character_string();
					State = 2566;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					while (_la==COMMA) {
						{
						{
						State = 2562; Match(COMMA);
						State = 2563; vex(0);
						}
						}
						State = 2568;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					}
					}
				}

				State = 2572;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==USING) {
					{
					State = 2571; raise_using();
					}
				}

				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2574; Match(RAISE);
				State = 2576;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,390,Context) ) {
				case 1:
					{
					State = 2575; log_level();
					}
					break;
				}
				State = 2578; identifier();
				State = 2580;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==USING) {
					{
					State = 2579; raise_using();
					}
				}

				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2582; Match(RAISE);
				State = 2584;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (((((_la - 546)) & ~0x3f) == 0 && ((1L << (_la - 546)) & ((1L << (DEBUG - 546)) | (1L << (EXCEPTION - 546)) | (1L << (INFO - 546)) | (1L << (LOG - 546)) | (1L << (NOTICE - 546)) | (1L << (WARNING - 546)))) != 0)) {
					{
					State = 2583; log_level();
					}
				}

				State = 2586; Match(SQLSTATE);
				State = 2587; character_string();
				State = 2589;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==USING) {
					{
					State = 2588; raise_using();
					}
				}

				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 2591; Match(ASSERT);
				State = 2592; vex(0);
				State = 2595;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COMMA) {
					{
					State = 2593; Match(COMMA);
					State = 2594; vex(0);
					}
				}

				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Raise_usingContext : ParserRuleContext {
		public ITerminalNode USING() { return GetToken(PlPgSqlParser.USING, 0); }
		public Raise_paramContext[] raise_param() {
			return GetRuleContexts<Raise_paramContext>();
		}
		public Raise_paramContext raise_param(int i) {
			return GetRuleContext<Raise_paramContext>(i);
		}
		public ITerminalNode[] EQUAL() { return GetTokens(PlPgSqlParser.EQUAL); }
		public ITerminalNode EQUAL(int i) {
			return GetToken(PlPgSqlParser.EQUAL, i);
		}
		public VexContext[] vex() {
			return GetRuleContexts<VexContext>();
		}
		public VexContext vex(int i) {
			return GetRuleContext<VexContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlPgSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlPgSqlParser.COMMA, i);
		}
		public Raise_usingContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_raise_using; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRaise_using(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Raise_usingContext raise_using() {
		Raise_usingContext _localctx = new Raise_usingContext(Context, State);
		EnterRule(_localctx, 246, RULE_raise_using);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2599; Match(USING);
			State = 2600; raise_param();
			State = 2601; Match(EQUAL);
			State = 2602; vex(0);
			State = 2610;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 2603; Match(COMMA);
				State = 2604; raise_param();
				State = 2605; Match(EQUAL);
				State = 2606; vex(0);
				}
				}
				State = 2612;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Raise_paramContext : ParserRuleContext {
		public ITerminalNode MESSAGE() { return GetToken(PlPgSqlParser.MESSAGE, 0); }
		public ITerminalNode DETAIL() { return GetToken(PlPgSqlParser.DETAIL, 0); }
		public ITerminalNode HINT() { return GetToken(PlPgSqlParser.HINT, 0); }
		public ITerminalNode ERRCODE() { return GetToken(PlPgSqlParser.ERRCODE, 0); }
		public ITerminalNode COLUMN() { return GetToken(PlPgSqlParser.COLUMN, 0); }
		public ITerminalNode CONSTRAINT() { return GetToken(PlPgSqlParser.CONSTRAINT, 0); }
		public ITerminalNode DATATYPE() { return GetToken(PlPgSqlParser.DATATYPE, 0); }
		public ITerminalNode TABLE() { return GetToken(PlPgSqlParser.TABLE, 0); }
		public ITerminalNode SCHEMA() { return GetToken(PlPgSqlParser.SCHEMA, 0); }
		public Raise_paramContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_raise_param; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRaise_param(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Raise_paramContext raise_param() {
		Raise_paramContext _localctx = new Raise_paramContext(Context, State);
		EnterRule(_localctx, 248, RULE_raise_param);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2613;
			_la = TokenStream.LA(1);
			if ( !(_la==SCHEMA || ((((_la - 380)) & ~0x3f) == 0 && ((1L << (_la - 380)) & ((1L << (COLUMN - 380)) | (1L << (CONSTRAINT - 380)) | (1L << (TABLE - 380)))) != 0) || ((((_la - 545)) & ~0x3f) == 0 && ((1L << (_la - 545)) & ((1L << (DATATYPE - 545)) | (1L << (DETAIL - 545)) | (1L << (ERRCODE - 545)) | (1L << (HINT - 545)) | (1L << (MESSAGE - 545)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Log_levelContext : ParserRuleContext {
		public ITerminalNode DEBUG() { return GetToken(PlPgSqlParser.DEBUG, 0); }
		public ITerminalNode LOG() { return GetToken(PlPgSqlParser.LOG, 0); }
		public ITerminalNode INFO() { return GetToken(PlPgSqlParser.INFO, 0); }
		public ITerminalNode NOTICE() { return GetToken(PlPgSqlParser.NOTICE, 0); }
		public ITerminalNode WARNING() { return GetToken(PlPgSqlParser.WARNING, 0); }
		public ITerminalNode EXCEPTION() { return GetToken(PlPgSqlParser.EXCEPTION, 0); }
		public Log_levelContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_log_level; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLog_level(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Log_levelContext log_level() {
		Log_levelContext _localctx = new Log_levelContext(Context, State);
		EnterRule(_localctx, 250, RULE_log_level);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2615;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 546)) & ~0x3f) == 0 && ((1L << (_la - 546)) & ((1L << (DEBUG - 546)) | (1L << (EXCEPTION - 546)) | (1L << (INFO - 546)) | (1L << (LOG - 546)) | (1L << (NOTICE - 546)) | (1L << (WARNING - 546)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Data_statementContext : ParserRuleContext {
		public Select_stmtContext select_stmt() {
			return GetRuleContext<Select_stmtContext>(0);
		}
		public Insert_stmt_for_psqlContext insert_stmt_for_psql() {
			return GetRuleContext<Insert_stmt_for_psqlContext>(0);
		}
		public Update_stmt_for_psqlContext update_stmt_for_psql() {
			return GetRuleContext<Update_stmt_for_psqlContext>(0);
		}
		public Delete_stmt_for_psqlContext delete_stmt_for_psql() {
			return GetRuleContext<Delete_stmt_for_psqlContext>(0);
		}
		public Notify_stmtContext notify_stmt() {
			return GetRuleContext<Notify_stmtContext>(0);
		}
		public Truncate_stmtContext truncate_stmt() {
			return GetRuleContext<Truncate_stmtContext>(0);
		}
		public Data_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_data_statement; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitData_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Data_statementContext data_statement() {
		Data_statementContext _localctx = new Data_statementContext(Context, State);
		EnterRule(_localctx, 252, RULE_data_statement);
		try {
			State = 2623;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,397,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2617; select_stmt();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2618; insert_stmt_for_psql();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2619; update_stmt_for_psql();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 2620; delete_stmt_for_psql();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 2621; notify_stmt();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 2622; truncate_stmt();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Notify_stmtContext : ParserRuleContext {
		public IdentifierContext channel;
		public Character_stringContext payload;
		public ITerminalNode NOTIFY() { return GetToken(PlPgSqlParser.NOTIFY, 0); }
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ITerminalNode COMMA() { return GetToken(PlPgSqlParser.COMMA, 0); }
		public Character_stringContext character_string() {
			return GetRuleContext<Character_stringContext>(0);
		}
		public Notify_stmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_notify_stmt; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNotify_stmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Notify_stmtContext notify_stmt() {
		Notify_stmtContext _localctx = new Notify_stmtContext(Context, State);
		EnterRule(_localctx, 254, RULE_notify_stmt);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2625; Match(NOTIFY);
			State = 2626; _localctx.channel = identifier();
			State = 2629;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMMA) {
				{
				State = 2627; Match(COMMA);
				State = 2628; _localctx.payload = character_string();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Truncate_stmtContext : ParserRuleContext {
		public ITerminalNode TRUNCATE() { return GetToken(PlPgSqlParser.TRUNCATE, 0); }
		public Only_table_multiplyContext[] only_table_multiply() {
			return GetRuleContexts<Only_table_multiplyContext>();
		}
		public Only_table_multiplyContext only_table_multiply(int i) {
			return GetRuleContext<Only_table_multiplyContext>(i);
		}
		public ITerminalNode TABLE() { return GetToken(PlPgSqlParser.TABLE, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(PlPgSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlPgSqlParser.COMMA, i);
		}
		public ITerminalNode IDENTITY() { return GetToken(PlPgSqlParser.IDENTITY, 0); }
		public Cascade_restrictContext cascade_restrict() {
			return GetRuleContext<Cascade_restrictContext>(0);
		}
		public ITerminalNode RESTART() { return GetToken(PlPgSqlParser.RESTART, 0); }
		public ITerminalNode CONTINUE() { return GetToken(PlPgSqlParser.CONTINUE, 0); }
		public Truncate_stmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_truncate_stmt; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTruncate_stmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Truncate_stmtContext truncate_stmt() {
		Truncate_stmtContext _localctx = new Truncate_stmtContext(Context, State);
		EnterRule(_localctx, 256, RULE_truncate_stmt);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2631; Match(TRUNCATE);
			State = 2633;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==TABLE) {
				{
				State = 2632; Match(TABLE);
				}
			}

			State = 2635; only_table_multiply();
			State = 2640;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 2636; Match(COMMA);
				State = 2637; only_table_multiply();
				}
				}
				State = 2642;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 2645;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,401,Context) ) {
			case 1:
				{
				State = 2643;
				_la = TokenStream.LA(1);
				if ( !(_la==CONTINUE || _la==RESTART) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 2644; Match(IDENTITY);
				}
				break;
			}
			State = 2648;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,402,Context) ) {
			case 1:
				{
				State = 2647; cascade_restrict();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Cascade_restrictContext : ParserRuleContext {
		public ITerminalNode CASCADE() { return GetToken(PlPgSqlParser.CASCADE, 0); }
		public ITerminalNode RESTRICT() { return GetToken(PlPgSqlParser.RESTRICT, 0); }
		public Cascade_restrictContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cascade_restrict; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCascade_restrict(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Cascade_restrictContext cascade_restrict() {
		Cascade_restrictContext _localctx = new Cascade_restrictContext(Context, State);
		EnterRule(_localctx, 258, RULE_cascade_restrict);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2650;
			_la = TokenStream.LA(1);
			if ( !(_la==CASCADE || _la==RESTRICT) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Additional_statementContext : ParserRuleContext {
		public Anonymous_blockContext anonymous_block() {
			return GetRuleContext<Anonymous_blockContext>(0);
		}
		public ITerminalNode LISTEN() { return GetToken(PlPgSqlParser.LISTEN, 0); }
		public IdentifierContext[] identifier() {
			return GetRuleContexts<IdentifierContext>();
		}
		public IdentifierContext identifier(int i) {
			return GetRuleContext<IdentifierContext>(i);
		}
		public ITerminalNode UNLISTEN() { return GetToken(PlPgSqlParser.UNLISTEN, 0); }
		public ITerminalNode MULTIPLY() { return GetToken(PlPgSqlParser.MULTIPLY, 0); }
		public ITerminalNode ANALYZE() { return GetToken(PlPgSqlParser.ANALYZE, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlPgSqlParser.LEFT_PAREN, 0); }
		public Analyze_modeContext[] analyze_mode() {
			return GetRuleContexts<Analyze_modeContext>();
		}
		public Analyze_modeContext analyze_mode(int i) {
			return GetRuleContext<Analyze_modeContext>(i);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlPgSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode VERBOSE() { return GetToken(PlPgSqlParser.VERBOSE, 0); }
		public Table_cols_listContext table_cols_list() {
			return GetRuleContext<Table_cols_listContext>(0);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlPgSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlPgSqlParser.COMMA, i);
		}
		public ITerminalNode CLUSTER() { return GetToken(PlPgSqlParser.CLUSTER, 0); }
		public ITerminalNode ON() { return GetToken(PlPgSqlParser.ON, 0); }
		public Schema_qualified_nameContext schema_qualified_name() {
			return GetRuleContext<Schema_qualified_nameContext>(0);
		}
		public ITerminalNode USING() { return GetToken(PlPgSqlParser.USING, 0); }
		public ITerminalNode CHECKPOINT() { return GetToken(PlPgSqlParser.CHECKPOINT, 0); }
		public ITerminalNode LOAD() { return GetToken(PlPgSqlParser.LOAD, 0); }
		public ITerminalNode Character_String_Literal() { return GetToken(PlPgSqlParser.Character_String_Literal, 0); }
		public ITerminalNode DEALLOCATE() { return GetToken(PlPgSqlParser.DEALLOCATE, 0); }
		public ITerminalNode ALL() { return GetToken(PlPgSqlParser.ALL, 0); }
		public ITerminalNode PREPARE() { return GetToken(PlPgSqlParser.PREPARE, 0); }
		public ITerminalNode REINDEX() { return GetToken(PlPgSqlParser.REINDEX, 0); }
		public ITerminalNode INDEX() { return GetToken(PlPgSqlParser.INDEX, 0); }
		public ITerminalNode TABLE() { return GetToken(PlPgSqlParser.TABLE, 0); }
		public ITerminalNode SCHEMA() { return GetToken(PlPgSqlParser.SCHEMA, 0); }
		public ITerminalNode DATABASE() { return GetToken(PlPgSqlParser.DATABASE, 0); }
		public ITerminalNode SYSTEM() { return GetToken(PlPgSqlParser.SYSTEM, 0); }
		public ITerminalNode CONCURRENTLY() { return GetToken(PlPgSqlParser.CONCURRENTLY, 0); }
		public ITerminalNode RESET() { return GetToken(PlPgSqlParser.RESET, 0); }
		public ITerminalNode TIME() { return GetToken(PlPgSqlParser.TIME, 0); }
		public ITerminalNode ZONE() { return GetToken(PlPgSqlParser.ZONE, 0); }
		public ITerminalNode SESSION() { return GetToken(PlPgSqlParser.SESSION, 0); }
		public ITerminalNode AUTHORIZATION() { return GetToken(PlPgSqlParser.AUTHORIZATION, 0); }
		public ITerminalNode DOT() { return GetToken(PlPgSqlParser.DOT, 0); }
		public Explain_statementContext explain_statement() {
			return GetRuleContext<Explain_statementContext>(0);
		}
		public ITerminalNode REFRESH() { return GetToken(PlPgSqlParser.REFRESH, 0); }
		public ITerminalNode MATERIALIZED() { return GetToken(PlPgSqlParser.MATERIALIZED, 0); }
		public ITerminalNode VIEW() { return GetToken(PlPgSqlParser.VIEW, 0); }
		public ITerminalNode WITH() { return GetToken(PlPgSqlParser.WITH, 0); }
		public ITerminalNode DATA() { return GetToken(PlPgSqlParser.DATA, 0); }
		public ITerminalNode NO() { return GetToken(PlPgSqlParser.NO, 0); }
		public ITerminalNode AS() { return GetToken(PlPgSqlParser.AS, 0); }
		public Data_statementContext data_statement() {
			return GetRuleContext<Data_statementContext>(0);
		}
		public Data_typeContext[] data_type() {
			return GetRuleContexts<Data_typeContext>();
		}
		public Data_typeContext data_type(int i) {
			return GetRuleContext<Data_typeContext>(i);
		}
		public ITerminalNode REASSIGN() { return GetToken(PlPgSqlParser.REASSIGN, 0); }
		public ITerminalNode OWNED() { return GetToken(PlPgSqlParser.OWNED, 0); }
		public ITerminalNode BY() { return GetToken(PlPgSqlParser.BY, 0); }
		public User_nameContext[] user_name() {
			return GetRuleContexts<User_nameContext>();
		}
		public User_nameContext user_name(int i) {
			return GetRuleContext<User_nameContext>(i);
		}
		public ITerminalNode TO() { return GetToken(PlPgSqlParser.TO, 0); }
		public Copy_statementContext copy_statement() {
			return GetRuleContext<Copy_statementContext>(0);
		}
		public Show_statementContext show_statement() {
			return GetRuleContext<Show_statementContext>(0);
		}
		public Additional_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_additional_statement; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAdditional_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Additional_statementContext additional_statement() {
		Additional_statementContext _localctx = new Additional_statementContext(Context, State);
		EnterRule(_localctx, 260, RULE_additional_statement);
		int _la;
		try {
			State = 2778;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case DO:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2652; anonymous_block();
				}
				break;
			case LISTEN:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2653; Match(LISTEN);
				State = 2654; identifier();
				}
				break;
			case UNLISTEN:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2655; Match(UNLISTEN);
				State = 2658;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case ABORT:
				case ABSOLUTE:
				case ACCESS:
				case ACTION:
				case ADD:
				case ADMIN:
				case AFTER:
				case AGGREGATE:
				case ALSO:
				case ALTER:
				case ALWAYS:
				case ASSERTION:
				case ASSIGNMENT:
				case AT:
				case ATTACH:
				case ATTRIBUTE:
				case BACKWARD:
				case BEFORE:
				case BEGIN:
				case BY:
				case CACHE:
				case CALL:
				case CALLED:
				case CASCADE:
				case CASCADED:
				case CATALOG:
				case CHAIN:
				case CHARACTERISTICS:
				case CHECKPOINT:
				case CLASS:
				case CLOSE:
				case CLUSTER:
				case COLUMNS:
				case COMMENT:
				case COMMENTS:
				case COMMIT:
				case COMMITTED:
				case CONFIGURATION:
				case CONFLICT:
				case CONNECTION:
				case CONSTRAINTS:
				case CONTENT:
				case CONTINUE:
				case CONVERSION:
				case COPY:
				case COST:
				case CSV:
				case CUBE:
				case CURRENT:
				case CURSOR:
				case CYCLE:
				case DATA:
				case DATABASE:
				case DAY:
				case DEALLOCATE:
				case DECLARE:
				case DEFAULTS:
				case DEFERRED:
				case DEFINER:
				case DELETE:
				case DELIMITER:
				case DELIMITERS:
				case DEPENDS:
				case DETACH:
				case DICTIONARY:
				case DISABLE:
				case DISCARD:
				case DOCUMENT:
				case DOMAIN:
				case DOUBLE:
				case DROP:
				case EACH:
				case ENABLE:
				case ENCODING:
				case ENCRYPTED:
				case ENUM:
				case ESCAPE:
				case EVENT:
				case EXCLUDE:
				case EXCLUDING:
				case EXCLUSIVE:
				case EXECUTE:
				case EXPLAIN:
				case EXTENSION:
				case EXTERNAL:
				case FAMILY:
				case FILTER:
				case FIRST:
				case FOLLOWING:
				case FORCE:
				case FORWARD:
				case FUNCTION:
				case FUNCTIONS:
				case GENERATED:
				case GLOBAL:
				case GRANTED:
				case GROUPS:
				case HANDLER:
				case HEADER:
				case HOLD:
				case HOUR:
				case IDENTITY:
				case IF:
				case IMMEDIATE:
				case IMMUTABLE:
				case IMPLICIT:
				case IMPORT:
				case INCLUDE:
				case INCLUDING:
				case INCREMENT:
				case INDEX:
				case INDEXES:
				case INHERIT:
				case INHERITS:
				case INLINE:
				case INPUT:
				case INSENSITIVE:
				case INSERT:
				case INSTEAD:
				case INVOKER:
				case ISOLATION:
				case KEY:
				case LABEL:
				case LANGUAGE:
				case LARGE:
				case LAST:
				case LEAKPROOF:
				case LEVEL:
				case LISTEN:
				case LOAD:
				case LOCAL:
				case LOCATION:
				case LOCK:
				case LOCKED:
				case LOGGED:
				case MAPPING:
				case MATCH:
				case MATERIALIZED:
				case MAXVALUE:
				case METHOD:
				case MINUTE:
				case MINVALUE:
				case MODE:
				case MONTH:
				case MOVE:
				case NAME:
				case NAMES:
				case NEW:
				case NEXT:
				case NO:
				case NOTHING:
				case NOTIFY:
				case NOWAIT:
				case NULLS:
				case OBJECT:
				case OF:
				case OFF:
				case OIDS:
				case OLD:
				case OPERATOR:
				case OPTION:
				case OPTIONS:
				case ORDINALITY:
				case OTHERS:
				case OVER:
				case OVERRIDING:
				case OWNED:
				case OWNER:
				case PARALLEL:
				case PARSER:
				case PARTIAL:
				case PARTITION:
				case PASSING:
				case PASSWORD:
				case PLANS:
				case POLICY:
				case PRECEDING:
				case PREPARE:
				case PREPARED:
				case PRESERVE:
				case PRIOR:
				case PRIVILEGES:
				case PROCEDURAL:
				case PROCEDURE:
				case PROCEDURES:
				case PROGRAM:
				case PUBLICATION:
				case QUOTE:
				case RANGE:
				case READ:
				case REASSIGN:
				case RECHECK:
				case RECURSIVE:
				case REF:
				case REFERENCING:
				case REFRESH:
				case REINDEX:
				case RELATIVE:
				case RELEASE:
				case RENAME:
				case REPEATABLE:
				case REPLACE:
				case REPLICA:
				case RESET:
				case RESTART:
				case RESTRICT:
				case RETURNS:
				case REVOKE:
				case ROLE:
				case ROLLBACK:
				case ROLLUP:
				case ROUTINE:
				case ROUTINES:
				case ROWS:
				case RULE:
				case SAVEPOINT:
				case SCHEMA:
				case SCHEMAS:
				case SCROLL:
				case SEARCH:
				case SECOND:
				case SECURITY:
				case SEQUENCE:
				case SEQUENCES:
				case SERIALIZABLE:
				case SERVER:
				case SESSION:
				case SET:
				case SETS:
				case SHARE:
				case SHOW:
				case SIMPLE:
				case SKIP_:
				case SNAPSHOT:
				case SQL:
				case STABLE:
				case STANDALONE:
				case START:
				case STATEMENT:
				case STATISTICS:
				case STDIN:
				case STDOUT:
				case STORAGE:
				case STORED:
				case STRICT:
				case STRIP:
				case SUBSCRIPTION:
				case SUPPORT:
				case SYSID:
				case SYSTEM:
				case TABLES:
				case TABLESPACE:
				case TEMP:
				case TEMPLATE:
				case TEMPORARY:
				case TEXT:
				case TIES:
				case TRANSACTION:
				case TRANSFORM:
				case TRIGGER:
				case TRUNCATE:
				case TRUSTED:
				case TYPE:
				case TYPES:
				case UNBOUNDED:
				case UNCOMMITTED:
				case UNENCRYPTED:
				case UNKNOWN:
				case UNLISTEN:
				case UNLOGGED:
				case UNTIL:
				case UPDATE:
				case VACUUM:
				case VALID:
				case VALIDATE:
				case VALIDATOR:
				case VALUE:
				case VARYING:
				case VERSION:
				case VIEW:
				case VIEWS:
				case VOLATILE:
				case WHITESPACE:
				case WITHIN:
				case WITHOUT:
				case WORK:
				case WRAPPER:
				case WRITE:
				case XML:
				case YEAR:
				case YES:
				case ZONE:
				case BETWEEN:
				case BIGINT:
				case BIT:
				case BOOLEAN:
				case CHAR:
				case CHARACTER:
				case COALESCE:
				case DEC:
				case DECIMAL:
				case EXISTS:
				case EXTRACT:
				case FLOAT:
				case GREATEST:
				case GROUPING:
				case INOUT:
				case INT:
				case INTEGER:
				case INTERVAL:
				case LEAST:
				case NATIONAL:
				case NCHAR:
				case NONE:
				case NULLIF:
				case NUMERIC:
				case OUT:
				case OVERLAY:
				case POSITION:
				case PRECISION:
				case REAL:
				case ROW:
				case SETOF:
				case SMALLINT:
				case SUBSTRING:
				case TIME:
				case TIMESTAMP:
				case TREAT:
				case TRIM:
				case VALUES:
				case VARCHAR:
				case XMLATTRIBUTES:
				case XMLCONCAT:
				case XMLELEMENT:
				case XMLEXISTS:
				case XMLFOREST:
				case XMLNAMESPACES:
				case XMLPARSE:
				case XMLPI:
				case XMLROOT:
				case XMLSERIALIZE:
				case XMLTABLE:
				case ALIGNMENT:
				case BASETYPE:
				case BUFFERS:
				case BYPASSRLS:
				case CANONICAL:
				case CATEGORY:
				case COLLATABLE:
				case COMBINEFUNC:
				case COMMUTATOR:
				case CONNECT:
				case COSTS:
				case CREATEDB:
				case CREATEROLE:
				case DESERIALFUNC:
				case DETERMINISTIC:
				case DISABLE_PAGE_SKIPPING:
				case ELEMENT:
				case EXTENDED:
				case FINALFUNC:
				case FINALFUNC_EXTRA:
				case FINALFUNC_MODIFY:
				case FORCE_NOT_NULL:
				case FORCE_NULL:
				case FORCE_QUOTE:
				case FORMAT:
				case GETTOKEN:
				case HASH:
				case HASHES:
				case HEADLINE:
				case HYPOTHETICAL:
				case INDEX_CLEANUP:
				case INIT:
				case INITCOND:
				case INTERNALLENGTH:
				case JSON:
				case LC_COLLATE:
				case LC_CTYPE:
				case LEFTARG:
				case LEXIZE:
				case LEXTYPES:
				case LIST:
				case LOCALE:
				case LOGIN:
				case MAIN:
				case MERGES:
				case MFINALFUNC:
				case MFINALFUNC_EXTRA:
				case MFINALFUNC_MODIFY:
				case MINITCOND:
				case MINVFUNC:
				case MODULUS:
				case MSFUNC:
				case MSSPACE:
				case MSTYPE:
				case NEGATOR:
				case NOBYPASSRLS:
				case NOCREATEDB:
				case NOCREATEROLE:
				case NOINHERIT:
				case NOLOGIN:
				case NOREPLICATION:
				case NOSUPERUSER:
				case OUTPUT:
				case PASSEDBYVALUE:
				case PATH:
				case PERMISSIVE:
				case PLAIN:
				case PREFERRED:
				case PROVIDER:
				case READ_ONLY:
				case READ_WRITE:
				case RECEIVE:
				case REMAINDER:
				case REPLICATION:
				case RESTRICTED:
				case RESTRICTIVE:
				case RIGHTARG:
				case SAFE:
				case SEND:
				case SERIALFUNC:
				case SETTINGS:
				case SFUNC:
				case SHAREABLE:
				case SKIP_LOCKED:
				case SORTOP:
				case SSPACE:
				case STYPE:
				case SUBTYPE_DIFF:
				case SUBTYPE_OPCLASS:
				case SUBTYPE:
				case SUMMARY:
				case SUPERUSER:
				case TIMING:
				case TYPMOD_IN:
				case TYPMOD_OUT:
				case UNSAFE:
				case USAGE:
				case VARIABLE:
				case YAML:
				case ALIAS:
				case ASSERT:
				case CONSTANT:
				case DATATYPE:
				case DEBUG:
				case DETAIL:
				case DIAGNOSTICS:
				case ELSEIF:
				case ELSIF:
				case ERRCODE:
				case EXIT:
				case EXCEPTION:
				case FOREACH:
				case GET:
				case HINT:
				case INFO:
				case LOG:
				case LOOP:
				case MESSAGE:
				case NOTICE:
				case OPEN:
				case PERFORM:
				case QUERY:
				case RAISE:
				case RECORD:
				case RETURN:
				case REVERSE:
				case ROWTYPE:
				case SLICE:
				case SQLSTATE:
				case STACKED:
				case WARNING:
				case WHILE:
				case Identifier:
				case QuotedIdentifier:
					{
					State = 2656; identifier();
					}
					break;
				case MULTIPLY:
					{
					State = 2657; Match(MULTIPLY);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case ANALYZE:
				EnterOuterAlt(_localctx, 4);
				{
				State = 2660; Match(ANALYZE);
				State = 2673;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,405,Context) ) {
				case 1:
					{
					State = 2661; Match(LEFT_PAREN);
					State = 2662; analyze_mode();
					State = 2667;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					while (_la==COMMA) {
						{
						{
						State = 2663; Match(COMMA);
						State = 2664; analyze_mode();
						}
						}
						State = 2669;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					}
					State = 2670; Match(RIGHT_PAREN);
					}
					break;
				case 2:
					{
					State = 2672; Match(VERBOSE);
					}
					break;
				}
				State = 2676;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,406,Context) ) {
				case 1:
					{
					State = 2675; table_cols_list();
					}
					break;
				}
				}
				break;
			case CLUSTER:
				EnterOuterAlt(_localctx, 5);
				{
				State = 2678; Match(CLUSTER);
				State = 2680;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==VERBOSE) {
					{
					State = 2679; Match(VERBOSE);
					}
				}

				State = 2691;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,409,Context) ) {
				case 1:
					{
					State = 2682; identifier();
					State = 2683; Match(ON);
					State = 2684; schema_qualified_name();
					}
					break;
				case 2:
					{
					State = 2686; schema_qualified_name();
					State = 2689;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==USING) {
						{
						State = 2687; Match(USING);
						State = 2688; identifier();
						}
					}

					}
					break;
				}
				}
				break;
			case CHECKPOINT:
				EnterOuterAlt(_localctx, 6);
				{
				State = 2693; Match(CHECKPOINT);
				}
				break;
			case LOAD:
				EnterOuterAlt(_localctx, 7);
				{
				State = 2694; Match(LOAD);
				State = 2695; Match(Character_String_Literal);
				}
				break;
			case DEALLOCATE:
				EnterOuterAlt(_localctx, 8);
				{
				State = 2696; Match(DEALLOCATE);
				State = 2698;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,410,Context) ) {
				case 1:
					{
					State = 2697; Match(PREPARE);
					}
					break;
				}
				State = 2702;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case ABORT:
				case ABSOLUTE:
				case ACCESS:
				case ACTION:
				case ADD:
				case ADMIN:
				case AFTER:
				case AGGREGATE:
				case ALSO:
				case ALTER:
				case ALWAYS:
				case ASSERTION:
				case ASSIGNMENT:
				case AT:
				case ATTACH:
				case ATTRIBUTE:
				case BACKWARD:
				case BEFORE:
				case BEGIN:
				case BY:
				case CACHE:
				case CALL:
				case CALLED:
				case CASCADE:
				case CASCADED:
				case CATALOG:
				case CHAIN:
				case CHARACTERISTICS:
				case CHECKPOINT:
				case CLASS:
				case CLOSE:
				case CLUSTER:
				case COLUMNS:
				case COMMENT:
				case COMMENTS:
				case COMMIT:
				case COMMITTED:
				case CONFIGURATION:
				case CONFLICT:
				case CONNECTION:
				case CONSTRAINTS:
				case CONTENT:
				case CONTINUE:
				case CONVERSION:
				case COPY:
				case COST:
				case CSV:
				case CUBE:
				case CURRENT:
				case CURSOR:
				case CYCLE:
				case DATA:
				case DATABASE:
				case DAY:
				case DEALLOCATE:
				case DECLARE:
				case DEFAULTS:
				case DEFERRED:
				case DEFINER:
				case DELETE:
				case DELIMITER:
				case DELIMITERS:
				case DEPENDS:
				case DETACH:
				case DICTIONARY:
				case DISABLE:
				case DISCARD:
				case DOCUMENT:
				case DOMAIN:
				case DOUBLE:
				case DROP:
				case EACH:
				case ENABLE:
				case ENCODING:
				case ENCRYPTED:
				case ENUM:
				case ESCAPE:
				case EVENT:
				case EXCLUDE:
				case EXCLUDING:
				case EXCLUSIVE:
				case EXECUTE:
				case EXPLAIN:
				case EXTENSION:
				case EXTERNAL:
				case FAMILY:
				case FILTER:
				case FIRST:
				case FOLLOWING:
				case FORCE:
				case FORWARD:
				case FUNCTION:
				case FUNCTIONS:
				case GENERATED:
				case GLOBAL:
				case GRANTED:
				case GROUPS:
				case HANDLER:
				case HEADER:
				case HOLD:
				case HOUR:
				case IDENTITY:
				case IF:
				case IMMEDIATE:
				case IMMUTABLE:
				case IMPLICIT:
				case IMPORT:
				case INCLUDE:
				case INCLUDING:
				case INCREMENT:
				case INDEX:
				case INDEXES:
				case INHERIT:
				case INHERITS:
				case INLINE:
				case INPUT:
				case INSENSITIVE:
				case INSERT:
				case INSTEAD:
				case INVOKER:
				case ISOLATION:
				case KEY:
				case LABEL:
				case LANGUAGE:
				case LARGE:
				case LAST:
				case LEAKPROOF:
				case LEVEL:
				case LISTEN:
				case LOAD:
				case LOCAL:
				case LOCATION:
				case LOCK:
				case LOCKED:
				case LOGGED:
				case MAPPING:
				case MATCH:
				case MATERIALIZED:
				case MAXVALUE:
				case METHOD:
				case MINUTE:
				case MINVALUE:
				case MODE:
				case MONTH:
				case MOVE:
				case NAME:
				case NAMES:
				case NEW:
				case NEXT:
				case NO:
				case NOTHING:
				case NOTIFY:
				case NOWAIT:
				case NULLS:
				case OBJECT:
				case OF:
				case OFF:
				case OIDS:
				case OLD:
				case OPERATOR:
				case OPTION:
				case OPTIONS:
				case ORDINALITY:
				case OTHERS:
				case OVER:
				case OVERRIDING:
				case OWNED:
				case OWNER:
				case PARALLEL:
				case PARSER:
				case PARTIAL:
				case PARTITION:
				case PASSING:
				case PASSWORD:
				case PLANS:
				case POLICY:
				case PRECEDING:
				case PREPARE:
				case PREPARED:
				case PRESERVE:
				case PRIOR:
				case PRIVILEGES:
				case PROCEDURAL:
				case PROCEDURE:
				case PROCEDURES:
				case PROGRAM:
				case PUBLICATION:
				case QUOTE:
				case RANGE:
				case READ:
				case REASSIGN:
				case RECHECK:
				case RECURSIVE:
				case REF:
				case REFERENCING:
				case REFRESH:
				case REINDEX:
				case RELATIVE:
				case RELEASE:
				case RENAME:
				case REPEATABLE:
				case REPLACE:
				case REPLICA:
				case RESET:
				case RESTART:
				case RESTRICT:
				case RETURNS:
				case REVOKE:
				case ROLE:
				case ROLLBACK:
				case ROLLUP:
				case ROUTINE:
				case ROUTINES:
				case ROWS:
				case RULE:
				case SAVEPOINT:
				case SCHEMA:
				case SCHEMAS:
				case SCROLL:
				case SEARCH:
				case SECOND:
				case SECURITY:
				case SEQUENCE:
				case SEQUENCES:
				case SERIALIZABLE:
				case SERVER:
				case SESSION:
				case SET:
				case SETS:
				case SHARE:
				case SHOW:
				case SIMPLE:
				case SKIP_:
				case SNAPSHOT:
				case SQL:
				case STABLE:
				case STANDALONE:
				case START:
				case STATEMENT:
				case STATISTICS:
				case STDIN:
				case STDOUT:
				case STORAGE:
				case STORED:
				case STRICT:
				case STRIP:
				case SUBSCRIPTION:
				case SUPPORT:
				case SYSID:
				case SYSTEM:
				case TABLES:
				case TABLESPACE:
				case TEMP:
				case TEMPLATE:
				case TEMPORARY:
				case TEXT:
				case TIES:
				case TRANSACTION:
				case TRANSFORM:
				case TRIGGER:
				case TRUNCATE:
				case TRUSTED:
				case TYPE:
				case TYPES:
				case UNBOUNDED:
				case UNCOMMITTED:
				case UNENCRYPTED:
				case UNKNOWN:
				case UNLISTEN:
				case UNLOGGED:
				case UNTIL:
				case UPDATE:
				case VACUUM:
				case VALID:
				case VALIDATE:
				case VALIDATOR:
				case VALUE:
				case VARYING:
				case VERSION:
				case VIEW:
				case VIEWS:
				case VOLATILE:
				case WHITESPACE:
				case WITHIN:
				case WITHOUT:
				case WORK:
				case WRAPPER:
				case WRITE:
				case XML:
				case YEAR:
				case YES:
				case ZONE:
				case BETWEEN:
				case BIGINT:
				case BIT:
				case BOOLEAN:
				case CHAR:
				case CHARACTER:
				case COALESCE:
				case DEC:
				case DECIMAL:
				case EXISTS:
				case EXTRACT:
				case FLOAT:
				case GREATEST:
				case GROUPING:
				case INOUT:
				case INT:
				case INTEGER:
				case INTERVAL:
				case LEAST:
				case NATIONAL:
				case NCHAR:
				case NONE:
				case NULLIF:
				case NUMERIC:
				case OUT:
				case OVERLAY:
				case POSITION:
				case PRECISION:
				case REAL:
				case ROW:
				case SETOF:
				case SMALLINT:
				case SUBSTRING:
				case TIME:
				case TIMESTAMP:
				case TREAT:
				case TRIM:
				case VALUES:
				case VARCHAR:
				case XMLATTRIBUTES:
				case XMLCONCAT:
				case XMLELEMENT:
				case XMLEXISTS:
				case XMLFOREST:
				case XMLNAMESPACES:
				case XMLPARSE:
				case XMLPI:
				case XMLROOT:
				case XMLSERIALIZE:
				case XMLTABLE:
				case ALIGNMENT:
				case BASETYPE:
				case BUFFERS:
				case BYPASSRLS:
				case CANONICAL:
				case CATEGORY:
				case COLLATABLE:
				case COMBINEFUNC:
				case COMMUTATOR:
				case CONNECT:
				case COSTS:
				case CREATEDB:
				case CREATEROLE:
				case DESERIALFUNC:
				case DETERMINISTIC:
				case DISABLE_PAGE_SKIPPING:
				case ELEMENT:
				case EXTENDED:
				case FINALFUNC:
				case FINALFUNC_EXTRA:
				case FINALFUNC_MODIFY:
				case FORCE_NOT_NULL:
				case FORCE_NULL:
				case FORCE_QUOTE:
				case FORMAT:
				case GETTOKEN:
				case HASH:
				case HASHES:
				case HEADLINE:
				case HYPOTHETICAL:
				case INDEX_CLEANUP:
				case INIT:
				case INITCOND:
				case INTERNALLENGTH:
				case JSON:
				case LC_COLLATE:
				case LC_CTYPE:
				case LEFTARG:
				case LEXIZE:
				case LEXTYPES:
				case LIST:
				case LOCALE:
				case LOGIN:
				case MAIN:
				case MERGES:
				case MFINALFUNC:
				case MFINALFUNC_EXTRA:
				case MFINALFUNC_MODIFY:
				case MINITCOND:
				case MINVFUNC:
				case MODULUS:
				case MSFUNC:
				case MSSPACE:
				case MSTYPE:
				case NEGATOR:
				case NOBYPASSRLS:
				case NOCREATEDB:
				case NOCREATEROLE:
				case NOINHERIT:
				case NOLOGIN:
				case NOREPLICATION:
				case NOSUPERUSER:
				case OUTPUT:
				case PASSEDBYVALUE:
				case PATH:
				case PERMISSIVE:
				case PLAIN:
				case PREFERRED:
				case PROVIDER:
				case READ_ONLY:
				case READ_WRITE:
				case RECEIVE:
				case REMAINDER:
				case REPLICATION:
				case RESTRICTED:
				case RESTRICTIVE:
				case RIGHTARG:
				case SAFE:
				case SEND:
				case SERIALFUNC:
				case SETTINGS:
				case SFUNC:
				case SHAREABLE:
				case SKIP_LOCKED:
				case SORTOP:
				case SSPACE:
				case STYPE:
				case SUBTYPE_DIFF:
				case SUBTYPE_OPCLASS:
				case SUBTYPE:
				case SUMMARY:
				case SUPERUSER:
				case TIMING:
				case TYPMOD_IN:
				case TYPMOD_OUT:
				case UNSAFE:
				case USAGE:
				case VARIABLE:
				case YAML:
				case ALIAS:
				case ASSERT:
				case CONSTANT:
				case DATATYPE:
				case DEBUG:
				case DETAIL:
				case DIAGNOSTICS:
				case ELSEIF:
				case ELSIF:
				case ERRCODE:
				case EXIT:
				case EXCEPTION:
				case FOREACH:
				case GET:
				case HINT:
				case INFO:
				case LOG:
				case LOOP:
				case MESSAGE:
				case NOTICE:
				case OPEN:
				case PERFORM:
				case QUERY:
				case RAISE:
				case RECORD:
				case RETURN:
				case REVERSE:
				case ROWTYPE:
				case SLICE:
				case SQLSTATE:
				case STACKED:
				case WARNING:
				case WHILE:
				case Identifier:
				case QuotedIdentifier:
					{
					State = 2700; identifier();
					}
					break;
				case ALL:
					{
					State = 2701; Match(ALL);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case REINDEX:
				EnterOuterAlt(_localctx, 9);
				{
				State = 2704; Match(REINDEX);
				State = 2708;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LEFT_PAREN) {
					{
					State = 2705; Match(LEFT_PAREN);
					State = 2706; Match(VERBOSE);
					State = 2707; Match(RIGHT_PAREN);
					}
				}

				State = 2710;
				_la = TokenStream.LA(1);
				if ( !(_la==DATABASE || _la==INDEX || _la==SCHEMA || _la==SYSTEM || _la==TABLE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 2712;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==CONCURRENTLY) {
					{
					State = 2711; Match(CONCURRENTLY);
					}
				}

				State = 2714; schema_qualified_name();
				}
				break;
			case RESET:
				EnterOuterAlt(_localctx, 10);
				{
				State = 2715; Match(RESET);
				State = 2727;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,415,Context) ) {
				case 1:
					{
					State = 2719;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,414,Context) ) {
					case 1:
						{
						State = 2716; identifier();
						State = 2717; Match(DOT);
						}
						break;
					}
					State = 2721; identifier();
					}
					break;
				case 2:
					{
					State = 2722; Match(TIME);
					State = 2723; Match(ZONE);
					}
					break;
				case 3:
					{
					State = 2724; Match(SESSION);
					State = 2725; Match(AUTHORIZATION);
					}
					break;
				case 4:
					{
					State = 2726; Match(ALL);
					}
					break;
				}
				}
				break;
			case EXPLAIN:
				EnterOuterAlt(_localctx, 11);
				{
				State = 2729; explain_statement();
				}
				break;
			case REFRESH:
				EnterOuterAlt(_localctx, 12);
				{
				State = 2730; Match(REFRESH);
				State = 2731; Match(MATERIALIZED);
				State = 2732; Match(VIEW);
				State = 2734;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==CONCURRENTLY) {
					{
					State = 2733; Match(CONCURRENTLY);
					}
				}

				State = 2736; schema_qualified_name();
				State = 2742;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,418,Context) ) {
				case 1:
					{
					State = 2737; Match(WITH);
					State = 2739;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==NO) {
						{
						State = 2738; Match(NO);
						}
					}

					State = 2741; Match(DATA);
					}
					break;
				}
				}
				break;
			case PREPARE:
				EnterOuterAlt(_localctx, 13);
				{
				State = 2744; Match(PREPARE);
				State = 2745; identifier();
				State = 2757;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LEFT_PAREN) {
					{
					State = 2746; Match(LEFT_PAREN);
					State = 2747; data_type();
					State = 2752;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					while (_la==COMMA) {
						{
						{
						State = 2748; Match(COMMA);
						State = 2749; data_type();
						}
						}
						State = 2754;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					}
					State = 2755; Match(RIGHT_PAREN);
					}
				}

				State = 2759; Match(AS);
				State = 2760; data_statement();
				}
				break;
			case REASSIGN:
				EnterOuterAlt(_localctx, 14);
				{
				State = 2762; Match(REASSIGN);
				State = 2763; Match(OWNED);
				State = 2764; Match(BY);
				State = 2765; user_name();
				State = 2770;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 2766; Match(COMMA);
					State = 2767; user_name();
					}
					}
					State = 2772;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 2773; Match(TO);
				State = 2774; user_name();
				}
				break;
			case COPY:
				EnterOuterAlt(_localctx, 15);
				{
				State = 2776; copy_statement();
				}
				break;
			case SHOW:
				EnterOuterAlt(_localctx, 16);
				{
				State = 2777; show_statement();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Copy_statementContext : ParserRuleContext {
		public Copy_to_statementContext copy_to_statement() {
			return GetRuleContext<Copy_to_statementContext>(0);
		}
		public Copy_from_statementContext copy_from_statement() {
			return GetRuleContext<Copy_from_statementContext>(0);
		}
		public Copy_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_copy_statement; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCopy_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Copy_statementContext copy_statement() {
		Copy_statementContext _localctx = new Copy_statementContext(Context, State);
		EnterRule(_localctx, 262, RULE_copy_statement);
		try {
			State = 2782;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,423,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2780; copy_to_statement();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2781; copy_from_statement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Copy_from_statementContext : ParserRuleContext {
		public ITerminalNode COPY() { return GetToken(PlPgSqlParser.COPY, 0); }
		public Table_colsContext table_cols() {
			return GetRuleContext<Table_colsContext>(0);
		}
		public ITerminalNode FROM() { return GetToken(PlPgSqlParser.FROM, 0); }
		public ITerminalNode Character_String_Literal() { return GetToken(PlPgSqlParser.Character_String_Literal, 0); }
		public ITerminalNode STDIN() { return GetToken(PlPgSqlParser.STDIN, 0); }
		public ITerminalNode WHERE() { return GetToken(PlPgSqlParser.WHERE, 0); }
		public VexContext vex() {
			return GetRuleContext<VexContext>(0);
		}
		public ITerminalNode PROGRAM() { return GetToken(PlPgSqlParser.PROGRAM, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlPgSqlParser.LEFT_PAREN, 0); }
		public Copy_option_listContext copy_option_list() {
			return GetRuleContext<Copy_option_listContext>(0);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlPgSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode WITH() { return GetToken(PlPgSqlParser.WITH, 0); }
		public Copy_from_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_copy_from_statement; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCopy_from_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Copy_from_statementContext copy_from_statement() {
		Copy_from_statementContext _localctx = new Copy_from_statementContext(Context, State);
		EnterRule(_localctx, 264, RULE_copy_from_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2784; Match(COPY);
			State = 2785; table_cols();
			State = 2786; Match(FROM);
			State = 2792;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case PROGRAM:
			case Character_String_Literal:
				{
				State = 2788;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==PROGRAM) {
					{
					State = 2787; Match(PROGRAM);
					}
				}

				State = 2790; Match(Character_String_Literal);
				}
				break;
			case STDIN:
				{
				State = 2791; Match(STDIN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2804;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,428,Context) ) {
			case 1:
				{
				State = 2795;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==WITH) {
					{
					State = 2794; Match(WITH);
					}
				}

				State = 2802;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case LEFT_PAREN:
					{
					State = 2797; Match(LEFT_PAREN);
					State = 2798; copy_option_list();
					State = 2799; Match(RIGHT_PAREN);
					}
					break;
				case CSV:
				case DELIMITER:
				case ENCODING:
				case ESCAPE:
				case FORCE:
				case HEADER:
				case OIDS:
				case QUOTE:
				case TEXT:
				case BINARY:
				case FREEZE:
				case NULL:
				case FORCE_NOT_NULL:
				case FORCE_NULL:
				case FORCE_QUOTE:
				case FORMAT:
					{
					State = 2801; copy_option_list();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			}
			State = 2808;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE) {
				{
				State = 2806; Match(WHERE);
				State = 2807; vex(0);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Copy_to_statementContext : ParserRuleContext {
		public ITerminalNode COPY() { return GetToken(PlPgSqlParser.COPY, 0); }
		public ITerminalNode TO() { return GetToken(PlPgSqlParser.TO, 0); }
		public Table_colsContext table_cols() {
			return GetRuleContext<Table_colsContext>(0);
		}
		public ITerminalNode[] LEFT_PAREN() { return GetTokens(PlPgSqlParser.LEFT_PAREN); }
		public ITerminalNode LEFT_PAREN(int i) {
			return GetToken(PlPgSqlParser.LEFT_PAREN, i);
		}
		public ITerminalNode[] RIGHT_PAREN() { return GetTokens(PlPgSqlParser.RIGHT_PAREN); }
		public ITerminalNode RIGHT_PAREN(int i) {
			return GetToken(PlPgSqlParser.RIGHT_PAREN, i);
		}
		public ITerminalNode Character_String_Literal() { return GetToken(PlPgSqlParser.Character_String_Literal, 0); }
		public ITerminalNode STDOUT() { return GetToken(PlPgSqlParser.STDOUT, 0); }
		public Select_stmtContext select_stmt() {
			return GetRuleContext<Select_stmtContext>(0);
		}
		public Insert_stmt_for_psqlContext insert_stmt_for_psql() {
			return GetRuleContext<Insert_stmt_for_psqlContext>(0);
		}
		public Update_stmt_for_psqlContext update_stmt_for_psql() {
			return GetRuleContext<Update_stmt_for_psqlContext>(0);
		}
		public Delete_stmt_for_psqlContext delete_stmt_for_psql() {
			return GetRuleContext<Delete_stmt_for_psqlContext>(0);
		}
		public ITerminalNode PROGRAM() { return GetToken(PlPgSqlParser.PROGRAM, 0); }
		public Copy_option_listContext copy_option_list() {
			return GetRuleContext<Copy_option_listContext>(0);
		}
		public ITerminalNode WITH() { return GetToken(PlPgSqlParser.WITH, 0); }
		public Copy_to_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_copy_to_statement; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCopy_to_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Copy_to_statementContext copy_to_statement() {
		Copy_to_statementContext _localctx = new Copy_to_statementContext(Context, State);
		EnterRule(_localctx, 266, RULE_copy_to_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2810; Match(COPY);
			State = 2821;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ABORT:
			case ABSOLUTE:
			case ACCESS:
			case ACTION:
			case ADD:
			case ADMIN:
			case AFTER:
			case AGGREGATE:
			case ALSO:
			case ALTER:
			case ALWAYS:
			case ASSERTION:
			case ASSIGNMENT:
			case AT:
			case ATTACH:
			case ATTRIBUTE:
			case BACKWARD:
			case BEFORE:
			case BEGIN:
			case BY:
			case CACHE:
			case CALL:
			case CALLED:
			case CASCADE:
			case CASCADED:
			case CATALOG:
			case CHAIN:
			case CHARACTERISTICS:
			case CHECKPOINT:
			case CLASS:
			case CLOSE:
			case CLUSTER:
			case COLUMNS:
			case COMMENT:
			case COMMENTS:
			case COMMIT:
			case COMMITTED:
			case CONFIGURATION:
			case CONFLICT:
			case CONNECTION:
			case CONSTRAINTS:
			case CONTENT:
			case CONTINUE:
			case CONVERSION:
			case COPY:
			case COST:
			case CSV:
			case CUBE:
			case CURRENT:
			case CURSOR:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DAY:
			case DEALLOCATE:
			case DECLARE:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DELIMITER:
			case DELIMITERS:
			case DEPENDS:
			case DETACH:
			case DICTIONARY:
			case DISABLE:
			case DISCARD:
			case DOCUMENT:
			case DOMAIN:
			case DOUBLE:
			case DROP:
			case EACH:
			case ENABLE:
			case ENCODING:
			case ENCRYPTED:
			case ENUM:
			case ESCAPE:
			case EVENT:
			case EXCLUDE:
			case EXCLUDING:
			case EXCLUSIVE:
			case EXECUTE:
			case EXPLAIN:
			case EXTENSION:
			case EXTERNAL:
			case FAMILY:
			case FILTER:
			case FIRST:
			case FOLLOWING:
			case FORCE:
			case FORWARD:
			case FUNCTION:
			case FUNCTIONS:
			case GENERATED:
			case GLOBAL:
			case GRANTED:
			case GROUPS:
			case HANDLER:
			case HEADER:
			case HOLD:
			case HOUR:
			case IDENTITY:
			case IF:
			case IMMEDIATE:
			case IMMUTABLE:
			case IMPLICIT:
			case IMPORT:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDEX:
			case INDEXES:
			case INHERIT:
			case INHERITS:
			case INLINE:
			case INPUT:
			case INSENSITIVE:
			case INSERT:
			case INSTEAD:
			case INVOKER:
			case ISOLATION:
			case KEY:
			case LABEL:
			case LANGUAGE:
			case LARGE:
			case LAST:
			case LEAKPROOF:
			case LEVEL:
			case LISTEN:
			case LOAD:
			case LOCAL:
			case LOCATION:
			case LOCK:
			case LOCKED:
			case LOGGED:
			case MAPPING:
			case MATCH:
			case MATERIALIZED:
			case MAXVALUE:
			case METHOD:
			case MINUTE:
			case MINVALUE:
			case MODE:
			case MONTH:
			case MOVE:
			case NAME:
			case NAMES:
			case NEW:
			case NEXT:
			case NO:
			case NOTHING:
			case NOTIFY:
			case NOWAIT:
			case NULLS:
			case OBJECT:
			case OF:
			case OFF:
			case OIDS:
			case OLD:
			case OPERATOR:
			case OPTION:
			case OPTIONS:
			case ORDINALITY:
			case OTHERS:
			case OVER:
			case OVERRIDING:
			case OWNED:
			case OWNER:
			case PARALLEL:
			case PARSER:
			case PARTIAL:
			case PARTITION:
			case PASSING:
			case PASSWORD:
			case PLANS:
			case POLICY:
			case PRECEDING:
			case PREPARE:
			case PREPARED:
			case PRESERVE:
			case PRIOR:
			case PRIVILEGES:
			case PROCEDURAL:
			case PROCEDURE:
			case PROCEDURES:
			case PROGRAM:
			case PUBLICATION:
			case QUOTE:
			case RANGE:
			case READ:
			case REASSIGN:
			case RECHECK:
			case RECURSIVE:
			case REF:
			case REFERENCING:
			case REFRESH:
			case REINDEX:
			case RELATIVE:
			case RELEASE:
			case RENAME:
			case REPEATABLE:
			case REPLACE:
			case REPLICA:
			case RESET:
			case RESTART:
			case RESTRICT:
			case RETURNS:
			case REVOKE:
			case ROLE:
			case ROLLBACK:
			case ROLLUP:
			case ROUTINE:
			case ROUTINES:
			case ROWS:
			case RULE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMAS:
			case SCROLL:
			case SEARCH:
			case SECOND:
			case SECURITY:
			case SEQUENCE:
			case SEQUENCES:
			case SERIALIZABLE:
			case SERVER:
			case SESSION:
			case SET:
			case SETS:
			case SHARE:
			case SHOW:
			case SIMPLE:
			case SKIP_:
			case SNAPSHOT:
			case SQL:
			case STABLE:
			case STANDALONE:
			case START:
			case STATEMENT:
			case STATISTICS:
			case STDIN:
			case STDOUT:
			case STORAGE:
			case STORED:
			case STRICT:
			case STRIP:
			case SUBSCRIPTION:
			case SUPPORT:
			case SYSID:
			case SYSTEM:
			case TABLES:
			case TABLESPACE:
			case TEMP:
			case TEMPLATE:
			case TEMPORARY:
			case TEXT:
			case TIES:
			case TRANSACTION:
			case TRANSFORM:
			case TRIGGER:
			case TRUNCATE:
			case TRUSTED:
			case TYPE:
			case TYPES:
			case UNBOUNDED:
			case UNCOMMITTED:
			case UNENCRYPTED:
			case UNKNOWN:
			case UNLISTEN:
			case UNLOGGED:
			case UNTIL:
			case UPDATE:
			case VACUUM:
			case VALID:
			case VALIDATE:
			case VALIDATOR:
			case VALUE:
			case VARYING:
			case VERSION:
			case VIEW:
			case VIEWS:
			case VOLATILE:
			case WHITESPACE:
			case WITHIN:
			case WITHOUT:
			case WORK:
			case WRAPPER:
			case WRITE:
			case XML:
			case YEAR:
			case YES:
			case ZONE:
			case BETWEEN:
			case BIGINT:
			case BIT:
			case BOOLEAN:
			case CHAR:
			case CHARACTER:
			case COALESCE:
			case DEC:
			case DECIMAL:
			case EXISTS:
			case EXTRACT:
			case FLOAT:
			case GREATEST:
			case GROUPING:
			case INOUT:
			case INT:
			case INTEGER:
			case INTERVAL:
			case LEAST:
			case NATIONAL:
			case NCHAR:
			case NONE:
			case NULLIF:
			case NUMERIC:
			case OUT:
			case OVERLAY:
			case POSITION:
			case PRECISION:
			case REAL:
			case ROW:
			case SETOF:
			case SMALLINT:
			case SUBSTRING:
			case TIME:
			case TIMESTAMP:
			case TREAT:
			case TRIM:
			case VALUES:
			case VARCHAR:
			case XMLATTRIBUTES:
			case XMLCONCAT:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case ALIGNMENT:
			case BASETYPE:
			case BUFFERS:
			case BYPASSRLS:
			case CANONICAL:
			case CATEGORY:
			case COLLATABLE:
			case COMBINEFUNC:
			case COMMUTATOR:
			case CONNECT:
			case COSTS:
			case CREATEDB:
			case CREATEROLE:
			case DESERIALFUNC:
			case DETERMINISTIC:
			case DISABLE_PAGE_SKIPPING:
			case ELEMENT:
			case EXTENDED:
			case FINALFUNC:
			case FINALFUNC_EXTRA:
			case FINALFUNC_MODIFY:
			case FORCE_NOT_NULL:
			case FORCE_NULL:
			case FORCE_QUOTE:
			case FORMAT:
			case GETTOKEN:
			case HASH:
			case HASHES:
			case HEADLINE:
			case HYPOTHETICAL:
			case INDEX_CLEANUP:
			case INIT:
			case INITCOND:
			case INTERNALLENGTH:
			case JSON:
			case LC_COLLATE:
			case LC_CTYPE:
			case LEFTARG:
			case LEXIZE:
			case LEXTYPES:
			case LIST:
			case LOCALE:
			case LOGIN:
			case MAIN:
			case MERGES:
			case MFINALFUNC:
			case MFINALFUNC_EXTRA:
			case MFINALFUNC_MODIFY:
			case MINITCOND:
			case MINVFUNC:
			case MODULUS:
			case MSFUNC:
			case MSSPACE:
			case MSTYPE:
			case NEGATOR:
			case NOBYPASSRLS:
			case NOCREATEDB:
			case NOCREATEROLE:
			case NOINHERIT:
			case NOLOGIN:
			case NOREPLICATION:
			case NOSUPERUSER:
			case OUTPUT:
			case PASSEDBYVALUE:
			case PATH:
			case PERMISSIVE:
			case PLAIN:
			case PREFERRED:
			case PROVIDER:
			case READ_ONLY:
			case READ_WRITE:
			case RECEIVE:
			case REMAINDER:
			case REPLICATION:
			case RESTRICTED:
			case RESTRICTIVE:
			case RIGHTARG:
			case SAFE:
			case SEND:
			case SERIALFUNC:
			case SETTINGS:
			case SFUNC:
			case SHAREABLE:
			case SKIP_LOCKED:
			case SORTOP:
			case SSPACE:
			case STYPE:
			case SUBTYPE_DIFF:
			case SUBTYPE_OPCLASS:
			case SUBTYPE:
			case SUMMARY:
			case SUPERUSER:
			case TIMING:
			case TYPMOD_IN:
			case TYPMOD_OUT:
			case UNSAFE:
			case USAGE:
			case VARIABLE:
			case YAML:
			case ALIAS:
			case ASSERT:
			case CONSTANT:
			case DATATYPE:
			case DEBUG:
			case DETAIL:
			case DIAGNOSTICS:
			case ELSEIF:
			case ELSIF:
			case ERRCODE:
			case EXIT:
			case EXCEPTION:
			case FOREACH:
			case GET:
			case HINT:
			case INFO:
			case LOG:
			case LOOP:
			case MESSAGE:
			case NOTICE:
			case OPEN:
			case PERFORM:
			case QUERY:
			case RAISE:
			case RECORD:
			case RETURN:
			case REVERSE:
			case ROWTYPE:
			case SLICE:
			case SQLSTATE:
			case STACKED:
			case WARNING:
			case WHILE:
			case Identifier:
			case QuotedIdentifier:
				{
				State = 2811; table_cols();
				}
				break;
			case LEFT_PAREN:
				{
				State = 2812; Match(LEFT_PAREN);
				State = 2817;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,430,Context) ) {
				case 1:
					{
					State = 2813; select_stmt();
					}
					break;
				case 2:
					{
					State = 2814; insert_stmt_for_psql();
					}
					break;
				case 3:
					{
					State = 2815; update_stmt_for_psql();
					}
					break;
				case 4:
					{
					State = 2816; delete_stmt_for_psql();
					}
					break;
				}
				State = 2819; Match(RIGHT_PAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2823; Match(TO);
			State = 2829;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case PROGRAM:
			case Character_String_Literal:
				{
				State = 2825;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==PROGRAM) {
					{
					State = 2824; Match(PROGRAM);
					}
				}

				State = 2827; Match(Character_String_Literal);
				}
				break;
			case STDOUT:
				{
				State = 2828; Match(STDOUT);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2841;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,436,Context) ) {
			case 1:
				{
				State = 2832;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==WITH) {
					{
					State = 2831; Match(WITH);
					}
				}

				State = 2839;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case LEFT_PAREN:
					{
					State = 2834; Match(LEFT_PAREN);
					State = 2835; copy_option_list();
					State = 2836; Match(RIGHT_PAREN);
					}
					break;
				case CSV:
				case DELIMITER:
				case ENCODING:
				case ESCAPE:
				case FORCE:
				case HEADER:
				case OIDS:
				case QUOTE:
				case TEXT:
				case BINARY:
				case FREEZE:
				case NULL:
				case FORCE_NOT_NULL:
				case FORCE_NULL:
				case FORCE_QUOTE:
				case FORMAT:
					{
					State = 2838; copy_option_list();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class User_nameContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ITerminalNode CURRENT_USER() { return GetToken(PlPgSqlParser.CURRENT_USER, 0); }
		public ITerminalNode SESSION_USER() { return GetToken(PlPgSqlParser.SESSION_USER, 0); }
		public User_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_user_name; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUser_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public User_nameContext user_name() {
		User_nameContext _localctx = new User_nameContext(Context, State);
		EnterRule(_localctx, 268, RULE_user_name);
		try {
			State = 2846;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ABORT:
			case ABSOLUTE:
			case ACCESS:
			case ACTION:
			case ADD:
			case ADMIN:
			case AFTER:
			case AGGREGATE:
			case ALSO:
			case ALTER:
			case ALWAYS:
			case ASSERTION:
			case ASSIGNMENT:
			case AT:
			case ATTACH:
			case ATTRIBUTE:
			case BACKWARD:
			case BEFORE:
			case BEGIN:
			case BY:
			case CACHE:
			case CALL:
			case CALLED:
			case CASCADE:
			case CASCADED:
			case CATALOG:
			case CHAIN:
			case CHARACTERISTICS:
			case CHECKPOINT:
			case CLASS:
			case CLOSE:
			case CLUSTER:
			case COLUMNS:
			case COMMENT:
			case COMMENTS:
			case COMMIT:
			case COMMITTED:
			case CONFIGURATION:
			case CONFLICT:
			case CONNECTION:
			case CONSTRAINTS:
			case CONTENT:
			case CONTINUE:
			case CONVERSION:
			case COPY:
			case COST:
			case CSV:
			case CUBE:
			case CURRENT:
			case CURSOR:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DAY:
			case DEALLOCATE:
			case DECLARE:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DELIMITER:
			case DELIMITERS:
			case DEPENDS:
			case DETACH:
			case DICTIONARY:
			case DISABLE:
			case DISCARD:
			case DOCUMENT:
			case DOMAIN:
			case DOUBLE:
			case DROP:
			case EACH:
			case ENABLE:
			case ENCODING:
			case ENCRYPTED:
			case ENUM:
			case ESCAPE:
			case EVENT:
			case EXCLUDE:
			case EXCLUDING:
			case EXCLUSIVE:
			case EXECUTE:
			case EXPLAIN:
			case EXTENSION:
			case EXTERNAL:
			case FAMILY:
			case FILTER:
			case FIRST:
			case FOLLOWING:
			case FORCE:
			case FORWARD:
			case FUNCTION:
			case FUNCTIONS:
			case GENERATED:
			case GLOBAL:
			case GRANTED:
			case GROUPS:
			case HANDLER:
			case HEADER:
			case HOLD:
			case HOUR:
			case IDENTITY:
			case IF:
			case IMMEDIATE:
			case IMMUTABLE:
			case IMPLICIT:
			case IMPORT:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDEX:
			case INDEXES:
			case INHERIT:
			case INHERITS:
			case INLINE:
			case INPUT:
			case INSENSITIVE:
			case INSERT:
			case INSTEAD:
			case INVOKER:
			case ISOLATION:
			case KEY:
			case LABEL:
			case LANGUAGE:
			case LARGE:
			case LAST:
			case LEAKPROOF:
			case LEVEL:
			case LISTEN:
			case LOAD:
			case LOCAL:
			case LOCATION:
			case LOCK:
			case LOCKED:
			case LOGGED:
			case MAPPING:
			case MATCH:
			case MATERIALIZED:
			case MAXVALUE:
			case METHOD:
			case MINUTE:
			case MINVALUE:
			case MODE:
			case MONTH:
			case MOVE:
			case NAME:
			case NAMES:
			case NEW:
			case NEXT:
			case NO:
			case NOTHING:
			case NOTIFY:
			case NOWAIT:
			case NULLS:
			case OBJECT:
			case OF:
			case OFF:
			case OIDS:
			case OLD:
			case OPERATOR:
			case OPTION:
			case OPTIONS:
			case ORDINALITY:
			case OTHERS:
			case OVER:
			case OVERRIDING:
			case OWNED:
			case OWNER:
			case PARALLEL:
			case PARSER:
			case PARTIAL:
			case PARTITION:
			case PASSING:
			case PASSWORD:
			case PLANS:
			case POLICY:
			case PRECEDING:
			case PREPARE:
			case PREPARED:
			case PRESERVE:
			case PRIOR:
			case PRIVILEGES:
			case PROCEDURAL:
			case PROCEDURE:
			case PROCEDURES:
			case PROGRAM:
			case PUBLICATION:
			case QUOTE:
			case RANGE:
			case READ:
			case REASSIGN:
			case RECHECK:
			case RECURSIVE:
			case REF:
			case REFERENCING:
			case REFRESH:
			case REINDEX:
			case RELATIVE:
			case RELEASE:
			case RENAME:
			case REPEATABLE:
			case REPLACE:
			case REPLICA:
			case RESET:
			case RESTART:
			case RESTRICT:
			case RETURNS:
			case REVOKE:
			case ROLE:
			case ROLLBACK:
			case ROLLUP:
			case ROUTINE:
			case ROUTINES:
			case ROWS:
			case RULE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMAS:
			case SCROLL:
			case SEARCH:
			case SECOND:
			case SECURITY:
			case SEQUENCE:
			case SEQUENCES:
			case SERIALIZABLE:
			case SERVER:
			case SESSION:
			case SET:
			case SETS:
			case SHARE:
			case SHOW:
			case SIMPLE:
			case SKIP_:
			case SNAPSHOT:
			case SQL:
			case STABLE:
			case STANDALONE:
			case START:
			case STATEMENT:
			case STATISTICS:
			case STDIN:
			case STDOUT:
			case STORAGE:
			case STORED:
			case STRICT:
			case STRIP:
			case SUBSCRIPTION:
			case SUPPORT:
			case SYSID:
			case SYSTEM:
			case TABLES:
			case TABLESPACE:
			case TEMP:
			case TEMPLATE:
			case TEMPORARY:
			case TEXT:
			case TIES:
			case TRANSACTION:
			case TRANSFORM:
			case TRIGGER:
			case TRUNCATE:
			case TRUSTED:
			case TYPE:
			case TYPES:
			case UNBOUNDED:
			case UNCOMMITTED:
			case UNENCRYPTED:
			case UNKNOWN:
			case UNLISTEN:
			case UNLOGGED:
			case UNTIL:
			case UPDATE:
			case VACUUM:
			case VALID:
			case VALIDATE:
			case VALIDATOR:
			case VALUE:
			case VARYING:
			case VERSION:
			case VIEW:
			case VIEWS:
			case VOLATILE:
			case WHITESPACE:
			case WITHIN:
			case WITHOUT:
			case WORK:
			case WRAPPER:
			case WRITE:
			case XML:
			case YEAR:
			case YES:
			case ZONE:
			case BETWEEN:
			case BIGINT:
			case BIT:
			case BOOLEAN:
			case CHAR:
			case CHARACTER:
			case COALESCE:
			case DEC:
			case DECIMAL:
			case EXISTS:
			case EXTRACT:
			case FLOAT:
			case GREATEST:
			case GROUPING:
			case INOUT:
			case INT:
			case INTEGER:
			case INTERVAL:
			case LEAST:
			case NATIONAL:
			case NCHAR:
			case NONE:
			case NULLIF:
			case NUMERIC:
			case OUT:
			case OVERLAY:
			case POSITION:
			case PRECISION:
			case REAL:
			case ROW:
			case SETOF:
			case SMALLINT:
			case SUBSTRING:
			case TIME:
			case TIMESTAMP:
			case TREAT:
			case TRIM:
			case VALUES:
			case VARCHAR:
			case XMLATTRIBUTES:
			case XMLCONCAT:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case ALIGNMENT:
			case BASETYPE:
			case BUFFERS:
			case BYPASSRLS:
			case CANONICAL:
			case CATEGORY:
			case COLLATABLE:
			case COMBINEFUNC:
			case COMMUTATOR:
			case CONNECT:
			case COSTS:
			case CREATEDB:
			case CREATEROLE:
			case DESERIALFUNC:
			case DETERMINISTIC:
			case DISABLE_PAGE_SKIPPING:
			case ELEMENT:
			case EXTENDED:
			case FINALFUNC:
			case FINALFUNC_EXTRA:
			case FINALFUNC_MODIFY:
			case FORCE_NOT_NULL:
			case FORCE_NULL:
			case FORCE_QUOTE:
			case FORMAT:
			case GETTOKEN:
			case HASH:
			case HASHES:
			case HEADLINE:
			case HYPOTHETICAL:
			case INDEX_CLEANUP:
			case INIT:
			case INITCOND:
			case INTERNALLENGTH:
			case JSON:
			case LC_COLLATE:
			case LC_CTYPE:
			case LEFTARG:
			case LEXIZE:
			case LEXTYPES:
			case LIST:
			case LOCALE:
			case LOGIN:
			case MAIN:
			case MERGES:
			case MFINALFUNC:
			case MFINALFUNC_EXTRA:
			case MFINALFUNC_MODIFY:
			case MINITCOND:
			case MINVFUNC:
			case MODULUS:
			case MSFUNC:
			case MSSPACE:
			case MSTYPE:
			case NEGATOR:
			case NOBYPASSRLS:
			case NOCREATEDB:
			case NOCREATEROLE:
			case NOINHERIT:
			case NOLOGIN:
			case NOREPLICATION:
			case NOSUPERUSER:
			case OUTPUT:
			case PASSEDBYVALUE:
			case PATH:
			case PERMISSIVE:
			case PLAIN:
			case PREFERRED:
			case PROVIDER:
			case READ_ONLY:
			case READ_WRITE:
			case RECEIVE:
			case REMAINDER:
			case REPLICATION:
			case RESTRICTED:
			case RESTRICTIVE:
			case RIGHTARG:
			case SAFE:
			case SEND:
			case SERIALFUNC:
			case SETTINGS:
			case SFUNC:
			case SHAREABLE:
			case SKIP_LOCKED:
			case SORTOP:
			case SSPACE:
			case STYPE:
			case SUBTYPE_DIFF:
			case SUBTYPE_OPCLASS:
			case SUBTYPE:
			case SUMMARY:
			case SUPERUSER:
			case TIMING:
			case TYPMOD_IN:
			case TYPMOD_OUT:
			case UNSAFE:
			case USAGE:
			case VARIABLE:
			case YAML:
			case ALIAS:
			case ASSERT:
			case CONSTANT:
			case DATATYPE:
			case DEBUG:
			case DETAIL:
			case DIAGNOSTICS:
			case ELSEIF:
			case ELSIF:
			case ERRCODE:
			case EXIT:
			case EXCEPTION:
			case FOREACH:
			case GET:
			case HINT:
			case INFO:
			case LOG:
			case LOOP:
			case MESSAGE:
			case NOTICE:
			case OPEN:
			case PERFORM:
			case QUERY:
			case RAISE:
			case RECORD:
			case RETURN:
			case REVERSE:
			case ROWTYPE:
			case SLICE:
			case SQLSTATE:
			case STACKED:
			case WARNING:
			case WHILE:
			case Identifier:
			case QuotedIdentifier:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2843; identifier();
				}
				break;
			case CURRENT_USER:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2844; Match(CURRENT_USER);
				}
				break;
			case SESSION_USER:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2845; Match(SESSION_USER);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Copy_option_listContext : ParserRuleContext {
		public Copy_optionContext[] copy_option() {
			return GetRuleContexts<Copy_optionContext>();
		}
		public Copy_optionContext copy_option(int i) {
			return GetRuleContext<Copy_optionContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlPgSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlPgSqlParser.COMMA, i);
		}
		public Copy_option_listContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_copy_option_list; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCopy_option_list(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Copy_option_listContext copy_option_list() {
		Copy_option_listContext _localctx = new Copy_option_listContext(Context, State);
		EnterRule(_localctx, 270, RULE_copy_option_list);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2848; copy_option();
			State = 2855;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,439,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 2850;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==COMMA) {
						{
						State = 2849; Match(COMMA);
						}
					}

					State = 2852; copy_option();
					}
					} 
				}
				State = 2857;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,439,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Copy_optionContext : ParserRuleContext {
		public ITerminalNode TEXT() { return GetToken(PlPgSqlParser.TEXT, 0); }
		public ITerminalNode CSV() { return GetToken(PlPgSqlParser.CSV, 0); }
		public ITerminalNode BINARY() { return GetToken(PlPgSqlParser.BINARY, 0); }
		public ITerminalNode FORMAT() { return GetToken(PlPgSqlParser.FORMAT, 0); }
		public ITerminalNode OIDS() { return GetToken(PlPgSqlParser.OIDS, 0); }
		public Truth_valueContext truth_value() {
			return GetRuleContext<Truth_valueContext>(0);
		}
		public ITerminalNode FREEZE() { return GetToken(PlPgSqlParser.FREEZE, 0); }
		public ITerminalNode DELIMITER() { return GetToken(PlPgSqlParser.DELIMITER, 0); }
		public ITerminalNode Character_String_Literal() { return GetToken(PlPgSqlParser.Character_String_Literal, 0); }
		public ITerminalNode AS() { return GetToken(PlPgSqlParser.AS, 0); }
		public ITerminalNode NULL() { return GetToken(PlPgSqlParser.NULL, 0); }
		public ITerminalNode HEADER() { return GetToken(PlPgSqlParser.HEADER, 0); }
		public ITerminalNode QUOTE() { return GetToken(PlPgSqlParser.QUOTE, 0); }
		public ITerminalNode ESCAPE() { return GetToken(PlPgSqlParser.ESCAPE, 0); }
		public ITerminalNode FORCE() { return GetToken(PlPgSqlParser.FORCE, 0); }
		public ITerminalNode MULTIPLY() { return GetToken(PlPgSqlParser.MULTIPLY, 0); }
		public Identifier_listContext identifier_list() {
			return GetRuleContext<Identifier_listContext>(0);
		}
		public ITerminalNode FORCE_QUOTE() { return GetToken(PlPgSqlParser.FORCE_QUOTE, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlPgSqlParser.LEFT_PAREN, 0); }
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlPgSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode NOT() { return GetToken(PlPgSqlParser.NOT, 0); }
		public ITerminalNode FORCE_NOT_NULL() { return GetToken(PlPgSqlParser.FORCE_NOT_NULL, 0); }
		public ITerminalNode FORCE_NULL() { return GetToken(PlPgSqlParser.FORCE_NULL, 0); }
		public ITerminalNode ENCODING() { return GetToken(PlPgSqlParser.ENCODING, 0); }
		public Copy_optionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_copy_option; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCopy_option(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Copy_optionContext copy_option() {
		Copy_optionContext _localctx = new Copy_optionContext(Context, State);
		EnterRule(_localctx, 272, RULE_copy_option);
		int _la;
		try {
			State = 2918;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,448,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2859;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==FORMAT) {
					{
					State = 2858; Match(FORMAT);
					}
				}

				State = 2861;
				_la = TokenStream.LA(1);
				if ( !(_la==CSV || _la==TEXT || _la==BINARY) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2862; Match(OIDS);
				State = 2864;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (((((_la - 397)) & ~0x3f) == 0 && ((1L << (_la - 397)) & ((1L << (FALSE - 397)) | (1L << (ON - 397)) | (1L << (TRUE - 397)))) != 0)) {
					{
					State = 2863; truth_value();
					}
				}

				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2866; Match(FREEZE);
				State = 2868;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (((((_la - 397)) & ~0x3f) == 0 && ((1L << (_la - 397)) & ((1L << (FALSE - 397)) | (1L << (ON - 397)) | (1L << (TRUE - 397)))) != 0)) {
					{
					State = 2867; truth_value();
					}
				}

				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 2870; Match(DELIMITER);
				State = 2872;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==AS) {
					{
					State = 2871; Match(AS);
					}
				}

				State = 2874; Match(Character_String_Literal);
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 2875; Match(NULL);
				State = 2877;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==AS) {
					{
					State = 2876; Match(AS);
					}
				}

				State = 2879; Match(Character_String_Literal);
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 2880; Match(HEADER);
				State = 2882;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (((((_la - 397)) & ~0x3f) == 0 && ((1L << (_la - 397)) & ((1L << (FALSE - 397)) | (1L << (ON - 397)) | (1L << (TRUE - 397)))) != 0)) {
					{
					State = 2881; truth_value();
					}
				}

				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 2884; Match(QUOTE);
				State = 2885; Match(Character_String_Literal);
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 2886; Match(ESCAPE);
				State = 2887; Match(Character_String_Literal);
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 2888; Match(FORCE);
				State = 2889; Match(QUOTE);
				State = 2892;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case MULTIPLY:
					{
					State = 2890; Match(MULTIPLY);
					}
					break;
				case ABORT:
				case ABSOLUTE:
				case ACCESS:
				case ACTION:
				case ADD:
				case ADMIN:
				case AFTER:
				case AGGREGATE:
				case ALSO:
				case ALTER:
				case ALWAYS:
				case ASSERTION:
				case ASSIGNMENT:
				case AT:
				case ATTACH:
				case ATTRIBUTE:
				case BACKWARD:
				case BEFORE:
				case BEGIN:
				case BY:
				case CACHE:
				case CALL:
				case CALLED:
				case CASCADE:
				case CASCADED:
				case CATALOG:
				case CHAIN:
				case CHARACTERISTICS:
				case CHECKPOINT:
				case CLASS:
				case CLOSE:
				case CLUSTER:
				case COLUMNS:
				case COMMENT:
				case COMMENTS:
				case COMMIT:
				case COMMITTED:
				case CONFIGURATION:
				case CONFLICT:
				case CONNECTION:
				case CONSTRAINTS:
				case CONTENT:
				case CONTINUE:
				case CONVERSION:
				case COPY:
				case COST:
				case CSV:
				case CUBE:
				case CURRENT:
				case CURSOR:
				case CYCLE:
				case DATA:
				case DATABASE:
				case DAY:
				case DEALLOCATE:
				case DECLARE:
				case DEFAULTS:
				case DEFERRED:
				case DEFINER:
				case DELETE:
				case DELIMITER:
				case DELIMITERS:
				case DEPENDS:
				case DETACH:
				case DICTIONARY:
				case DISABLE:
				case DISCARD:
				case DOCUMENT:
				case DOMAIN:
				case DOUBLE:
				case DROP:
				case EACH:
				case ENABLE:
				case ENCODING:
				case ENCRYPTED:
				case ENUM:
				case ESCAPE:
				case EVENT:
				case EXCLUDE:
				case EXCLUDING:
				case EXCLUSIVE:
				case EXECUTE:
				case EXPLAIN:
				case EXTENSION:
				case EXTERNAL:
				case FAMILY:
				case FILTER:
				case FIRST:
				case FOLLOWING:
				case FORCE:
				case FORWARD:
				case FUNCTION:
				case FUNCTIONS:
				case GENERATED:
				case GLOBAL:
				case GRANTED:
				case GROUPS:
				case HANDLER:
				case HEADER:
				case HOLD:
				case HOUR:
				case IDENTITY:
				case IF:
				case IMMEDIATE:
				case IMMUTABLE:
				case IMPLICIT:
				case IMPORT:
				case INCLUDE:
				case INCLUDING:
				case INCREMENT:
				case INDEX:
				case INDEXES:
				case INHERIT:
				case INHERITS:
				case INLINE:
				case INPUT:
				case INSENSITIVE:
				case INSERT:
				case INSTEAD:
				case INVOKER:
				case ISOLATION:
				case KEY:
				case LABEL:
				case LANGUAGE:
				case LARGE:
				case LAST:
				case LEAKPROOF:
				case LEVEL:
				case LISTEN:
				case LOAD:
				case LOCAL:
				case LOCATION:
				case LOCK:
				case LOCKED:
				case LOGGED:
				case MAPPING:
				case MATCH:
				case MATERIALIZED:
				case MAXVALUE:
				case METHOD:
				case MINUTE:
				case MINVALUE:
				case MODE:
				case MONTH:
				case MOVE:
				case NAME:
				case NAMES:
				case NEW:
				case NEXT:
				case NO:
				case NOTHING:
				case NOTIFY:
				case NOWAIT:
				case NULLS:
				case OBJECT:
				case OF:
				case OFF:
				case OIDS:
				case OLD:
				case OPERATOR:
				case OPTION:
				case OPTIONS:
				case ORDINALITY:
				case OTHERS:
				case OVER:
				case OVERRIDING:
				case OWNED:
				case OWNER:
				case PARALLEL:
				case PARSER:
				case PARTIAL:
				case PARTITION:
				case PASSING:
				case PASSWORD:
				case PLANS:
				case POLICY:
				case PRECEDING:
				case PREPARE:
				case PREPARED:
				case PRESERVE:
				case PRIOR:
				case PRIVILEGES:
				case PROCEDURAL:
				case PROCEDURE:
				case PROCEDURES:
				case PROGRAM:
				case PUBLICATION:
				case QUOTE:
				case RANGE:
				case READ:
				case REASSIGN:
				case RECHECK:
				case RECURSIVE:
				case REF:
				case REFERENCING:
				case REFRESH:
				case REINDEX:
				case RELATIVE:
				case RELEASE:
				case RENAME:
				case REPEATABLE:
				case REPLACE:
				case REPLICA:
				case RESET:
				case RESTART:
				case RESTRICT:
				case RETURNS:
				case REVOKE:
				case ROLE:
				case ROLLBACK:
				case ROLLUP:
				case ROUTINE:
				case ROUTINES:
				case ROWS:
				case RULE:
				case SAVEPOINT:
				case SCHEMA:
				case SCHEMAS:
				case SCROLL:
				case SEARCH:
				case SECOND:
				case SECURITY:
				case SEQUENCE:
				case SEQUENCES:
				case SERIALIZABLE:
				case SERVER:
				case SESSION:
				case SET:
				case SETS:
				case SHARE:
				case SHOW:
				case SIMPLE:
				case SKIP_:
				case SNAPSHOT:
				case SQL:
				case STABLE:
				case STANDALONE:
				case START:
				case STATEMENT:
				case STATISTICS:
				case STDIN:
				case STDOUT:
				case STORAGE:
				case STORED:
				case STRICT:
				case STRIP:
				case SUBSCRIPTION:
				case SUPPORT:
				case SYSID:
				case SYSTEM:
				case TABLES:
				case TABLESPACE:
				case TEMP:
				case TEMPLATE:
				case TEMPORARY:
				case TEXT:
				case TIES:
				case TRANSACTION:
				case TRANSFORM:
				case TRIGGER:
				case TRUNCATE:
				case TRUSTED:
				case TYPE:
				case TYPES:
				case UNBOUNDED:
				case UNCOMMITTED:
				case UNENCRYPTED:
				case UNKNOWN:
				case UNLISTEN:
				case UNLOGGED:
				case UNTIL:
				case UPDATE:
				case VACUUM:
				case VALID:
				case VALIDATE:
				case VALIDATOR:
				case VALUE:
				case VARYING:
				case VERSION:
				case VIEW:
				case VIEWS:
				case VOLATILE:
				case WHITESPACE:
				case WITHIN:
				case WITHOUT:
				case WORK:
				case WRAPPER:
				case WRITE:
				case XML:
				case YEAR:
				case YES:
				case ZONE:
				case BETWEEN:
				case BIGINT:
				case BIT:
				case BOOLEAN:
				case CHAR:
				case CHARACTER:
				case COALESCE:
				case DEC:
				case DECIMAL:
				case EXISTS:
				case EXTRACT:
				case FLOAT:
				case GREATEST:
				case GROUPING:
				case INOUT:
				case INT:
				case INTEGER:
				case INTERVAL:
				case LEAST:
				case NATIONAL:
				case NCHAR:
				case NONE:
				case NULLIF:
				case NUMERIC:
				case OUT:
				case OVERLAY:
				case POSITION:
				case PRECISION:
				case REAL:
				case ROW:
				case SETOF:
				case SMALLINT:
				case SUBSTRING:
				case TIME:
				case TIMESTAMP:
				case TREAT:
				case TRIM:
				case VALUES:
				case VARCHAR:
				case XMLATTRIBUTES:
				case XMLCONCAT:
				case XMLELEMENT:
				case XMLEXISTS:
				case XMLFOREST:
				case XMLNAMESPACES:
				case XMLPARSE:
				case XMLPI:
				case XMLROOT:
				case XMLSERIALIZE:
				case XMLTABLE:
				case ALIGNMENT:
				case BASETYPE:
				case BUFFERS:
				case BYPASSRLS:
				case CANONICAL:
				case CATEGORY:
				case COLLATABLE:
				case COMBINEFUNC:
				case COMMUTATOR:
				case CONNECT:
				case COSTS:
				case CREATEDB:
				case CREATEROLE:
				case DESERIALFUNC:
				case DETERMINISTIC:
				case DISABLE_PAGE_SKIPPING:
				case ELEMENT:
				case EXTENDED:
				case FINALFUNC:
				case FINALFUNC_EXTRA:
				case FINALFUNC_MODIFY:
				case FORCE_NOT_NULL:
				case FORCE_NULL:
				case FORCE_QUOTE:
				case FORMAT:
				case GETTOKEN:
				case HASH:
				case HASHES:
				case HEADLINE:
				case HYPOTHETICAL:
				case INDEX_CLEANUP:
				case INIT:
				case INITCOND:
				case INTERNALLENGTH:
				case JSON:
				case LC_COLLATE:
				case LC_CTYPE:
				case LEFTARG:
				case LEXIZE:
				case LEXTYPES:
				case LIST:
				case LOCALE:
				case LOGIN:
				case MAIN:
				case MERGES:
				case MFINALFUNC:
				case MFINALFUNC_EXTRA:
				case MFINALFUNC_MODIFY:
				case MINITCOND:
				case MINVFUNC:
				case MODULUS:
				case MSFUNC:
				case MSSPACE:
				case MSTYPE:
				case NEGATOR:
				case NOBYPASSRLS:
				case NOCREATEDB:
				case NOCREATEROLE:
				case NOINHERIT:
				case NOLOGIN:
				case NOREPLICATION:
				case NOSUPERUSER:
				case OUTPUT:
				case PASSEDBYVALUE:
				case PATH:
				case PERMISSIVE:
				case PLAIN:
				case PREFERRED:
				case PROVIDER:
				case READ_ONLY:
				case READ_WRITE:
				case RECEIVE:
				case REMAINDER:
				case REPLICATION:
				case RESTRICTED:
				case RESTRICTIVE:
				case RIGHTARG:
				case SAFE:
				case SEND:
				case SERIALFUNC:
				case SETTINGS:
				case SFUNC:
				case SHAREABLE:
				case SKIP_LOCKED:
				case SORTOP:
				case SSPACE:
				case STYPE:
				case SUBTYPE_DIFF:
				case SUBTYPE_OPCLASS:
				case SUBTYPE:
				case SUMMARY:
				case SUPERUSER:
				case TIMING:
				case TYPMOD_IN:
				case TYPMOD_OUT:
				case UNSAFE:
				case USAGE:
				case VARIABLE:
				case YAML:
				case ALIAS:
				case ASSERT:
				case CONSTANT:
				case DATATYPE:
				case DEBUG:
				case DETAIL:
				case DIAGNOSTICS:
				case ELSEIF:
				case ELSIF:
				case ERRCODE:
				case EXIT:
				case EXCEPTION:
				case FOREACH:
				case GET:
				case HINT:
				case INFO:
				case LOG:
				case LOOP:
				case MESSAGE:
				case NOTICE:
				case OPEN:
				case PERFORM:
				case QUERY:
				case RAISE:
				case RECORD:
				case RETURN:
				case REVERSE:
				case ROWTYPE:
				case SLICE:
				case SQLSTATE:
				case STACKED:
				case WARNING:
				case WHILE:
				case Identifier:
				case QuotedIdentifier:
					{
					State = 2891; identifier_list();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case 10:
				EnterOuterAlt(_localctx, 10);
				{
				State = 2894; Match(FORCE_QUOTE);
				State = 2900;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case MULTIPLY:
					{
					State = 2895; Match(MULTIPLY);
					}
					break;
				case LEFT_PAREN:
					{
					State = 2896; Match(LEFT_PAREN);
					State = 2897; identifier_list();
					State = 2898; Match(RIGHT_PAREN);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case 11:
				EnterOuterAlt(_localctx, 11);
				{
				State = 2902; Match(FORCE);
				State = 2903; Match(NOT);
				State = 2904; Match(NULL);
				State = 2905; identifier_list();
				}
				break;
			case 12:
				EnterOuterAlt(_localctx, 12);
				{
				State = 2906; Match(FORCE_NOT_NULL);
				State = 2907; Match(LEFT_PAREN);
				State = 2908; identifier_list();
				State = 2909; Match(RIGHT_PAREN);
				}
				break;
			case 13:
				EnterOuterAlt(_localctx, 13);
				{
				State = 2911; Match(FORCE_NULL);
				State = 2912; Match(LEFT_PAREN);
				State = 2913; identifier_list();
				State = 2914; Match(RIGHT_PAREN);
				}
				break;
			case 14:
				EnterOuterAlt(_localctx, 14);
				{
				State = 2916; Match(ENCODING);
				State = 2917; Match(Character_String_Literal);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Truth_valueContext : ParserRuleContext {
		public ITerminalNode TRUE() { return GetToken(PlPgSqlParser.TRUE, 0); }
		public ITerminalNode FALSE() { return GetToken(PlPgSqlParser.FALSE, 0); }
		public ITerminalNode ON() { return GetToken(PlPgSqlParser.ON, 0); }
		public Truth_valueContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_truth_value; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTruth_value(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Truth_valueContext truth_value() {
		Truth_valueContext _localctx = new Truth_valueContext(Context, State);
		EnterRule(_localctx, 274, RULE_truth_value);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2920;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 397)) & ~0x3f) == 0 && ((1L << (_la - 397)) & ((1L << (FALSE - 397)) | (1L << (ON - 397)) | (1L << (TRUE - 397)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Table_cols_listContext : ParserRuleContext {
		public Table_colsContext[] table_cols() {
			return GetRuleContexts<Table_colsContext>();
		}
		public Table_colsContext table_cols(int i) {
			return GetRuleContext<Table_colsContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlPgSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlPgSqlParser.COMMA, i);
		}
		public Table_cols_listContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_table_cols_list; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTable_cols_list(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Table_cols_listContext table_cols_list() {
		Table_cols_listContext _localctx = new Table_cols_listContext(Context, State);
		EnterRule(_localctx, 276, RULE_table_cols_list);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2922; table_cols();
			State = 2927;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 2923; Match(COMMA);
				State = 2924; table_cols();
				}
				}
				State = 2929;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Table_colsContext : ParserRuleContext {
		public Schema_qualified_nameContext schema_qualified_name() {
			return GetRuleContext<Schema_qualified_nameContext>(0);
		}
		public ITerminalNode LEFT_PAREN() { return GetToken(PlPgSqlParser.LEFT_PAREN, 0); }
		public IdentifierContext[] identifier() {
			return GetRuleContexts<IdentifierContext>();
		}
		public IdentifierContext identifier(int i) {
			return GetRuleContext<IdentifierContext>(i);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlPgSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(PlPgSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlPgSqlParser.COMMA, i);
		}
		public Table_colsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_table_cols; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTable_cols(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Table_colsContext table_cols() {
		Table_colsContext _localctx = new Table_colsContext(Context, State);
		EnterRule(_localctx, 278, RULE_table_cols);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2930; schema_qualified_name();
			State = 2942;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,451,Context) ) {
			case 1:
				{
				State = 2931; Match(LEFT_PAREN);
				State = 2932; identifier();
				State = 2937;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 2933; Match(COMMA);
					State = 2934; identifier();
					}
					}
					State = 2939;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 2940; Match(RIGHT_PAREN);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Anonymous_blockContext : ParserRuleContext {
		public ITerminalNode DO() { return GetToken(PlPgSqlParser.DO, 0); }
		public Character_stringContext[] character_string() {
			return GetRuleContexts<Character_stringContext>();
		}
		public Character_stringContext character_string(int i) {
			return GetRuleContext<Character_stringContext>(i);
		}
		public ITerminalNode LANGUAGE() { return GetToken(PlPgSqlParser.LANGUAGE, 0); }
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Anonymous_blockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_anonymous_block; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAnonymous_block(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Anonymous_blockContext anonymous_block() {
		Anonymous_blockContext _localctx = new Anonymous_blockContext(Context, State);
		EnterRule(_localctx, 280, RULE_anonymous_block);
		int _la;
		try {
			State = 2960;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,455,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2944; Match(DO);
				State = 2950;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LANGUAGE) {
					{
					State = 2945; Match(LANGUAGE);
					State = 2948;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case ABORT:
					case ABSOLUTE:
					case ACCESS:
					case ACTION:
					case ADD:
					case ADMIN:
					case AFTER:
					case AGGREGATE:
					case ALSO:
					case ALTER:
					case ALWAYS:
					case ASSERTION:
					case ASSIGNMENT:
					case AT:
					case ATTACH:
					case ATTRIBUTE:
					case BACKWARD:
					case BEFORE:
					case BEGIN:
					case BY:
					case CACHE:
					case CALL:
					case CALLED:
					case CASCADE:
					case CASCADED:
					case CATALOG:
					case CHAIN:
					case CHARACTERISTICS:
					case CHECKPOINT:
					case CLASS:
					case CLOSE:
					case CLUSTER:
					case COLUMNS:
					case COMMENT:
					case COMMENTS:
					case COMMIT:
					case COMMITTED:
					case CONFIGURATION:
					case CONFLICT:
					case CONNECTION:
					case CONSTRAINTS:
					case CONTENT:
					case CONTINUE:
					case CONVERSION:
					case COPY:
					case COST:
					case CSV:
					case CUBE:
					case CURRENT:
					case CURSOR:
					case CYCLE:
					case DATA:
					case DATABASE:
					case DAY:
					case DEALLOCATE:
					case DECLARE:
					case DEFAULTS:
					case DEFERRED:
					case DEFINER:
					case DELETE:
					case DELIMITER:
					case DELIMITERS:
					case DEPENDS:
					case DETACH:
					case DICTIONARY:
					case DISABLE:
					case DISCARD:
					case DOCUMENT:
					case DOMAIN:
					case DOUBLE:
					case DROP:
					case EACH:
					case ENABLE:
					case ENCODING:
					case ENCRYPTED:
					case ENUM:
					case ESCAPE:
					case EVENT:
					case EXCLUDE:
					case EXCLUDING:
					case EXCLUSIVE:
					case EXECUTE:
					case EXPLAIN:
					case EXTENSION:
					case EXTERNAL:
					case FAMILY:
					case FILTER:
					case FIRST:
					case FOLLOWING:
					case FORCE:
					case FORWARD:
					case FUNCTION:
					case FUNCTIONS:
					case GENERATED:
					case GLOBAL:
					case GRANTED:
					case GROUPS:
					case HANDLER:
					case HEADER:
					case HOLD:
					case HOUR:
					case IDENTITY:
					case IF:
					case IMMEDIATE:
					case IMMUTABLE:
					case IMPLICIT:
					case IMPORT:
					case INCLUDE:
					case INCLUDING:
					case INCREMENT:
					case INDEX:
					case INDEXES:
					case INHERIT:
					case INHERITS:
					case INLINE:
					case INPUT:
					case INSENSITIVE:
					case INSERT:
					case INSTEAD:
					case INVOKER:
					case ISOLATION:
					case KEY:
					case LABEL:
					case LANGUAGE:
					case LARGE:
					case LAST:
					case LEAKPROOF:
					case LEVEL:
					case LISTEN:
					case LOAD:
					case LOCAL:
					case LOCATION:
					case LOCK:
					case LOCKED:
					case LOGGED:
					case MAPPING:
					case MATCH:
					case MATERIALIZED:
					case MAXVALUE:
					case METHOD:
					case MINUTE:
					case MINVALUE:
					case MODE:
					case MONTH:
					case MOVE:
					case NAME:
					case NAMES:
					case NEW:
					case NEXT:
					case NO:
					case NOTHING:
					case NOTIFY:
					case NOWAIT:
					case NULLS:
					case OBJECT:
					case OF:
					case OFF:
					case OIDS:
					case OLD:
					case OPERATOR:
					case OPTION:
					case OPTIONS:
					case ORDINALITY:
					case OTHERS:
					case OVER:
					case OVERRIDING:
					case OWNED:
					case OWNER:
					case PARALLEL:
					case PARSER:
					case PARTIAL:
					case PARTITION:
					case PASSING:
					case PASSWORD:
					case PLANS:
					case POLICY:
					case PRECEDING:
					case PREPARE:
					case PREPARED:
					case PRESERVE:
					case PRIOR:
					case PRIVILEGES:
					case PROCEDURAL:
					case PROCEDURE:
					case PROCEDURES:
					case PROGRAM:
					case PUBLICATION:
					case QUOTE:
					case RANGE:
					case READ:
					case REASSIGN:
					case RECHECK:
					case RECURSIVE:
					case REF:
					case REFERENCING:
					case REFRESH:
					case REINDEX:
					case RELATIVE:
					case RELEASE:
					case RENAME:
					case REPEATABLE:
					case REPLACE:
					case REPLICA:
					case RESET:
					case RESTART:
					case RESTRICT:
					case RETURNS:
					case REVOKE:
					case ROLE:
					case ROLLBACK:
					case ROLLUP:
					case ROUTINE:
					case ROUTINES:
					case ROWS:
					case RULE:
					case SAVEPOINT:
					case SCHEMA:
					case SCHEMAS:
					case SCROLL:
					case SEARCH:
					case SECOND:
					case SECURITY:
					case SEQUENCE:
					case SEQUENCES:
					case SERIALIZABLE:
					case SERVER:
					case SESSION:
					case SET:
					case SETS:
					case SHARE:
					case SHOW:
					case SIMPLE:
					case SKIP_:
					case SNAPSHOT:
					case SQL:
					case STABLE:
					case STANDALONE:
					case START:
					case STATEMENT:
					case STATISTICS:
					case STDIN:
					case STDOUT:
					case STORAGE:
					case STORED:
					case STRICT:
					case STRIP:
					case SUBSCRIPTION:
					case SUPPORT:
					case SYSID:
					case SYSTEM:
					case TABLES:
					case TABLESPACE:
					case TEMP:
					case TEMPLATE:
					case TEMPORARY:
					case TEXT:
					case TIES:
					case TRANSACTION:
					case TRANSFORM:
					case TRIGGER:
					case TRUNCATE:
					case TRUSTED:
					case TYPE:
					case TYPES:
					case UNBOUNDED:
					case UNCOMMITTED:
					case UNENCRYPTED:
					case UNKNOWN:
					case UNLISTEN:
					case UNLOGGED:
					case UNTIL:
					case UPDATE:
					case VACUUM:
					case VALID:
					case VALIDATE:
					case VALIDATOR:
					case VALUE:
					case VARYING:
					case VERSION:
					case VIEW:
					case VIEWS:
					case VOLATILE:
					case WHITESPACE:
					case WITHIN:
					case WITHOUT:
					case WORK:
					case WRAPPER:
					case WRITE:
					case XML:
					case YEAR:
					case YES:
					case ZONE:
					case BETWEEN:
					case BIGINT:
					case BIT:
					case BOOLEAN:
					case CHAR:
					case CHARACTER:
					case COALESCE:
					case DEC:
					case DECIMAL:
					case EXISTS:
					case EXTRACT:
					case FLOAT:
					case GREATEST:
					case GROUPING:
					case INOUT:
					case INT:
					case INTEGER:
					case INTERVAL:
					case LEAST:
					case NATIONAL:
					case NCHAR:
					case NONE:
					case NULLIF:
					case NUMERIC:
					case OUT:
					case OVERLAY:
					case POSITION:
					case PRECISION:
					case REAL:
					case ROW:
					case SETOF:
					case SMALLINT:
					case SUBSTRING:
					case TIME:
					case TIMESTAMP:
					case TREAT:
					case TRIM:
					case VALUES:
					case VARCHAR:
					case XMLATTRIBUTES:
					case XMLCONCAT:
					case XMLELEMENT:
					case XMLEXISTS:
					case XMLFOREST:
					case XMLNAMESPACES:
					case XMLPARSE:
					case XMLPI:
					case XMLROOT:
					case XMLSERIALIZE:
					case XMLTABLE:
					case ALIGNMENT:
					case BASETYPE:
					case BUFFERS:
					case BYPASSRLS:
					case CANONICAL:
					case CATEGORY:
					case COLLATABLE:
					case COMBINEFUNC:
					case COMMUTATOR:
					case CONNECT:
					case COSTS:
					case CREATEDB:
					case CREATEROLE:
					case DESERIALFUNC:
					case DETERMINISTIC:
					case DISABLE_PAGE_SKIPPING:
					case ELEMENT:
					case EXTENDED:
					case FINALFUNC:
					case FINALFUNC_EXTRA:
					case FINALFUNC_MODIFY:
					case FORCE_NOT_NULL:
					case FORCE_NULL:
					case FORCE_QUOTE:
					case FORMAT:
					case GETTOKEN:
					case HASH:
					case HASHES:
					case HEADLINE:
					case HYPOTHETICAL:
					case INDEX_CLEANUP:
					case INIT:
					case INITCOND:
					case INTERNALLENGTH:
					case JSON:
					case LC_COLLATE:
					case LC_CTYPE:
					case LEFTARG:
					case LEXIZE:
					case LEXTYPES:
					case LIST:
					case LOCALE:
					case LOGIN:
					case MAIN:
					case MERGES:
					case MFINALFUNC:
					case MFINALFUNC_EXTRA:
					case MFINALFUNC_MODIFY:
					case MINITCOND:
					case MINVFUNC:
					case MODULUS:
					case MSFUNC:
					case MSSPACE:
					case MSTYPE:
					case NEGATOR:
					case NOBYPASSRLS:
					case NOCREATEDB:
					case NOCREATEROLE:
					case NOINHERIT:
					case NOLOGIN:
					case NOREPLICATION:
					case NOSUPERUSER:
					case OUTPUT:
					case PASSEDBYVALUE:
					case PATH:
					case PERMISSIVE:
					case PLAIN:
					case PREFERRED:
					case PROVIDER:
					case READ_ONLY:
					case READ_WRITE:
					case RECEIVE:
					case REMAINDER:
					case REPLICATION:
					case RESTRICTED:
					case RESTRICTIVE:
					case RIGHTARG:
					case SAFE:
					case SEND:
					case SERIALFUNC:
					case SETTINGS:
					case SFUNC:
					case SHAREABLE:
					case SKIP_LOCKED:
					case SORTOP:
					case SSPACE:
					case STYPE:
					case SUBTYPE_DIFF:
					case SUBTYPE_OPCLASS:
					case SUBTYPE:
					case SUMMARY:
					case SUPERUSER:
					case TIMING:
					case TYPMOD_IN:
					case TYPMOD_OUT:
					case UNSAFE:
					case USAGE:
					case VARIABLE:
					case YAML:
					case ALIAS:
					case ASSERT:
					case CONSTANT:
					case DATATYPE:
					case DEBUG:
					case DETAIL:
					case DIAGNOSTICS:
					case ELSEIF:
					case ELSIF:
					case ERRCODE:
					case EXIT:
					case EXCEPTION:
					case FOREACH:
					case GET:
					case HINT:
					case INFO:
					case LOG:
					case LOOP:
					case MESSAGE:
					case NOTICE:
					case OPEN:
					case PERFORM:
					case QUERY:
					case RAISE:
					case RECORD:
					case RETURN:
					case REVERSE:
					case ROWTYPE:
					case SLICE:
					case SQLSTATE:
					case STACKED:
					case WARNING:
					case WHILE:
					case Identifier:
					case QuotedIdentifier:
						{
						State = 2946; identifier();
						}
						break;
					case Character_String_Literal:
					case BeginDollarStringConstant:
						{
						State = 2947; character_string();
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
				}

				State = 2952; character_string();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2953; Match(DO);
				State = 2954; character_string();
				State = 2955; Match(LANGUAGE);
				State = 2958;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case ABORT:
				case ABSOLUTE:
				case ACCESS:
				case ACTION:
				case ADD:
				case ADMIN:
				case AFTER:
				case AGGREGATE:
				case ALSO:
				case ALTER:
				case ALWAYS:
				case ASSERTION:
				case ASSIGNMENT:
				case AT:
				case ATTACH:
				case ATTRIBUTE:
				case BACKWARD:
				case BEFORE:
				case BEGIN:
				case BY:
				case CACHE:
				case CALL:
				case CALLED:
				case CASCADE:
				case CASCADED:
				case CATALOG:
				case CHAIN:
				case CHARACTERISTICS:
				case CHECKPOINT:
				case CLASS:
				case CLOSE:
				case CLUSTER:
				case COLUMNS:
				case COMMENT:
				case COMMENTS:
				case COMMIT:
				case COMMITTED:
				case CONFIGURATION:
				case CONFLICT:
				case CONNECTION:
				case CONSTRAINTS:
				case CONTENT:
				case CONTINUE:
				case CONVERSION:
				case COPY:
				case COST:
				case CSV:
				case CUBE:
				case CURRENT:
				case CURSOR:
				case CYCLE:
				case DATA:
				case DATABASE:
				case DAY:
				case DEALLOCATE:
				case DECLARE:
				case DEFAULTS:
				case DEFERRED:
				case DEFINER:
				case DELETE:
				case DELIMITER:
				case DELIMITERS:
				case DEPENDS:
				case DETACH:
				case DICTIONARY:
				case DISABLE:
				case DISCARD:
				case DOCUMENT:
				case DOMAIN:
				case DOUBLE:
				case DROP:
				case EACH:
				case ENABLE:
				case ENCODING:
				case ENCRYPTED:
				case ENUM:
				case ESCAPE:
				case EVENT:
				case EXCLUDE:
				case EXCLUDING:
				case EXCLUSIVE:
				case EXECUTE:
				case EXPLAIN:
				case EXTENSION:
				case EXTERNAL:
				case FAMILY:
				case FILTER:
				case FIRST:
				case FOLLOWING:
				case FORCE:
				case FORWARD:
				case FUNCTION:
				case FUNCTIONS:
				case GENERATED:
				case GLOBAL:
				case GRANTED:
				case GROUPS:
				case HANDLER:
				case HEADER:
				case HOLD:
				case HOUR:
				case IDENTITY:
				case IF:
				case IMMEDIATE:
				case IMMUTABLE:
				case IMPLICIT:
				case IMPORT:
				case INCLUDE:
				case INCLUDING:
				case INCREMENT:
				case INDEX:
				case INDEXES:
				case INHERIT:
				case INHERITS:
				case INLINE:
				case INPUT:
				case INSENSITIVE:
				case INSERT:
				case INSTEAD:
				case INVOKER:
				case ISOLATION:
				case KEY:
				case LABEL:
				case LANGUAGE:
				case LARGE:
				case LAST:
				case LEAKPROOF:
				case LEVEL:
				case LISTEN:
				case LOAD:
				case LOCAL:
				case LOCATION:
				case LOCK:
				case LOCKED:
				case LOGGED:
				case MAPPING:
				case MATCH:
				case MATERIALIZED:
				case MAXVALUE:
				case METHOD:
				case MINUTE:
				case MINVALUE:
				case MODE:
				case MONTH:
				case MOVE:
				case NAME:
				case NAMES:
				case NEW:
				case NEXT:
				case NO:
				case NOTHING:
				case NOTIFY:
				case NOWAIT:
				case NULLS:
				case OBJECT:
				case OF:
				case OFF:
				case OIDS:
				case OLD:
				case OPERATOR:
				case OPTION:
				case OPTIONS:
				case ORDINALITY:
				case OTHERS:
				case OVER:
				case OVERRIDING:
				case OWNED:
				case OWNER:
				case PARALLEL:
				case PARSER:
				case PARTIAL:
				case PARTITION:
				case PASSING:
				case PASSWORD:
				case PLANS:
				case POLICY:
				case PRECEDING:
				case PREPARE:
				case PREPARED:
				case PRESERVE:
				case PRIOR:
				case PRIVILEGES:
				case PROCEDURAL:
				case PROCEDURE:
				case PROCEDURES:
				case PROGRAM:
				case PUBLICATION:
				case QUOTE:
				case RANGE:
				case READ:
				case REASSIGN:
				case RECHECK:
				case RECURSIVE:
				case REF:
				case REFERENCING:
				case REFRESH:
				case REINDEX:
				case RELATIVE:
				case RELEASE:
				case RENAME:
				case REPEATABLE:
				case REPLACE:
				case REPLICA:
				case RESET:
				case RESTART:
				case RESTRICT:
				case RETURNS:
				case REVOKE:
				case ROLE:
				case ROLLBACK:
				case ROLLUP:
				case ROUTINE:
				case ROUTINES:
				case ROWS:
				case RULE:
				case SAVEPOINT:
				case SCHEMA:
				case SCHEMAS:
				case SCROLL:
				case SEARCH:
				case SECOND:
				case SECURITY:
				case SEQUENCE:
				case SEQUENCES:
				case SERIALIZABLE:
				case SERVER:
				case SESSION:
				case SET:
				case SETS:
				case SHARE:
				case SHOW:
				case SIMPLE:
				case SKIP_:
				case SNAPSHOT:
				case SQL:
				case STABLE:
				case STANDALONE:
				case START:
				case STATEMENT:
				case STATISTICS:
				case STDIN:
				case STDOUT:
				case STORAGE:
				case STORED:
				case STRICT:
				case STRIP:
				case SUBSCRIPTION:
				case SUPPORT:
				case SYSID:
				case SYSTEM:
				case TABLES:
				case TABLESPACE:
				case TEMP:
				case TEMPLATE:
				case TEMPORARY:
				case TEXT:
				case TIES:
				case TRANSACTION:
				case TRANSFORM:
				case TRIGGER:
				case TRUNCATE:
				case TRUSTED:
				case TYPE:
				case TYPES:
				case UNBOUNDED:
				case UNCOMMITTED:
				case UNENCRYPTED:
				case UNKNOWN:
				case UNLISTEN:
				case UNLOGGED:
				case UNTIL:
				case UPDATE:
				case VACUUM:
				case VALID:
				case VALIDATE:
				case VALIDATOR:
				case VALUE:
				case VARYING:
				case VERSION:
				case VIEW:
				case VIEWS:
				case VOLATILE:
				case WHITESPACE:
				case WITHIN:
				case WITHOUT:
				case WORK:
				case WRAPPER:
				case WRITE:
				case XML:
				case YEAR:
				case YES:
				case ZONE:
				case BETWEEN:
				case BIGINT:
				case BIT:
				case BOOLEAN:
				case CHAR:
				case CHARACTER:
				case COALESCE:
				case DEC:
				case DECIMAL:
				case EXISTS:
				case EXTRACT:
				case FLOAT:
				case GREATEST:
				case GROUPING:
				case INOUT:
				case INT:
				case INTEGER:
				case INTERVAL:
				case LEAST:
				case NATIONAL:
				case NCHAR:
				case NONE:
				case NULLIF:
				case NUMERIC:
				case OUT:
				case OVERLAY:
				case POSITION:
				case PRECISION:
				case REAL:
				case ROW:
				case SETOF:
				case SMALLINT:
				case SUBSTRING:
				case TIME:
				case TIMESTAMP:
				case TREAT:
				case TRIM:
				case VALUES:
				case VARCHAR:
				case XMLATTRIBUTES:
				case XMLCONCAT:
				case XMLELEMENT:
				case XMLEXISTS:
				case XMLFOREST:
				case XMLNAMESPACES:
				case XMLPARSE:
				case XMLPI:
				case XMLROOT:
				case XMLSERIALIZE:
				case XMLTABLE:
				case ALIGNMENT:
				case BASETYPE:
				case BUFFERS:
				case BYPASSRLS:
				case CANONICAL:
				case CATEGORY:
				case COLLATABLE:
				case COMBINEFUNC:
				case COMMUTATOR:
				case CONNECT:
				case COSTS:
				case CREATEDB:
				case CREATEROLE:
				case DESERIALFUNC:
				case DETERMINISTIC:
				case DISABLE_PAGE_SKIPPING:
				case ELEMENT:
				case EXTENDED:
				case FINALFUNC:
				case FINALFUNC_EXTRA:
				case FINALFUNC_MODIFY:
				case FORCE_NOT_NULL:
				case FORCE_NULL:
				case FORCE_QUOTE:
				case FORMAT:
				case GETTOKEN:
				case HASH:
				case HASHES:
				case HEADLINE:
				case HYPOTHETICAL:
				case INDEX_CLEANUP:
				case INIT:
				case INITCOND:
				case INTERNALLENGTH:
				case JSON:
				case LC_COLLATE:
				case LC_CTYPE:
				case LEFTARG:
				case LEXIZE:
				case LEXTYPES:
				case LIST:
				case LOCALE:
				case LOGIN:
				case MAIN:
				case MERGES:
				case MFINALFUNC:
				case MFINALFUNC_EXTRA:
				case MFINALFUNC_MODIFY:
				case MINITCOND:
				case MINVFUNC:
				case MODULUS:
				case MSFUNC:
				case MSSPACE:
				case MSTYPE:
				case NEGATOR:
				case NOBYPASSRLS:
				case NOCREATEDB:
				case NOCREATEROLE:
				case NOINHERIT:
				case NOLOGIN:
				case NOREPLICATION:
				case NOSUPERUSER:
				case OUTPUT:
				case PASSEDBYVALUE:
				case PATH:
				case PERMISSIVE:
				case PLAIN:
				case PREFERRED:
				case PROVIDER:
				case READ_ONLY:
				case READ_WRITE:
				case RECEIVE:
				case REMAINDER:
				case REPLICATION:
				case RESTRICTED:
				case RESTRICTIVE:
				case RIGHTARG:
				case SAFE:
				case SEND:
				case SERIALFUNC:
				case SETTINGS:
				case SFUNC:
				case SHAREABLE:
				case SKIP_LOCKED:
				case SORTOP:
				case SSPACE:
				case STYPE:
				case SUBTYPE_DIFF:
				case SUBTYPE_OPCLASS:
				case SUBTYPE:
				case SUMMARY:
				case SUPERUSER:
				case TIMING:
				case TYPMOD_IN:
				case TYPMOD_OUT:
				case UNSAFE:
				case USAGE:
				case VARIABLE:
				case YAML:
				case ALIAS:
				case ASSERT:
				case CONSTANT:
				case DATATYPE:
				case DEBUG:
				case DETAIL:
				case DIAGNOSTICS:
				case ELSEIF:
				case ELSIF:
				case ERRCODE:
				case EXIT:
				case EXCEPTION:
				case FOREACH:
				case GET:
				case HINT:
				case INFO:
				case LOG:
				case LOOP:
				case MESSAGE:
				case NOTICE:
				case OPEN:
				case PERFORM:
				case QUERY:
				case RAISE:
				case RECORD:
				case RETURN:
				case REVERSE:
				case ROWTYPE:
				case SLICE:
				case SQLSTATE:
				case STACKED:
				case WARNING:
				case WHILE:
				case Identifier:
				case QuotedIdentifier:
					{
					State = 2956; identifier();
					}
					break;
				case Character_String_Literal:
				case BeginDollarStringConstant:
					{
					State = 2957; character_string();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Analyze_modeContext : ParserRuleContext {
		public ITerminalNode VERBOSE() { return GetToken(PlPgSqlParser.VERBOSE, 0); }
		public ITerminalNode SKIP_LOCKED() { return GetToken(PlPgSqlParser.SKIP_LOCKED, 0); }
		public Boolean_valueContext boolean_value() {
			return GetRuleContext<Boolean_valueContext>(0);
		}
		public Analyze_modeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_analyze_mode; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAnalyze_mode(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Analyze_modeContext analyze_mode() {
		Analyze_modeContext _localctx = new Analyze_modeContext(Context, State);
		EnterRule(_localctx, 282, RULE_analyze_mode);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2962;
			_la = TokenStream.LA(1);
			if ( !(_la==VERBOSE || _la==SKIP_LOCKED) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 2964;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OFF || ((((_la - 397)) & ~0x3f) == 0 && ((1L << (_la - 397)) & ((1L << (FALSE - 397)) | (1L << (ON - 397)) | (1L << (TRUE - 397)))) != 0) || _la==NUMBER_LITERAL) {
				{
				State = 2963; boolean_value();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Using_vexContext : ParserRuleContext {
		public ITerminalNode USING() { return GetToken(PlPgSqlParser.USING, 0); }
		public VexContext[] vex() {
			return GetRuleContexts<VexContext>();
		}
		public VexContext vex(int i) {
			return GetRuleContext<VexContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlPgSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlPgSqlParser.COMMA, i);
		}
		public Using_vexContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_using_vex; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUsing_vex(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Using_vexContext using_vex() {
		Using_vexContext _localctx = new Using_vexContext(Context, State);
		EnterRule(_localctx, 284, RULE_using_vex);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2966; Match(USING);
			State = 2967; vex(0);
			State = 2972;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 2968; Match(COMMA);
				State = 2969; vex(0);
				}
				}
				State = 2974;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Assign_stmtContext : ParserRuleContext {
		public VarContext var() {
			return GetRuleContext<VarContext>(0);
		}
		public ITerminalNode COLON_EQUAL() { return GetToken(PlPgSqlParser.COLON_EQUAL, 0); }
		public ITerminalNode EQUAL() { return GetToken(PlPgSqlParser.EQUAL, 0); }
		public Select_stmt_no_parensContext select_stmt_no_parens() {
			return GetRuleContext<Select_stmt_no_parensContext>(0);
		}
		public Perform_stmtContext perform_stmt() {
			return GetRuleContext<Perform_stmtContext>(0);
		}
		public Assign_stmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_assign_stmt; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAssign_stmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Assign_stmtContext assign_stmt() {
		Assign_stmtContext _localctx = new Assign_stmtContext(Context, State);
		EnterRule(_localctx, 286, RULE_assign_stmt);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2975; var();
			State = 2976;
			_la = TokenStream.LA(1);
			if ( !(_la==EQUAL || _la==COLON_EQUAL) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 2979;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,458,Context) ) {
			case 1:
				{
				State = 2977; select_stmt_no_parens();
				}
				break;
			case 2:
				{
				State = 2978; perform_stmt();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Select_stmt_no_parensContext : ParserRuleContext {
		public Select_ops_no_parensContext select_ops_no_parens() {
			return GetRuleContext<Select_ops_no_parensContext>(0);
		}
		public With_clauseContext with_clause() {
			return GetRuleContext<With_clauseContext>(0);
		}
		public After_opsContext[] after_ops() {
			return GetRuleContexts<After_opsContext>();
		}
		public After_opsContext after_ops(int i) {
			return GetRuleContext<After_opsContext>(i);
		}
		public Select_stmt_no_parensContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_select_stmt_no_parens; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSelect_stmt_no_parens(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Select_stmt_no_parensContext select_stmt_no_parens() {
		Select_stmt_no_parensContext _localctx = new Select_stmt_no_parensContext(Context, State);
		EnterRule(_localctx, 288, RULE_select_stmt_no_parens);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2982;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WITH) {
				{
				State = 2981; with_clause();
				}
			}

			State = 2984; select_ops_no_parens();
			State = 2988;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,460,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 2985; after_ops();
					}
					} 
				}
				State = 2990;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,460,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Select_ops_no_parensContext : ParserRuleContext {
		public Select_opsContext select_ops() {
			return GetRuleContext<Select_opsContext>(0);
		}
		public ITerminalNode INTERSECT() { return GetToken(PlPgSqlParser.INTERSECT, 0); }
		public ITerminalNode UNION() { return GetToken(PlPgSqlParser.UNION, 0); }
		public ITerminalNode EXCEPT() { return GetToken(PlPgSqlParser.EXCEPT, 0); }
		public Select_primaryContext select_primary() {
			return GetRuleContext<Select_primaryContext>(0);
		}
		public ITerminalNode LEFT_PAREN() { return GetToken(PlPgSqlParser.LEFT_PAREN, 0); }
		public Select_stmtContext select_stmt() {
			return GetRuleContext<Select_stmtContext>(0);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlPgSqlParser.RIGHT_PAREN, 0); }
		public Set_qualifierContext set_qualifier() {
			return GetRuleContext<Set_qualifierContext>(0);
		}
		public Select_ops_no_parensContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_select_ops_no_parens; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSelect_ops_no_parens(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Select_ops_no_parensContext select_ops_no_parens() {
		Select_ops_no_parensContext _localctx = new Select_ops_no_parensContext(Context, State);
		EnterRule(_localctx, 290, RULE_select_ops_no_parens);
		int _la;
		try {
			State = 3004;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,463,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2991; select_ops(0);
				State = 2992;
				_la = TokenStream.LA(1);
				if ( !(((((_la - 396)) & ~0x3f) == 0 && ((1L << (_la - 396)) & ((1L << (EXCEPT - 396)) | (1L << (INTERSECT - 396)) | (1L << (UNION - 396)))) != 0)) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 2994;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ALL || _la==DISTINCT) {
					{
					State = 2993; set_qualifier();
					}
				}

				State = 3001;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case VALUES:
				case SELECT:
				case TABLE:
					{
					State = 2996; select_primary();
					}
					break;
				case LEFT_PAREN:
					{
					State = 2997; Match(LEFT_PAREN);
					State = 2998; select_stmt();
					State = 2999; Match(RIGHT_PAREN);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3003; select_primary();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Vex_bContext : ParserRuleContext {
		public ITerminalNode LEFT_PAREN() { return GetToken(PlPgSqlParser.LEFT_PAREN, 0); }
		public VexContext[] vex() {
			return GetRuleContexts<VexContext>();
		}
		public VexContext vex(int i) {
			return GetRuleContext<VexContext>(i);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlPgSqlParser.RIGHT_PAREN, 0); }
		public Indirection_listContext indirection_list() {
			return GetRuleContext<Indirection_listContext>(0);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlPgSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlPgSqlParser.COMMA, i);
		}
		public Vex_bContext[] vex_b() {
			return GetRuleContexts<Vex_bContext>();
		}
		public Vex_bContext vex_b(int i) {
			return GetRuleContext<Vex_bContext>(i);
		}
		public ITerminalNode PLUS() { return GetToken(PlPgSqlParser.PLUS, 0); }
		public ITerminalNode MINUS() { return GetToken(PlPgSqlParser.MINUS, 0); }
		public OpContext op() {
			return GetRuleContext<OpContext>(0);
		}
		public Value_expression_primaryContext value_expression_primary() {
			return GetRuleContext<Value_expression_primaryContext>(0);
		}
		public ITerminalNode EXP() { return GetToken(PlPgSqlParser.EXP, 0); }
		public ITerminalNode MULTIPLY() { return GetToken(PlPgSqlParser.MULTIPLY, 0); }
		public ITerminalNode DIVIDE() { return GetToken(PlPgSqlParser.DIVIDE, 0); }
		public ITerminalNode MODULAR() { return GetToken(PlPgSqlParser.MODULAR, 0); }
		public ITerminalNode LTH() { return GetToken(PlPgSqlParser.LTH, 0); }
		public ITerminalNode GTH() { return GetToken(PlPgSqlParser.GTH, 0); }
		public ITerminalNode LEQ() { return GetToken(PlPgSqlParser.LEQ, 0); }
		public ITerminalNode GEQ() { return GetToken(PlPgSqlParser.GEQ, 0); }
		public ITerminalNode EQUAL() { return GetToken(PlPgSqlParser.EQUAL, 0); }
		public ITerminalNode NOT_EQUAL() { return GetToken(PlPgSqlParser.NOT_EQUAL, 0); }
		public ITerminalNode IS() { return GetToken(PlPgSqlParser.IS, 0); }
		public ITerminalNode DISTINCT() { return GetToken(PlPgSqlParser.DISTINCT, 0); }
		public ITerminalNode FROM() { return GetToken(PlPgSqlParser.FROM, 0); }
		public ITerminalNode NOT() { return GetToken(PlPgSqlParser.NOT, 0); }
		public ITerminalNode CAST_EXPRESSION() { return GetToken(PlPgSqlParser.CAST_EXPRESSION, 0); }
		public Data_typeContext data_type() {
			return GetRuleContext<Data_typeContext>(0);
		}
		public ITerminalNode DOCUMENT() { return GetToken(PlPgSqlParser.DOCUMENT, 0); }
		public ITerminalNode UNKNOWN() { return GetToken(PlPgSqlParser.UNKNOWN, 0); }
		public ITerminalNode OF() { return GetToken(PlPgSqlParser.OF, 0); }
		public Type_listContext type_list() {
			return GetRuleContext<Type_listContext>(0);
		}
		public Vex_bContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_vex_b; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVex_b(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Vex_bContext vex_b() {
		return vex_b(0);
	}

	private Vex_bContext vex_b(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		Vex_bContext _localctx = new Vex_bContext(Context, _parentState);
		Vex_bContext _prevctx = _localctx;
		int _startState = 292;
		EnterRecursionRule(_localctx, 292, RULE_vex_b, _p);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 3029;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,466,Context) ) {
			case 1:
				{
				State = 3007; Match(LEFT_PAREN);
				State = 3008; vex(0);
				State = 3009; Match(RIGHT_PAREN);
				State = 3011;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,464,Context) ) {
				case 1:
					{
					State = 3010; indirection_list();
					}
					break;
				}
				}
				break;
			case 2:
				{
				State = 3013; Match(LEFT_PAREN);
				State = 3014; vex(0);
				State = 3017;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					{
					State = 3015; Match(COMMA);
					State = 3016; vex(0);
					}
					}
					State = 3019;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( _la==COMMA );
				State = 3021; Match(RIGHT_PAREN);
				}
				break;
			case 3:
				{
				State = 3023;
				_la = TokenStream.LA(1);
				if ( !(_la==PLUS || _la==MINUS) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 3024; vex_b(13);
				}
				break;
			case 4:
				{
				State = 3025; op();
				State = 3026; vex_b(8);
				}
				break;
			case 5:
				{
				State = 3028; value_expression_primary();
				}
				break;
			}
			Context.Stop = TokenStream.LT(-1);
			State = 3084;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,472,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 3082;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,471,Context) ) {
					case 1:
						{
						_localctx = new Vex_bContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_vex_b);
						State = 3031;
						if (!(Precpred(Context, 12))) throw new FailedPredicateException(this, "Precpred(Context, 12)");
						State = 3032; Match(EXP);
						State = 3033; vex_b(13);
						}
						break;
					case 2:
						{
						_localctx = new Vex_bContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_vex_b);
						State = 3034;
						if (!(Precpred(Context, 11))) throw new FailedPredicateException(this, "Precpred(Context, 11)");
						State = 3035;
						_la = TokenStream.LA(1);
						if ( !(((((_la - 589)) & ~0x3f) == 0 && ((1L << (_la - 589)) & ((1L << (MULTIPLY - 589)) | (1L << (DIVIDE - 589)) | (1L << (MODULAR - 589)))) != 0)) ) {
						ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 3036; vex_b(12);
						}
						break;
					case 3:
						{
						_localctx = new Vex_bContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_vex_b);
						State = 3037;
						if (!(Precpred(Context, 10))) throw new FailedPredicateException(this, "Precpred(Context, 10)");
						State = 3038;
						_la = TokenStream.LA(1);
						if ( !(_la==PLUS || _la==MINUS) ) {
						ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 3039; vex_b(11);
						}
						break;
					case 4:
						{
						_localctx = new Vex_bContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_vex_b);
						State = 3040;
						if (!(Precpred(Context, 9))) throw new FailedPredicateException(this, "Precpred(Context, 9)");
						State = 3041; op();
						State = 3042; vex_b(10);
						}
						break;
					case 5:
						{
						_localctx = new Vex_bContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_vex_b);
						State = 3044;
						if (!(Precpred(Context, 6))) throw new FailedPredicateException(this, "Precpred(Context, 6)");
						State = 3045;
						_la = TokenStream.LA(1);
						if ( !(((((_la - 576)) & ~0x3f) == 0 && ((1L << (_la - 576)) & ((1L << (EQUAL - 576)) | (1L << (NOT_EQUAL - 576)) | (1L << (LTH - 576)) | (1L << (LEQ - 576)) | (1L << (GTH - 576)) | (1L << (GEQ - 576)))) != 0)) ) {
						ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 3046; vex_b(7);
						}
						break;
					case 6:
						{
						_localctx = new Vex_bContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_vex_b);
						State = 3047;
						if (!(Precpred(Context, 5))) throw new FailedPredicateException(this, "Precpred(Context, 5)");
						State = 3048; Match(IS);
						State = 3050;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==NOT) {
							{
							State = 3049; Match(NOT);
							}
						}

						State = 3052; Match(DISTINCT);
						State = 3053; Match(FROM);
						State = 3054; vex_b(6);
						}
						break;
					case 7:
						{
						_localctx = new Vex_bContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_vex_b);
						State = 3055;
						if (!(Precpred(Context, 16))) throw new FailedPredicateException(this, "Precpred(Context, 16)");
						State = 3056; Match(CAST_EXPRESSION);
						State = 3057; data_type();
						}
						break;
					case 8:
						{
						_localctx = new Vex_bContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_vex_b);
						State = 3058;
						if (!(Precpred(Context, 7))) throw new FailedPredicateException(this, "Precpred(Context, 7)");
						State = 3059; op();
						}
						break;
					case 9:
						{
						_localctx = new Vex_bContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_vex_b);
						State = 3060;
						if (!(Precpred(Context, 4))) throw new FailedPredicateException(this, "Precpred(Context, 4)");
						State = 3061; Match(IS);
						State = 3063;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==NOT) {
							{
							State = 3062; Match(NOT);
							}
						}

						State = 3065; Match(DOCUMENT);
						}
						break;
					case 10:
						{
						_localctx = new Vex_bContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_vex_b);
						State = 3066;
						if (!(Precpred(Context, 3))) throw new FailedPredicateException(this, "Precpred(Context, 3)");
						State = 3067; Match(IS);
						State = 3069;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==NOT) {
							{
							State = 3068; Match(NOT);
							}
						}

						State = 3071; Match(UNKNOWN);
						}
						break;
					case 11:
						{
						_localctx = new Vex_bContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_vex_b);
						State = 3072;
						if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
						State = 3073; Match(IS);
						State = 3075;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==NOT) {
							{
							State = 3074; Match(NOT);
							}
						}

						State = 3077; Match(OF);
						State = 3078; Match(LEFT_PAREN);
						State = 3079; type_list();
						State = 3080; Match(RIGHT_PAREN);
						}
						break;
					}
					} 
				}
				State = 3086;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,472,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class OpContext : ParserRuleContext {
		public Op_charsContext op_chars() {
			return GetRuleContext<Op_charsContext>(0);
		}
		public ITerminalNode OPERATOR() { return GetToken(PlPgSqlParser.OPERATOR, 0); }
		public ITerminalNode LEFT_PAREN() { return GetToken(PlPgSqlParser.LEFT_PAREN, 0); }
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ITerminalNode DOT() { return GetToken(PlPgSqlParser.DOT, 0); }
		public All_simple_opContext all_simple_op() {
			return GetRuleContext<All_simple_opContext>(0);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlPgSqlParser.RIGHT_PAREN, 0); }
		public OpContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_op; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOp(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OpContext op() {
		OpContext _localctx = new OpContext(Context, State);
		EnterRule(_localctx, 294, RULE_op);
		try {
			State = 3095;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LESS_LESS:
			case GREATER_GREATER:
			case HASH_SIGN:
			case OP_CHARS:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3087; op_chars();
				}
				break;
			case OPERATOR:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3088; Match(OPERATOR);
				State = 3089; Match(LEFT_PAREN);
				State = 3090; identifier();
				State = 3091; Match(DOT);
				State = 3092; all_simple_op();
				State = 3093; Match(RIGHT_PAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Value_expression_primaryContext : ParserRuleContext {
		public Unsigned_value_specificationContext unsigned_value_specification() {
			return GetRuleContext<Unsigned_value_specificationContext>(0);
		}
		public ITerminalNode LEFT_PAREN() { return GetToken(PlPgSqlParser.LEFT_PAREN, 0); }
		public Select_stmt_no_parensContext select_stmt_no_parens() {
			return GetRuleContext<Select_stmt_no_parensContext>(0);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlPgSqlParser.RIGHT_PAREN, 0); }
		public Indirection_listContext indirection_list() {
			return GetRuleContext<Indirection_listContext>(0);
		}
		public Case_expressionContext case_expression() {
			return GetRuleContext<Case_expressionContext>(0);
		}
		public ITerminalNode NULL() { return GetToken(PlPgSqlParser.NULL, 0); }
		public ITerminalNode MULTIPLY() { return GetToken(PlPgSqlParser.MULTIPLY, 0); }
		public Comparison_modContext comparison_mod() {
			return GetRuleContext<Comparison_modContext>(0);
		}
		public ITerminalNode EXISTS() { return GetToken(PlPgSqlParser.EXISTS, 0); }
		public Table_subqueryContext table_subquery() {
			return GetRuleContext<Table_subqueryContext>(0);
		}
		public Function_callContext function_call() {
			return GetRuleContext<Function_callContext>(0);
		}
		public Indirection_varContext indirection_var() {
			return GetRuleContext<Indirection_varContext>(0);
		}
		public Array_expressionContext array_expression() {
			return GetRuleContext<Array_expressionContext>(0);
		}
		public Type_coercionContext type_coercion() {
			return GetRuleContext<Type_coercionContext>(0);
		}
		public Datetime_overlapsContext datetime_overlaps() {
			return GetRuleContext<Datetime_overlapsContext>(0);
		}
		public Value_expression_primaryContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_value_expression_primary; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitValue_expression_primary(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Value_expression_primaryContext value_expression_primary() {
		Value_expression_primaryContext _localctx = new Value_expression_primaryContext(Context, State);
		EnterRule(_localctx, 296, RULE_value_expression_primary);
		try {
			State = 3115;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,475,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3097; unsigned_value_specification();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3098; Match(LEFT_PAREN);
				State = 3099; select_stmt_no_parens();
				State = 3100; Match(RIGHT_PAREN);
				State = 3102;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,474,Context) ) {
				case 1:
					{
					State = 3101; indirection_list();
					}
					break;
				}
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3104; case_expression();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 3105; Match(NULL);
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 3106; Match(MULTIPLY);
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 3107; comparison_mod();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 3108; Match(EXISTS);
				State = 3109; table_subquery();
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 3110; function_call();
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 3111; indirection_var();
				}
				break;
			case 10:
				EnterOuterAlt(_localctx, 10);
				{
				State = 3112; array_expression();
				}
				break;
			case 11:
				EnterOuterAlt(_localctx, 11);
				{
				State = 3113; type_coercion();
				}
				break;
			case 12:
				EnterOuterAlt(_localctx, 12);
				{
				State = 3114; datetime_overlaps();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Datetime_overlapsContext : ParserRuleContext {
		public ITerminalNode[] LEFT_PAREN() { return GetTokens(PlPgSqlParser.LEFT_PAREN); }
		public ITerminalNode LEFT_PAREN(int i) {
			return GetToken(PlPgSqlParser.LEFT_PAREN, i);
		}
		public VexContext[] vex() {
			return GetRuleContexts<VexContext>();
		}
		public VexContext vex(int i) {
			return GetRuleContext<VexContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlPgSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlPgSqlParser.COMMA, i);
		}
		public ITerminalNode[] RIGHT_PAREN() { return GetTokens(PlPgSqlParser.RIGHT_PAREN); }
		public ITerminalNode RIGHT_PAREN(int i) {
			return GetToken(PlPgSqlParser.RIGHT_PAREN, i);
		}
		public ITerminalNode OVERLAPS() { return GetToken(PlPgSqlParser.OVERLAPS, 0); }
		public Datetime_overlapsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_datetime_overlaps; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDatetime_overlaps(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Datetime_overlapsContext datetime_overlaps() {
		Datetime_overlapsContext _localctx = new Datetime_overlapsContext(Context, State);
		EnterRule(_localctx, 298, RULE_datetime_overlaps);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3117; Match(LEFT_PAREN);
			State = 3118; vex(0);
			State = 3119; Match(COMMA);
			State = 3120; vex(0);
			State = 3121; Match(RIGHT_PAREN);
			State = 3122; Match(OVERLAPS);
			State = 3123; Match(LEFT_PAREN);
			State = 3124; vex(0);
			State = 3125; Match(COMMA);
			State = 3126; vex(0);
			State = 3127; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Type_coercionContext : ParserRuleContext {
		public Data_typeContext data_type() {
			return GetRuleContext<Data_typeContext>(0);
		}
		public Character_stringContext character_string() {
			return GetRuleContext<Character_stringContext>(0);
		}
		public ITerminalNode INTERVAL() { return GetToken(PlPgSqlParser.INTERVAL, 0); }
		public Interval_fieldContext interval_field() {
			return GetRuleContext<Interval_fieldContext>(0);
		}
		public Type_lengthContext type_length() {
			return GetRuleContext<Type_lengthContext>(0);
		}
		public Type_coercionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type_coercion; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType_coercion(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Type_coercionContext type_coercion() {
		Type_coercionContext _localctx = new Type_coercionContext(Context, State);
		EnterRule(_localctx, 300, RULE_type_coercion);
		try {
			State = 3138;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,477,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3129; data_type();
				State = 3130; character_string();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3132; Match(INTERVAL);
				State = 3133; character_string();
				State = 3134; interval_field();
				State = 3136;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,476,Context) ) {
				case 1:
					{
					State = 3135; type_length();
					}
					break;
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Array_expressionContext : ParserRuleContext {
		public ITerminalNode ARRAY() { return GetToken(PlPgSqlParser.ARRAY, 0); }
		public Array_elementsContext array_elements() {
			return GetRuleContext<Array_elementsContext>(0);
		}
		public Table_subqueryContext table_subquery() {
			return GetRuleContext<Table_subqueryContext>(0);
		}
		public Array_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_array_expression; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArray_expression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Array_expressionContext array_expression() {
		Array_expressionContext _localctx = new Array_expressionContext(Context, State);
		EnterRule(_localctx, 302, RULE_array_expression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3140; Match(ARRAY);
			State = 3143;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LEFT_BRACKET:
				{
				State = 3141; array_elements();
				}
				break;
			case LEFT_PAREN:
				{
				State = 3142; table_subquery();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Array_elementsContext : ParserRuleContext {
		public ITerminalNode LEFT_BRACKET() { return GetToken(PlPgSqlParser.LEFT_BRACKET, 0); }
		public ITerminalNode RIGHT_BRACKET() { return GetToken(PlPgSqlParser.RIGHT_BRACKET, 0); }
		public VexContext[] vex() {
			return GetRuleContexts<VexContext>();
		}
		public VexContext vex(int i) {
			return GetRuleContext<VexContext>(i);
		}
		public Array_elementsContext[] array_elements() {
			return GetRuleContexts<Array_elementsContext>();
		}
		public Array_elementsContext array_elements(int i) {
			return GetRuleContext<Array_elementsContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlPgSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlPgSqlParser.COMMA, i);
		}
		public Array_elementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_array_elements; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArray_elements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Array_elementsContext array_elements() {
		Array_elementsContext _localctx = new Array_elementsContext(Context, State);
		EnterRule(_localctx, 304, RULE_array_elements);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3145; Match(LEFT_BRACKET);
			State = 3160;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ABORT) | (1L << ABSOLUTE) | (1L << ACCESS) | (1L << ACTION) | (1L << ADD) | (1L << ADMIN) | (1L << AFTER) | (1L << AGGREGATE) | (1L << ALSO) | (1L << ALTER) | (1L << ALWAYS) | (1L << ASSERTION) | (1L << ASSIGNMENT) | (1L << AT) | (1L << ATTACH) | (1L << ATTRIBUTE) | (1L << BACKWARD) | (1L << BEFORE) | (1L << BEGIN) | (1L << BY) | (1L << CACHE) | (1L << CALL) | (1L << CALLED) | (1L << CASCADE) | (1L << CASCADED) | (1L << CATALOG) | (1L << CHAIN) | (1L << CHARACTERISTICS) | (1L << CHECKPOINT) | (1L << CLASS) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMENTS) | (1L << COMMIT) | (1L << COMMITTED) | (1L << CONFIGURATION) | (1L << CONFLICT) | (1L << CONNECTION) | (1L << CONSTRAINTS) | (1L << CONTENT) | (1L << CONTINUE) | (1L << CONVERSION) | (1L << COPY) | (1L << COST) | (1L << CSV) | (1L << CUBE) | (1L << CURRENT) | (1L << CURSOR) | (1L << CYCLE) | (1L << DATA) | (1L << DATABASE) | (1L << DAY) | (1L << DEALLOCATE) | (1L << DECLARE) | (1L << DEFAULTS) | (1L << DEFERRED) | (1L << DEFINER) | (1L << DELETE) | (1L << DELIMITER) | (1L << DELIMITERS) | (1L << DEPENDS))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (DETACH - 64)) | (1L << (DICTIONARY - 64)) | (1L << (DISABLE - 64)) | (1L << (DISCARD - 64)) | (1L << (DOCUMENT - 64)) | (1L << (DOMAIN - 64)) | (1L << (DOUBLE - 64)) | (1L << (DROP - 64)) | (1L << (EACH - 64)) | (1L << (ENABLE - 64)) | (1L << (ENCODING - 64)) | (1L << (ENCRYPTED - 64)) | (1L << (ENUM - 64)) | (1L << (ESCAPE - 64)) | (1L << (EVENT - 64)) | (1L << (EXCLUDE - 64)) | (1L << (EXCLUDING - 64)) | (1L << (EXCLUSIVE - 64)) | (1L << (EXECUTE - 64)) | (1L << (EXPLAIN - 64)) | (1L << (EXTENSION - 64)) | (1L << (EXTERNAL - 64)) | (1L << (FAMILY - 64)) | (1L << (FILTER - 64)) | (1L << (FIRST - 64)) | (1L << (FOLLOWING - 64)) | (1L << (FORCE - 64)) | (1L << (FORWARD - 64)) | (1L << (FUNCTION - 64)) | (1L << (FUNCTIONS - 64)) | (1L << (GENERATED - 64)) | (1L << (GLOBAL - 64)) | (1L << (GRANTED - 64)) | (1L << (GROUPS - 64)) | (1L << (HANDLER - 64)) | (1L << (HEADER - 64)) | (1L << (HOLD - 64)) | (1L << (HOUR - 64)) | (1L << (IDENTITY - 64)) | (1L << (IF - 64)) | (1L << (IMMEDIATE - 64)) | (1L << (IMMUTABLE - 64)) | (1L << (IMPLICIT - 64)) | (1L << (IMPORT - 64)) | (1L << (INCLUDE - 64)) | (1L << (INCLUDING - 64)) | (1L << (INCREMENT - 64)) | (1L << (INDEX - 64)) | (1L << (INDEXES - 64)) | (1L << (INHERIT - 64)) | (1L << (INHERITS - 64)) | (1L << (INLINE - 64)) | (1L << (INPUT - 64)) | (1L << (INSENSITIVE - 64)) | (1L << (INSERT - 64)) | (1L << (INSTEAD - 64)) | (1L << (INVOKER - 64)) | (1L << (ISOLATION - 64)) | (1L << (KEY - 64)) | (1L << (LABEL - 64)) | (1L << (LANGUAGE - 64)) | (1L << (LARGE - 64)) | (1L << (LAST - 64)) | (1L << (LEAKPROOF - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (LEVEL - 128)) | (1L << (LISTEN - 128)) | (1L << (LOAD - 128)) | (1L << (LOCAL - 128)) | (1L << (LOCATION - 128)) | (1L << (LOCK - 128)) | (1L << (LOCKED - 128)) | (1L << (LOGGED - 128)) | (1L << (MAPPING - 128)) | (1L << (MATCH - 128)) | (1L << (MATERIALIZED - 128)) | (1L << (MAXVALUE - 128)) | (1L << (METHOD - 128)) | (1L << (MINUTE - 128)) | (1L << (MINVALUE - 128)) | (1L << (MODE - 128)) | (1L << (MONTH - 128)) | (1L << (MOVE - 128)) | (1L << (NAME - 128)) | (1L << (NAMES - 128)) | (1L << (NEW - 128)) | (1L << (NEXT - 128)) | (1L << (NO - 128)) | (1L << (NOTHING - 128)) | (1L << (NOTIFY - 128)) | (1L << (NOWAIT - 128)) | (1L << (NULLS - 128)) | (1L << (OBJECT - 128)) | (1L << (OF - 128)) | (1L << (OFF - 128)) | (1L << (OIDS - 128)) | (1L << (OLD - 128)) | (1L << (OPERATOR - 128)) | (1L << (OPTION - 128)) | (1L << (OPTIONS - 128)) | (1L << (ORDINALITY - 128)) | (1L << (OTHERS - 128)) | (1L << (OVER - 128)) | (1L << (OVERRIDING - 128)) | (1L << (OWNED - 128)) | (1L << (OWNER - 128)) | (1L << (PARALLEL - 128)) | (1L << (PARSER - 128)) | (1L << (PARTIAL - 128)) | (1L << (PARTITION - 128)) | (1L << (PASSING - 128)) | (1L << (PASSWORD - 128)) | (1L << (PLANS - 128)) | (1L << (POLICY - 128)) | (1L << (PRECEDING - 128)) | (1L << (PREPARE - 128)) | (1L << (PREPARED - 128)) | (1L << (PRESERVE - 128)) | (1L << (PRIOR - 128)) | (1L << (PRIVILEGES - 128)) | (1L << (PROCEDURAL - 128)) | (1L << (PROCEDURE - 128)) | (1L << (PROCEDURES - 128)) | (1L << (PROGRAM - 128)) | (1L << (PUBLICATION - 128)) | (1L << (QUOTE - 128)) | (1L << (RANGE - 128)) | (1L << (READ - 128)) | (1L << (REASSIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (RECHECK - 192)) | (1L << (RECURSIVE - 192)) | (1L << (REF - 192)) | (1L << (REFERENCING - 192)) | (1L << (REFRESH - 192)) | (1L << (REINDEX - 192)) | (1L << (RELATIVE - 192)) | (1L << (RELEASE - 192)) | (1L << (RENAME - 192)) | (1L << (REPEATABLE - 192)) | (1L << (REPLACE - 192)) | (1L << (REPLICA - 192)) | (1L << (RESET - 192)) | (1L << (RESTART - 192)) | (1L << (RESTRICT - 192)) | (1L << (RETURNS - 192)) | (1L << (REVOKE - 192)) | (1L << (ROLE - 192)) | (1L << (ROLLBACK - 192)) | (1L << (ROLLUP - 192)) | (1L << (ROUTINE - 192)) | (1L << (ROUTINES - 192)) | (1L << (ROWS - 192)) | (1L << (RULE - 192)) | (1L << (SAVEPOINT - 192)) | (1L << (SCHEMA - 192)) | (1L << (SCHEMAS - 192)) | (1L << (SCROLL - 192)) | (1L << (SEARCH - 192)) | (1L << (SECOND - 192)) | (1L << (SECURITY - 192)) | (1L << (SEQUENCE - 192)) | (1L << (SEQUENCES - 192)) | (1L << (SERIALIZABLE - 192)) | (1L << (SERVER - 192)) | (1L << (SESSION - 192)) | (1L << (SET - 192)) | (1L << (SETS - 192)) | (1L << (SHARE - 192)) | (1L << (SHOW - 192)) | (1L << (SIMPLE - 192)) | (1L << (SKIP_ - 192)) | (1L << (SNAPSHOT - 192)) | (1L << (SQL - 192)) | (1L << (STABLE - 192)) | (1L << (STANDALONE - 192)) | (1L << (START - 192)) | (1L << (STATEMENT - 192)) | (1L << (STATISTICS - 192)) | (1L << (STDIN - 192)) | (1L << (STDOUT - 192)) | (1L << (STORAGE - 192)) | (1L << (STORED - 192)) | (1L << (STRICT - 192)) | (1L << (STRIP - 192)) | (1L << (SUBSCRIPTION - 192)) | (1L << (SUPPORT - 192)) | (1L << (SYSID - 192)) | (1L << (SYSTEM - 192)) | (1L << (TABLES - 192)) | (1L << (TABLESPACE - 192)) | (1L << (TEMP - 192)) | (1L << (TEMPLATE - 192)) | (1L << (TEMPORARY - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (TEXT - 256)) | (1L << (TIES - 256)) | (1L << (TRANSACTION - 256)) | (1L << (TRANSFORM - 256)) | (1L << (TRIGGER - 256)) | (1L << (TRUNCATE - 256)) | (1L << (TRUSTED - 256)) | (1L << (TYPE - 256)) | (1L << (TYPES - 256)) | (1L << (UNBOUNDED - 256)) | (1L << (UNCOMMITTED - 256)) | (1L << (UNENCRYPTED - 256)) | (1L << (UNKNOWN - 256)) | (1L << (UNLISTEN - 256)) | (1L << (UNLOGGED - 256)) | (1L << (UNTIL - 256)) | (1L << (UPDATE - 256)) | (1L << (VACUUM - 256)) | (1L << (VALID - 256)) | (1L << (VALIDATE - 256)) | (1L << (VALIDATOR - 256)) | (1L << (VALUE - 256)) | (1L << (VARYING - 256)) | (1L << (VERSION - 256)) | (1L << (VIEW - 256)) | (1L << (VIEWS - 256)) | (1L << (VOLATILE - 256)) | (1L << (WHITESPACE - 256)) | (1L << (WITHIN - 256)) | (1L << (WITHOUT - 256)) | (1L << (WORK - 256)) | (1L << (WRAPPER - 256)) | (1L << (WRITE - 256)) | (1L << (XML - 256)) | (1L << (YEAR - 256)) | (1L << (YES - 256)) | (1L << (ZONE - 256)) | (1L << (BETWEEN - 256)) | (1L << (BIGINT - 256)) | (1L << (BIT - 256)) | (1L << (BOOLEAN - 256)) | (1L << (CHAR - 256)) | (1L << (CHARACTER - 256)) | (1L << (COALESCE - 256)) | (1L << (DEC - 256)) | (1L << (DECIMAL - 256)) | (1L << (EXISTS - 256)) | (1L << (EXTRACT - 256)) | (1L << (FLOAT - 256)) | (1L << (GREATEST - 256)) | (1L << (GROUPING - 256)) | (1L << (INOUT - 256)) | (1L << (INT - 256)) | (1L << (INTEGER - 256)) | (1L << (INTERVAL - 256)) | (1L << (LEAST - 256)) | (1L << (NATIONAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NONE - 256)) | (1L << (NULLIF - 256)) | (1L << (NUMERIC - 256)) | (1L << (OUT - 256)) | (1L << (OVERLAY - 256)) | (1L << (POSITION - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (PRECISION - 320)) | (1L << (REAL - 320)) | (1L << (ROW - 320)) | (1L << (SETOF - 320)) | (1L << (SMALLINT - 320)) | (1L << (SUBSTRING - 320)) | (1L << (TIME - 320)) | (1L << (TIMESTAMP - 320)) | (1L << (TREAT - 320)) | (1L << (TRIM - 320)) | (1L << (VALUES - 320)) | (1L << (VARCHAR - 320)) | (1L << (XMLATTRIBUTES - 320)) | (1L << (XMLCONCAT - 320)) | (1L << (XMLELEMENT - 320)) | (1L << (XMLEXISTS - 320)) | (1L << (XMLFOREST - 320)) | (1L << (XMLNAMESPACES - 320)) | (1L << (XMLPARSE - 320)) | (1L << (XMLPI - 320)) | (1L << (XMLROOT - 320)) | (1L << (XMLSERIALIZE - 320)) | (1L << (XMLTABLE - 320)) | (1L << (AUTHORIZATION - 320)) | (1L << (BINARY - 320)) | (1L << (COLLATION - 320)) | (1L << (CONCURRENTLY - 320)) | (1L << (CROSS - 320)) | (1L << (CURRENT_SCHEMA - 320)) | (1L << (FREEZE - 320)) | (1L << (FULL - 320)) | (1L << (ILIKE - 320)) | (1L << (INNER - 320)) | (1L << (IS - 320)) | (1L << (ISNULL - 320)) | (1L << (JOIN - 320)) | (1L << (LEFT - 320)) | (1L << (LIKE - 320)) | (1L << (NATURAL - 320)) | (1L << (NOTNULL - 320)) | (1L << (OUTER - 320)) | (1L << (OVERLAPS - 320)) | (1L << (RIGHT - 320)) | (1L << (SIMILAR - 320)) | (1L << (TABLESAMPLE - 320)) | (1L << (VERBOSE - 320)) | (1L << (ALL - 320)) | (1L << (ANY - 320)) | (1L << (ARRAY - 320)) | (1L << (CASE - 320)) | (1L << (CAST - 320)) | (1L << (CURRENT_CATALOG - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (CURRENT_DATE - 384)) | (1L << (CURRENT_TIME - 384)) | (1L << (CURRENT_TIMESTAMP - 384)) | (1L << (CURRENT_USER - 384)) | (1L << (FALSE - 384)) | (1L << (LOCALTIME - 384)) | (1L << (LOCALTIMESTAMP - 384)) | (1L << (NOT - 384)) | (1L << (NULL - 384)) | (1L << (ON - 384)) | (1L << (SESSION_USER - 384)) | (1L << (SOME - 384)) | (1L << (TRUE - 384)) | (1L << (USER - 384)) | (1L << (ALIGNMENT - 384)) | (1L << (BASETYPE - 384)) | (1L << (BUFFERS - 384)) | (1L << (BYPASSRLS - 384)) | (1L << (CANONICAL - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (CATEGORY - 448)) | (1L << (COLLATABLE - 448)) | (1L << (COMBINEFUNC - 448)) | (1L << (COMMUTATOR - 448)) | (1L << (CONNECT - 448)) | (1L << (COSTS - 448)) | (1L << (CREATEDB - 448)) | (1L << (CREATEROLE - 448)) | (1L << (DESERIALFUNC - 448)) | (1L << (DETERMINISTIC - 448)) | (1L << (DISABLE_PAGE_SKIPPING - 448)) | (1L << (ELEMENT - 448)) | (1L << (EXTENDED - 448)) | (1L << (FINALFUNC - 448)) | (1L << (FINALFUNC_EXTRA - 448)) | (1L << (FINALFUNC_MODIFY - 448)) | (1L << (FORCE_NOT_NULL - 448)) | (1L << (FORCE_NULL - 448)) | (1L << (FORCE_QUOTE - 448)) | (1L << (FORMAT - 448)) | (1L << (GETTOKEN - 448)) | (1L << (HASH - 448)) | (1L << (HASHES - 448)) | (1L << (HEADLINE - 448)) | (1L << (HYPOTHETICAL - 448)) | (1L << (INDEX_CLEANUP - 448)) | (1L << (INIT - 448)) | (1L << (INITCOND - 448)) | (1L << (INTERNALLENGTH - 448)) | (1L << (JSON - 448)) | (1L << (LC_COLLATE - 448)) | (1L << (LC_CTYPE - 448)) | (1L << (LEFTARG - 448)) | (1L << (LEXIZE - 448)) | (1L << (LEXTYPES - 448)) | (1L << (LIST - 448)) | (1L << (LOCALE - 448)) | (1L << (LOGIN - 448)) | (1L << (MAIN - 448)) | (1L << (MERGES - 448)) | (1L << (MFINALFUNC - 448)) | (1L << (MFINALFUNC_EXTRA - 448)) | (1L << (MFINALFUNC_MODIFY - 448)) | (1L << (MINITCOND - 448)) | (1L << (MINVFUNC - 448)) | (1L << (MODULUS - 448)) | (1L << (MSFUNC - 448)) | (1L << (MSSPACE - 448)) | (1L << (MSTYPE - 448)) | (1L << (NEGATOR - 448)) | (1L << (NOBYPASSRLS - 448)) | (1L << (NOCREATEDB - 448)) | (1L << (NOCREATEROLE - 448)) | (1L << (NOINHERIT - 448)) | (1L << (NOLOGIN - 448)) | (1L << (NOREPLICATION - 448)) | (1L << (NOSUPERUSER - 448)) | (1L << (OUTPUT - 448)) | (1L << (PASSEDBYVALUE - 448)) | (1L << (PATH - 448)) | (1L << (PERMISSIVE - 448)) | (1L << (PLAIN - 448)) | (1L << (PREFERRED - 448)) | (1L << (PROVIDER - 448)))) != 0) || ((((_la - 512)) & ~0x3f) == 0 && ((1L << (_la - 512)) & ((1L << (READ_ONLY - 512)) | (1L << (READ_WRITE - 512)) | (1L << (RECEIVE - 512)) | (1L << (REMAINDER - 512)) | (1L << (REPLICATION - 512)) | (1L << (RESTRICTED - 512)) | (1L << (RESTRICTIVE - 512)) | (1L << (RIGHTARG - 512)) | (1L << (SAFE - 512)) | (1L << (SEND - 512)) | (1L << (SERIALFUNC - 512)) | (1L << (SETTINGS - 512)) | (1L << (SFUNC - 512)) | (1L << (SHAREABLE - 512)) | (1L << (SKIP_LOCKED - 512)) | (1L << (SORTOP - 512)) | (1L << (SSPACE - 512)) | (1L << (STYPE - 512)) | (1L << (SUBTYPE_DIFF - 512)) | (1L << (SUBTYPE_OPCLASS - 512)) | (1L << (SUBTYPE - 512)) | (1L << (SUMMARY - 512)) | (1L << (SUPERUSER - 512)) | (1L << (TIMING - 512)) | (1L << (TYPMOD_IN - 512)) | (1L << (TYPMOD_OUT - 512)) | (1L << (UNSAFE - 512)) | (1L << (USAGE - 512)) | (1L << (VARIABLE - 512)) | (1L << (YAML - 512)) | (1L << (ALIAS - 512)) | (1L << (ASSERT - 512)) | (1L << (CONSTANT - 512)) | (1L << (DATATYPE - 512)) | (1L << (DEBUG - 512)) | (1L << (DETAIL - 512)) | (1L << (DIAGNOSTICS - 512)) | (1L << (ELSEIF - 512)) | (1L << (ELSIF - 512)) | (1L << (ERRCODE - 512)) | (1L << (EXIT - 512)) | (1L << (EXCEPTION - 512)) | (1L << (FOREACH - 512)) | (1L << (GET - 512)) | (1L << (HINT - 512)) | (1L << (INFO - 512)) | (1L << (LOG - 512)) | (1L << (LOOP - 512)) | (1L << (MESSAGE - 512)) | (1L << (NOTICE - 512)) | (1L << (OPEN - 512)) | (1L << (PERFORM - 512)) | (1L << (QUERY - 512)) | (1L << (RAISE - 512)) | (1L << (RECORD - 512)) | (1L << (RETURN - 512)) | (1L << (REVERSE - 512)) | (1L << (ROWTYPE - 512)) | (1L << (SLICE - 512)) | (1L << (SQLSTATE - 512)) | (1L << (STACKED - 512)) | (1L << (WARNING - 512)) | (1L << (WHILE - 512)))) != 0) || ((((_la - 585)) & ~0x3f) == 0 && ((1L << (_la - 585)) & ((1L << (LEFT_PAREN - 585)) | (1L << (PLUS - 585)) | (1L << (MINUS - 585)) | (1L << (MULTIPLY - 585)) | (1L << (LEFT_BRACKET - 585)) | (1L << (LESS_LESS - 585)) | (1L << (GREATER_GREATER - 585)) | (1L << (HASH_SIGN - 585)) | (1L << (OP_CHARS - 585)) | (1L << (NUMBER_LITERAL - 585)) | (1L << (REAL_NUMBER - 585)) | (1L << (DOLLAR_NUMBER - 585)) | (1L << (Identifier - 585)) | (1L << (QuotedIdentifier - 585)) | (1L << (Character_String_Literal - 585)) | (1L << (BeginDollarStringConstant - 585)))) != 0)) {
				{
				State = 3148;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case ABORT:
				case ABSOLUTE:
				case ACCESS:
				case ACTION:
				case ADD:
				case ADMIN:
				case AFTER:
				case AGGREGATE:
				case ALSO:
				case ALTER:
				case ALWAYS:
				case ASSERTION:
				case ASSIGNMENT:
				case AT:
				case ATTACH:
				case ATTRIBUTE:
				case BACKWARD:
				case BEFORE:
				case BEGIN:
				case BY:
				case CACHE:
				case CALL:
				case CALLED:
				case CASCADE:
				case CASCADED:
				case CATALOG:
				case CHAIN:
				case CHARACTERISTICS:
				case CHECKPOINT:
				case CLASS:
				case CLOSE:
				case CLUSTER:
				case COLUMNS:
				case COMMENT:
				case COMMENTS:
				case COMMIT:
				case COMMITTED:
				case CONFIGURATION:
				case CONFLICT:
				case CONNECTION:
				case CONSTRAINTS:
				case CONTENT:
				case CONTINUE:
				case CONVERSION:
				case COPY:
				case COST:
				case CSV:
				case CUBE:
				case CURRENT:
				case CURSOR:
				case CYCLE:
				case DATA:
				case DATABASE:
				case DAY:
				case DEALLOCATE:
				case DECLARE:
				case DEFAULTS:
				case DEFERRED:
				case DEFINER:
				case DELETE:
				case DELIMITER:
				case DELIMITERS:
				case DEPENDS:
				case DETACH:
				case DICTIONARY:
				case DISABLE:
				case DISCARD:
				case DOCUMENT:
				case DOMAIN:
				case DOUBLE:
				case DROP:
				case EACH:
				case ENABLE:
				case ENCODING:
				case ENCRYPTED:
				case ENUM:
				case ESCAPE:
				case EVENT:
				case EXCLUDE:
				case EXCLUDING:
				case EXCLUSIVE:
				case EXECUTE:
				case EXPLAIN:
				case EXTENSION:
				case EXTERNAL:
				case FAMILY:
				case FILTER:
				case FIRST:
				case FOLLOWING:
				case FORCE:
				case FORWARD:
				case FUNCTION:
				case FUNCTIONS:
				case GENERATED:
				case GLOBAL:
				case GRANTED:
				case GROUPS:
				case HANDLER:
				case HEADER:
				case HOLD:
				case HOUR:
				case IDENTITY:
				case IF:
				case IMMEDIATE:
				case IMMUTABLE:
				case IMPLICIT:
				case IMPORT:
				case INCLUDE:
				case INCLUDING:
				case INCREMENT:
				case INDEX:
				case INDEXES:
				case INHERIT:
				case INHERITS:
				case INLINE:
				case INPUT:
				case INSENSITIVE:
				case INSERT:
				case INSTEAD:
				case INVOKER:
				case ISOLATION:
				case KEY:
				case LABEL:
				case LANGUAGE:
				case LARGE:
				case LAST:
				case LEAKPROOF:
				case LEVEL:
				case LISTEN:
				case LOAD:
				case LOCAL:
				case LOCATION:
				case LOCK:
				case LOCKED:
				case LOGGED:
				case MAPPING:
				case MATCH:
				case MATERIALIZED:
				case MAXVALUE:
				case METHOD:
				case MINUTE:
				case MINVALUE:
				case MODE:
				case MONTH:
				case MOVE:
				case NAME:
				case NAMES:
				case NEW:
				case NEXT:
				case NO:
				case NOTHING:
				case NOTIFY:
				case NOWAIT:
				case NULLS:
				case OBJECT:
				case OF:
				case OFF:
				case OIDS:
				case OLD:
				case OPERATOR:
				case OPTION:
				case OPTIONS:
				case ORDINALITY:
				case OTHERS:
				case OVER:
				case OVERRIDING:
				case OWNED:
				case OWNER:
				case PARALLEL:
				case PARSER:
				case PARTIAL:
				case PARTITION:
				case PASSING:
				case PASSWORD:
				case PLANS:
				case POLICY:
				case PRECEDING:
				case PREPARE:
				case PREPARED:
				case PRESERVE:
				case PRIOR:
				case PRIVILEGES:
				case PROCEDURAL:
				case PROCEDURE:
				case PROCEDURES:
				case PROGRAM:
				case PUBLICATION:
				case QUOTE:
				case RANGE:
				case READ:
				case REASSIGN:
				case RECHECK:
				case RECURSIVE:
				case REF:
				case REFERENCING:
				case REFRESH:
				case REINDEX:
				case RELATIVE:
				case RELEASE:
				case RENAME:
				case REPEATABLE:
				case REPLACE:
				case REPLICA:
				case RESET:
				case RESTART:
				case RESTRICT:
				case RETURNS:
				case REVOKE:
				case ROLE:
				case ROLLBACK:
				case ROLLUP:
				case ROUTINE:
				case ROUTINES:
				case ROWS:
				case RULE:
				case SAVEPOINT:
				case SCHEMA:
				case SCHEMAS:
				case SCROLL:
				case SEARCH:
				case SECOND:
				case SECURITY:
				case SEQUENCE:
				case SEQUENCES:
				case SERIALIZABLE:
				case SERVER:
				case SESSION:
				case SET:
				case SETS:
				case SHARE:
				case SHOW:
				case SIMPLE:
				case SKIP_:
				case SNAPSHOT:
				case SQL:
				case STABLE:
				case STANDALONE:
				case START:
				case STATEMENT:
				case STATISTICS:
				case STDIN:
				case STDOUT:
				case STORAGE:
				case STORED:
				case STRICT:
				case STRIP:
				case SUBSCRIPTION:
				case SUPPORT:
				case SYSID:
				case SYSTEM:
				case TABLES:
				case TABLESPACE:
				case TEMP:
				case TEMPLATE:
				case TEMPORARY:
				case TEXT:
				case TIES:
				case TRANSACTION:
				case TRANSFORM:
				case TRIGGER:
				case TRUNCATE:
				case TRUSTED:
				case TYPE:
				case TYPES:
				case UNBOUNDED:
				case UNCOMMITTED:
				case UNENCRYPTED:
				case UNKNOWN:
				case UNLISTEN:
				case UNLOGGED:
				case UNTIL:
				case UPDATE:
				case VACUUM:
				case VALID:
				case VALIDATE:
				case VALIDATOR:
				case VALUE:
				case VARYING:
				case VERSION:
				case VIEW:
				case VIEWS:
				case VOLATILE:
				case WHITESPACE:
				case WITHIN:
				case WITHOUT:
				case WORK:
				case WRAPPER:
				case WRITE:
				case XML:
				case YEAR:
				case YES:
				case ZONE:
				case BETWEEN:
				case BIGINT:
				case BIT:
				case BOOLEAN:
				case CHAR:
				case CHARACTER:
				case COALESCE:
				case DEC:
				case DECIMAL:
				case EXISTS:
				case EXTRACT:
				case FLOAT:
				case GREATEST:
				case GROUPING:
				case INOUT:
				case INT:
				case INTEGER:
				case INTERVAL:
				case LEAST:
				case NATIONAL:
				case NCHAR:
				case NONE:
				case NULLIF:
				case NUMERIC:
				case OUT:
				case OVERLAY:
				case POSITION:
				case PRECISION:
				case REAL:
				case ROW:
				case SETOF:
				case SMALLINT:
				case SUBSTRING:
				case TIME:
				case TIMESTAMP:
				case TREAT:
				case TRIM:
				case VALUES:
				case VARCHAR:
				case XMLATTRIBUTES:
				case XMLCONCAT:
				case XMLELEMENT:
				case XMLEXISTS:
				case XMLFOREST:
				case XMLNAMESPACES:
				case XMLPARSE:
				case XMLPI:
				case XMLROOT:
				case XMLSERIALIZE:
				case XMLTABLE:
				case AUTHORIZATION:
				case BINARY:
				case COLLATION:
				case CONCURRENTLY:
				case CROSS:
				case CURRENT_SCHEMA:
				case FREEZE:
				case FULL:
				case ILIKE:
				case INNER:
				case IS:
				case ISNULL:
				case JOIN:
				case LEFT:
				case LIKE:
				case NATURAL:
				case NOTNULL:
				case OUTER:
				case OVERLAPS:
				case RIGHT:
				case SIMILAR:
				case TABLESAMPLE:
				case VERBOSE:
				case ALL:
				case ANY:
				case ARRAY:
				case CASE:
				case CAST:
				case CURRENT_CATALOG:
				case CURRENT_DATE:
				case CURRENT_TIME:
				case CURRENT_TIMESTAMP:
				case CURRENT_USER:
				case FALSE:
				case LOCALTIME:
				case LOCALTIMESTAMP:
				case NOT:
				case NULL:
				case ON:
				case SESSION_USER:
				case SOME:
				case TRUE:
				case USER:
				case ALIGNMENT:
				case BASETYPE:
				case BUFFERS:
				case BYPASSRLS:
				case CANONICAL:
				case CATEGORY:
				case COLLATABLE:
				case COMBINEFUNC:
				case COMMUTATOR:
				case CONNECT:
				case COSTS:
				case CREATEDB:
				case CREATEROLE:
				case DESERIALFUNC:
				case DETERMINISTIC:
				case DISABLE_PAGE_SKIPPING:
				case ELEMENT:
				case EXTENDED:
				case FINALFUNC:
				case FINALFUNC_EXTRA:
				case FINALFUNC_MODIFY:
				case FORCE_NOT_NULL:
				case FORCE_NULL:
				case FORCE_QUOTE:
				case FORMAT:
				case GETTOKEN:
				case HASH:
				case HASHES:
				case HEADLINE:
				case HYPOTHETICAL:
				case INDEX_CLEANUP:
				case INIT:
				case INITCOND:
				case INTERNALLENGTH:
				case JSON:
				case LC_COLLATE:
				case LC_CTYPE:
				case LEFTARG:
				case LEXIZE:
				case LEXTYPES:
				case LIST:
				case LOCALE:
				case LOGIN:
				case MAIN:
				case MERGES:
				case MFINALFUNC:
				case MFINALFUNC_EXTRA:
				case MFINALFUNC_MODIFY:
				case MINITCOND:
				case MINVFUNC:
				case MODULUS:
				case MSFUNC:
				case MSSPACE:
				case MSTYPE:
				case NEGATOR:
				case NOBYPASSRLS:
				case NOCREATEDB:
				case NOCREATEROLE:
				case NOINHERIT:
				case NOLOGIN:
				case NOREPLICATION:
				case NOSUPERUSER:
				case OUTPUT:
				case PASSEDBYVALUE:
				case PATH:
				case PERMISSIVE:
				case PLAIN:
				case PREFERRED:
				case PROVIDER:
				case READ_ONLY:
				case READ_WRITE:
				case RECEIVE:
				case REMAINDER:
				case REPLICATION:
				case RESTRICTED:
				case RESTRICTIVE:
				case RIGHTARG:
				case SAFE:
				case SEND:
				case SERIALFUNC:
				case SETTINGS:
				case SFUNC:
				case SHAREABLE:
				case SKIP_LOCKED:
				case SORTOP:
				case SSPACE:
				case STYPE:
				case SUBTYPE_DIFF:
				case SUBTYPE_OPCLASS:
				case SUBTYPE:
				case SUMMARY:
				case SUPERUSER:
				case TIMING:
				case TYPMOD_IN:
				case TYPMOD_OUT:
				case UNSAFE:
				case USAGE:
				case VARIABLE:
				case YAML:
				case ALIAS:
				case ASSERT:
				case CONSTANT:
				case DATATYPE:
				case DEBUG:
				case DETAIL:
				case DIAGNOSTICS:
				case ELSEIF:
				case ELSIF:
				case ERRCODE:
				case EXIT:
				case EXCEPTION:
				case FOREACH:
				case GET:
				case HINT:
				case INFO:
				case LOG:
				case LOOP:
				case MESSAGE:
				case NOTICE:
				case OPEN:
				case PERFORM:
				case QUERY:
				case RAISE:
				case RECORD:
				case RETURN:
				case REVERSE:
				case ROWTYPE:
				case SLICE:
				case SQLSTATE:
				case STACKED:
				case WARNING:
				case WHILE:
				case LEFT_PAREN:
				case PLUS:
				case MINUS:
				case MULTIPLY:
				case LESS_LESS:
				case GREATER_GREATER:
				case HASH_SIGN:
				case OP_CHARS:
				case NUMBER_LITERAL:
				case REAL_NUMBER:
				case DOLLAR_NUMBER:
				case Identifier:
				case QuotedIdentifier:
				case Character_String_Literal:
				case BeginDollarStringConstant:
					{
					State = 3146; vex(0);
					}
					break;
				case LEFT_BRACKET:
					{
					State = 3147; array_elements();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 3157;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 3150; Match(COMMA);
					State = 3153;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case ABORT:
					case ABSOLUTE:
					case ACCESS:
					case ACTION:
					case ADD:
					case ADMIN:
					case AFTER:
					case AGGREGATE:
					case ALSO:
					case ALTER:
					case ALWAYS:
					case ASSERTION:
					case ASSIGNMENT:
					case AT:
					case ATTACH:
					case ATTRIBUTE:
					case BACKWARD:
					case BEFORE:
					case BEGIN:
					case BY:
					case CACHE:
					case CALL:
					case CALLED:
					case CASCADE:
					case CASCADED:
					case CATALOG:
					case CHAIN:
					case CHARACTERISTICS:
					case CHECKPOINT:
					case CLASS:
					case CLOSE:
					case CLUSTER:
					case COLUMNS:
					case COMMENT:
					case COMMENTS:
					case COMMIT:
					case COMMITTED:
					case CONFIGURATION:
					case CONFLICT:
					case CONNECTION:
					case CONSTRAINTS:
					case CONTENT:
					case CONTINUE:
					case CONVERSION:
					case COPY:
					case COST:
					case CSV:
					case CUBE:
					case CURRENT:
					case CURSOR:
					case CYCLE:
					case DATA:
					case DATABASE:
					case DAY:
					case DEALLOCATE:
					case DECLARE:
					case DEFAULTS:
					case DEFERRED:
					case DEFINER:
					case DELETE:
					case DELIMITER:
					case DELIMITERS:
					case DEPENDS:
					case DETACH:
					case DICTIONARY:
					case DISABLE:
					case DISCARD:
					case DOCUMENT:
					case DOMAIN:
					case DOUBLE:
					case DROP:
					case EACH:
					case ENABLE:
					case ENCODING:
					case ENCRYPTED:
					case ENUM:
					case ESCAPE:
					case EVENT:
					case EXCLUDE:
					case EXCLUDING:
					case EXCLUSIVE:
					case EXECUTE:
					case EXPLAIN:
					case EXTENSION:
					case EXTERNAL:
					case FAMILY:
					case FILTER:
					case FIRST:
					case FOLLOWING:
					case FORCE:
					case FORWARD:
					case FUNCTION:
					case FUNCTIONS:
					case GENERATED:
					case GLOBAL:
					case GRANTED:
					case GROUPS:
					case HANDLER:
					case HEADER:
					case HOLD:
					case HOUR:
					case IDENTITY:
					case IF:
					case IMMEDIATE:
					case IMMUTABLE:
					case IMPLICIT:
					case IMPORT:
					case INCLUDE:
					case INCLUDING:
					case INCREMENT:
					case INDEX:
					case INDEXES:
					case INHERIT:
					case INHERITS:
					case INLINE:
					case INPUT:
					case INSENSITIVE:
					case INSERT:
					case INSTEAD:
					case INVOKER:
					case ISOLATION:
					case KEY:
					case LABEL:
					case LANGUAGE:
					case LARGE:
					case LAST:
					case LEAKPROOF:
					case LEVEL:
					case LISTEN:
					case LOAD:
					case LOCAL:
					case LOCATION:
					case LOCK:
					case LOCKED:
					case LOGGED:
					case MAPPING:
					case MATCH:
					case MATERIALIZED:
					case MAXVALUE:
					case METHOD:
					case MINUTE:
					case MINVALUE:
					case MODE:
					case MONTH:
					case MOVE:
					case NAME:
					case NAMES:
					case NEW:
					case NEXT:
					case NO:
					case NOTHING:
					case NOTIFY:
					case NOWAIT:
					case NULLS:
					case OBJECT:
					case OF:
					case OFF:
					case OIDS:
					case OLD:
					case OPERATOR:
					case OPTION:
					case OPTIONS:
					case ORDINALITY:
					case OTHERS:
					case OVER:
					case OVERRIDING:
					case OWNED:
					case OWNER:
					case PARALLEL:
					case PARSER:
					case PARTIAL:
					case PARTITION:
					case PASSING:
					case PASSWORD:
					case PLANS:
					case POLICY:
					case PRECEDING:
					case PREPARE:
					case PREPARED:
					case PRESERVE:
					case PRIOR:
					case PRIVILEGES:
					case PROCEDURAL:
					case PROCEDURE:
					case PROCEDURES:
					case PROGRAM:
					case PUBLICATION:
					case QUOTE:
					case RANGE:
					case READ:
					case REASSIGN:
					case RECHECK:
					case RECURSIVE:
					case REF:
					case REFERENCING:
					case REFRESH:
					case REINDEX:
					case RELATIVE:
					case RELEASE:
					case RENAME:
					case REPEATABLE:
					case REPLACE:
					case REPLICA:
					case RESET:
					case RESTART:
					case RESTRICT:
					case RETURNS:
					case REVOKE:
					case ROLE:
					case ROLLBACK:
					case ROLLUP:
					case ROUTINE:
					case ROUTINES:
					case ROWS:
					case RULE:
					case SAVEPOINT:
					case SCHEMA:
					case SCHEMAS:
					case SCROLL:
					case SEARCH:
					case SECOND:
					case SECURITY:
					case SEQUENCE:
					case SEQUENCES:
					case SERIALIZABLE:
					case SERVER:
					case SESSION:
					case SET:
					case SETS:
					case SHARE:
					case SHOW:
					case SIMPLE:
					case SKIP_:
					case SNAPSHOT:
					case SQL:
					case STABLE:
					case STANDALONE:
					case START:
					case STATEMENT:
					case STATISTICS:
					case STDIN:
					case STDOUT:
					case STORAGE:
					case STORED:
					case STRICT:
					case STRIP:
					case SUBSCRIPTION:
					case SUPPORT:
					case SYSID:
					case SYSTEM:
					case TABLES:
					case TABLESPACE:
					case TEMP:
					case TEMPLATE:
					case TEMPORARY:
					case TEXT:
					case TIES:
					case TRANSACTION:
					case TRANSFORM:
					case TRIGGER:
					case TRUNCATE:
					case TRUSTED:
					case TYPE:
					case TYPES:
					case UNBOUNDED:
					case UNCOMMITTED:
					case UNENCRYPTED:
					case UNKNOWN:
					case UNLISTEN:
					case UNLOGGED:
					case UNTIL:
					case UPDATE:
					case VACUUM:
					case VALID:
					case VALIDATE:
					case VALIDATOR:
					case VALUE:
					case VARYING:
					case VERSION:
					case VIEW:
					case VIEWS:
					case VOLATILE:
					case WHITESPACE:
					case WITHIN:
					case WITHOUT:
					case WORK:
					case WRAPPER:
					case WRITE:
					case XML:
					case YEAR:
					case YES:
					case ZONE:
					case BETWEEN:
					case BIGINT:
					case BIT:
					case BOOLEAN:
					case CHAR:
					case CHARACTER:
					case COALESCE:
					case DEC:
					case DECIMAL:
					case EXISTS:
					case EXTRACT:
					case FLOAT:
					case GREATEST:
					case GROUPING:
					case INOUT:
					case INT:
					case INTEGER:
					case INTERVAL:
					case LEAST:
					case NATIONAL:
					case NCHAR:
					case NONE:
					case NULLIF:
					case NUMERIC:
					case OUT:
					case OVERLAY:
					case POSITION:
					case PRECISION:
					case REAL:
					case ROW:
					case SETOF:
					case SMALLINT:
					case SUBSTRING:
					case TIME:
					case TIMESTAMP:
					case TREAT:
					case TRIM:
					case VALUES:
					case VARCHAR:
					case XMLATTRIBUTES:
					case XMLCONCAT:
					case XMLELEMENT:
					case XMLEXISTS:
					case XMLFOREST:
					case XMLNAMESPACES:
					case XMLPARSE:
					case XMLPI:
					case XMLROOT:
					case XMLSERIALIZE:
					case XMLTABLE:
					case AUTHORIZATION:
					case BINARY:
					case COLLATION:
					case CONCURRENTLY:
					case CROSS:
					case CURRENT_SCHEMA:
					case FREEZE:
					case FULL:
					case ILIKE:
					case INNER:
					case IS:
					case ISNULL:
					case JOIN:
					case LEFT:
					case LIKE:
					case NATURAL:
					case NOTNULL:
					case OUTER:
					case OVERLAPS:
					case RIGHT:
					case SIMILAR:
					case TABLESAMPLE:
					case VERBOSE:
					case ALL:
					case ANY:
					case ARRAY:
					case CASE:
					case CAST:
					case CURRENT_CATALOG:
					case CURRENT_DATE:
					case CURRENT_TIME:
					case CURRENT_TIMESTAMP:
					case CURRENT_USER:
					case FALSE:
					case LOCALTIME:
					case LOCALTIMESTAMP:
					case NOT:
					case NULL:
					case ON:
					case SESSION_USER:
					case SOME:
					case TRUE:
					case USER:
					case ALIGNMENT:
					case BASETYPE:
					case BUFFERS:
					case BYPASSRLS:
					case CANONICAL:
					case CATEGORY:
					case COLLATABLE:
					case COMBINEFUNC:
					case COMMUTATOR:
					case CONNECT:
					case COSTS:
					case CREATEDB:
					case CREATEROLE:
					case DESERIALFUNC:
					case DETERMINISTIC:
					case DISABLE_PAGE_SKIPPING:
					case ELEMENT:
					case EXTENDED:
					case FINALFUNC:
					case FINALFUNC_EXTRA:
					case FINALFUNC_MODIFY:
					case FORCE_NOT_NULL:
					case FORCE_NULL:
					case FORCE_QUOTE:
					case FORMAT:
					case GETTOKEN:
					case HASH:
					case HASHES:
					case HEADLINE:
					case HYPOTHETICAL:
					case INDEX_CLEANUP:
					case INIT:
					case INITCOND:
					case INTERNALLENGTH:
					case JSON:
					case LC_COLLATE:
					case LC_CTYPE:
					case LEFTARG:
					case LEXIZE:
					case LEXTYPES:
					case LIST:
					case LOCALE:
					case LOGIN:
					case MAIN:
					case MERGES:
					case MFINALFUNC:
					case MFINALFUNC_EXTRA:
					case MFINALFUNC_MODIFY:
					case MINITCOND:
					case MINVFUNC:
					case MODULUS:
					case MSFUNC:
					case MSSPACE:
					case MSTYPE:
					case NEGATOR:
					case NOBYPASSRLS:
					case NOCREATEDB:
					case NOCREATEROLE:
					case NOINHERIT:
					case NOLOGIN:
					case NOREPLICATION:
					case NOSUPERUSER:
					case OUTPUT:
					case PASSEDBYVALUE:
					case PATH:
					case PERMISSIVE:
					case PLAIN:
					case PREFERRED:
					case PROVIDER:
					case READ_ONLY:
					case READ_WRITE:
					case RECEIVE:
					case REMAINDER:
					case REPLICATION:
					case RESTRICTED:
					case RESTRICTIVE:
					case RIGHTARG:
					case SAFE:
					case SEND:
					case SERIALFUNC:
					case SETTINGS:
					case SFUNC:
					case SHAREABLE:
					case SKIP_LOCKED:
					case SORTOP:
					case SSPACE:
					case STYPE:
					case SUBTYPE_DIFF:
					case SUBTYPE_OPCLASS:
					case SUBTYPE:
					case SUMMARY:
					case SUPERUSER:
					case TIMING:
					case TYPMOD_IN:
					case TYPMOD_OUT:
					case UNSAFE:
					case USAGE:
					case VARIABLE:
					case YAML:
					case ALIAS:
					case ASSERT:
					case CONSTANT:
					case DATATYPE:
					case DEBUG:
					case DETAIL:
					case DIAGNOSTICS:
					case ELSEIF:
					case ELSIF:
					case ERRCODE:
					case EXIT:
					case EXCEPTION:
					case FOREACH:
					case GET:
					case HINT:
					case INFO:
					case LOG:
					case LOOP:
					case MESSAGE:
					case NOTICE:
					case OPEN:
					case PERFORM:
					case QUERY:
					case RAISE:
					case RECORD:
					case RETURN:
					case REVERSE:
					case ROWTYPE:
					case SLICE:
					case SQLSTATE:
					case STACKED:
					case WARNING:
					case WHILE:
					case LEFT_PAREN:
					case PLUS:
					case MINUS:
					case MULTIPLY:
					case LESS_LESS:
					case GREATER_GREATER:
					case HASH_SIGN:
					case OP_CHARS:
					case NUMBER_LITERAL:
					case REAL_NUMBER:
					case DOLLAR_NUMBER:
					case Identifier:
					case QuotedIdentifier:
					case Character_String_Literal:
					case BeginDollarStringConstant:
						{
						State = 3151; vex(0);
						}
						break;
					case LEFT_BRACKET:
						{
						State = 3152; array_elements();
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
					}
					State = 3159;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
			}

			State = 3162; Match(RIGHT_BRACKET);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Indirection_varContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Dollar_numberContext dollar_number() {
			return GetRuleContext<Dollar_numberContext>(0);
		}
		public Indirection_listContext indirection_list() {
			return GetRuleContext<Indirection_listContext>(0);
		}
		public Indirection_varContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indirection_var; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIndirection_var(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Indirection_varContext indirection_var() {
		Indirection_varContext _localctx = new Indirection_varContext(Context, State);
		EnterRule(_localctx, 306, RULE_indirection_var);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3166;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ABORT:
			case ABSOLUTE:
			case ACCESS:
			case ACTION:
			case ADD:
			case ADMIN:
			case AFTER:
			case AGGREGATE:
			case ALSO:
			case ALTER:
			case ALWAYS:
			case ASSERTION:
			case ASSIGNMENT:
			case AT:
			case ATTACH:
			case ATTRIBUTE:
			case BACKWARD:
			case BEFORE:
			case BEGIN:
			case BY:
			case CACHE:
			case CALL:
			case CALLED:
			case CASCADE:
			case CASCADED:
			case CATALOG:
			case CHAIN:
			case CHARACTERISTICS:
			case CHECKPOINT:
			case CLASS:
			case CLOSE:
			case CLUSTER:
			case COLUMNS:
			case COMMENT:
			case COMMENTS:
			case COMMIT:
			case COMMITTED:
			case CONFIGURATION:
			case CONFLICT:
			case CONNECTION:
			case CONSTRAINTS:
			case CONTENT:
			case CONTINUE:
			case CONVERSION:
			case COPY:
			case COST:
			case CSV:
			case CUBE:
			case CURRENT:
			case CURSOR:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DAY:
			case DEALLOCATE:
			case DECLARE:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DELIMITER:
			case DELIMITERS:
			case DEPENDS:
			case DETACH:
			case DICTIONARY:
			case DISABLE:
			case DISCARD:
			case DOCUMENT:
			case DOMAIN:
			case DOUBLE:
			case DROP:
			case EACH:
			case ENABLE:
			case ENCODING:
			case ENCRYPTED:
			case ENUM:
			case ESCAPE:
			case EVENT:
			case EXCLUDE:
			case EXCLUDING:
			case EXCLUSIVE:
			case EXECUTE:
			case EXPLAIN:
			case EXTENSION:
			case EXTERNAL:
			case FAMILY:
			case FILTER:
			case FIRST:
			case FOLLOWING:
			case FORCE:
			case FORWARD:
			case FUNCTION:
			case FUNCTIONS:
			case GENERATED:
			case GLOBAL:
			case GRANTED:
			case GROUPS:
			case HANDLER:
			case HEADER:
			case HOLD:
			case HOUR:
			case IDENTITY:
			case IF:
			case IMMEDIATE:
			case IMMUTABLE:
			case IMPLICIT:
			case IMPORT:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDEX:
			case INDEXES:
			case INHERIT:
			case INHERITS:
			case INLINE:
			case INPUT:
			case INSENSITIVE:
			case INSERT:
			case INSTEAD:
			case INVOKER:
			case ISOLATION:
			case KEY:
			case LABEL:
			case LANGUAGE:
			case LARGE:
			case LAST:
			case LEAKPROOF:
			case LEVEL:
			case LISTEN:
			case LOAD:
			case LOCAL:
			case LOCATION:
			case LOCK:
			case LOCKED:
			case LOGGED:
			case MAPPING:
			case MATCH:
			case MATERIALIZED:
			case MAXVALUE:
			case METHOD:
			case MINUTE:
			case MINVALUE:
			case MODE:
			case MONTH:
			case MOVE:
			case NAME:
			case NAMES:
			case NEW:
			case NEXT:
			case NO:
			case NOTHING:
			case NOTIFY:
			case NOWAIT:
			case NULLS:
			case OBJECT:
			case OF:
			case OFF:
			case OIDS:
			case OLD:
			case OPERATOR:
			case OPTION:
			case OPTIONS:
			case ORDINALITY:
			case OTHERS:
			case OVER:
			case OVERRIDING:
			case OWNED:
			case OWNER:
			case PARALLEL:
			case PARSER:
			case PARTIAL:
			case PARTITION:
			case PASSING:
			case PASSWORD:
			case PLANS:
			case POLICY:
			case PRECEDING:
			case PREPARE:
			case PREPARED:
			case PRESERVE:
			case PRIOR:
			case PRIVILEGES:
			case PROCEDURAL:
			case PROCEDURE:
			case PROCEDURES:
			case PROGRAM:
			case PUBLICATION:
			case QUOTE:
			case RANGE:
			case READ:
			case REASSIGN:
			case RECHECK:
			case RECURSIVE:
			case REF:
			case REFERENCING:
			case REFRESH:
			case REINDEX:
			case RELATIVE:
			case RELEASE:
			case RENAME:
			case REPEATABLE:
			case REPLACE:
			case REPLICA:
			case RESET:
			case RESTART:
			case RESTRICT:
			case RETURNS:
			case REVOKE:
			case ROLE:
			case ROLLBACK:
			case ROLLUP:
			case ROUTINE:
			case ROUTINES:
			case ROWS:
			case RULE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMAS:
			case SCROLL:
			case SEARCH:
			case SECOND:
			case SECURITY:
			case SEQUENCE:
			case SEQUENCES:
			case SERIALIZABLE:
			case SERVER:
			case SESSION:
			case SET:
			case SETS:
			case SHARE:
			case SHOW:
			case SIMPLE:
			case SKIP_:
			case SNAPSHOT:
			case SQL:
			case STABLE:
			case STANDALONE:
			case START:
			case STATEMENT:
			case STATISTICS:
			case STDIN:
			case STDOUT:
			case STORAGE:
			case STORED:
			case STRICT:
			case STRIP:
			case SUBSCRIPTION:
			case SUPPORT:
			case SYSID:
			case SYSTEM:
			case TABLES:
			case TABLESPACE:
			case TEMP:
			case TEMPLATE:
			case TEMPORARY:
			case TEXT:
			case TIES:
			case TRANSACTION:
			case TRANSFORM:
			case TRIGGER:
			case TRUNCATE:
			case TRUSTED:
			case TYPE:
			case TYPES:
			case UNBOUNDED:
			case UNCOMMITTED:
			case UNENCRYPTED:
			case UNKNOWN:
			case UNLISTEN:
			case UNLOGGED:
			case UNTIL:
			case UPDATE:
			case VACUUM:
			case VALID:
			case VALIDATE:
			case VALIDATOR:
			case VALUE:
			case VARYING:
			case VERSION:
			case VIEW:
			case VIEWS:
			case VOLATILE:
			case WHITESPACE:
			case WITHIN:
			case WITHOUT:
			case WORK:
			case WRAPPER:
			case WRITE:
			case XML:
			case YEAR:
			case YES:
			case ZONE:
			case BETWEEN:
			case BIGINT:
			case BIT:
			case BOOLEAN:
			case CHAR:
			case CHARACTER:
			case COALESCE:
			case DEC:
			case DECIMAL:
			case EXISTS:
			case EXTRACT:
			case FLOAT:
			case GREATEST:
			case GROUPING:
			case INOUT:
			case INT:
			case INTEGER:
			case INTERVAL:
			case LEAST:
			case NATIONAL:
			case NCHAR:
			case NONE:
			case NULLIF:
			case NUMERIC:
			case OUT:
			case OVERLAY:
			case POSITION:
			case PRECISION:
			case REAL:
			case ROW:
			case SETOF:
			case SMALLINT:
			case SUBSTRING:
			case TIME:
			case TIMESTAMP:
			case TREAT:
			case TRIM:
			case VALUES:
			case VARCHAR:
			case XMLATTRIBUTES:
			case XMLCONCAT:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case ALIGNMENT:
			case BASETYPE:
			case BUFFERS:
			case BYPASSRLS:
			case CANONICAL:
			case CATEGORY:
			case COLLATABLE:
			case COMBINEFUNC:
			case COMMUTATOR:
			case CONNECT:
			case COSTS:
			case CREATEDB:
			case CREATEROLE:
			case DESERIALFUNC:
			case DETERMINISTIC:
			case DISABLE_PAGE_SKIPPING:
			case ELEMENT:
			case EXTENDED:
			case FINALFUNC:
			case FINALFUNC_EXTRA:
			case FINALFUNC_MODIFY:
			case FORCE_NOT_NULL:
			case FORCE_NULL:
			case FORCE_QUOTE:
			case FORMAT:
			case GETTOKEN:
			case HASH:
			case HASHES:
			case HEADLINE:
			case HYPOTHETICAL:
			case INDEX_CLEANUP:
			case INIT:
			case INITCOND:
			case INTERNALLENGTH:
			case JSON:
			case LC_COLLATE:
			case LC_CTYPE:
			case LEFTARG:
			case LEXIZE:
			case LEXTYPES:
			case LIST:
			case LOCALE:
			case LOGIN:
			case MAIN:
			case MERGES:
			case MFINALFUNC:
			case MFINALFUNC_EXTRA:
			case MFINALFUNC_MODIFY:
			case MINITCOND:
			case MINVFUNC:
			case MODULUS:
			case MSFUNC:
			case MSSPACE:
			case MSTYPE:
			case NEGATOR:
			case NOBYPASSRLS:
			case NOCREATEDB:
			case NOCREATEROLE:
			case NOINHERIT:
			case NOLOGIN:
			case NOREPLICATION:
			case NOSUPERUSER:
			case OUTPUT:
			case PASSEDBYVALUE:
			case PATH:
			case PERMISSIVE:
			case PLAIN:
			case PREFERRED:
			case PROVIDER:
			case READ_ONLY:
			case READ_WRITE:
			case RECEIVE:
			case REMAINDER:
			case REPLICATION:
			case RESTRICTED:
			case RESTRICTIVE:
			case RIGHTARG:
			case SAFE:
			case SEND:
			case SERIALFUNC:
			case SETTINGS:
			case SFUNC:
			case SHAREABLE:
			case SKIP_LOCKED:
			case SORTOP:
			case SSPACE:
			case STYPE:
			case SUBTYPE_DIFF:
			case SUBTYPE_OPCLASS:
			case SUBTYPE:
			case SUMMARY:
			case SUPERUSER:
			case TIMING:
			case TYPMOD_IN:
			case TYPMOD_OUT:
			case UNSAFE:
			case USAGE:
			case VARIABLE:
			case YAML:
			case ALIAS:
			case ASSERT:
			case CONSTANT:
			case DATATYPE:
			case DEBUG:
			case DETAIL:
			case DIAGNOSTICS:
			case ELSEIF:
			case ELSIF:
			case ERRCODE:
			case EXIT:
			case EXCEPTION:
			case FOREACH:
			case GET:
			case HINT:
			case INFO:
			case LOG:
			case LOOP:
			case MESSAGE:
			case NOTICE:
			case OPEN:
			case PERFORM:
			case QUERY:
			case RAISE:
			case RECORD:
			case RETURN:
			case REVERSE:
			case ROWTYPE:
			case SLICE:
			case SQLSTATE:
			case STACKED:
			case WARNING:
			case WHILE:
			case Identifier:
			case QuotedIdentifier:
				{
				State = 3164; identifier();
				}
				break;
			case DOLLAR_NUMBER:
				{
				State = 3165; dollar_number();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3169;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,484,Context) ) {
			case 1:
				{
				State = 3168; indirection_list();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Dollar_numberContext : ParserRuleContext {
		public ITerminalNode DOLLAR_NUMBER() { return GetToken(PlPgSqlParser.DOLLAR_NUMBER, 0); }
		public Dollar_numberContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dollar_number; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDollar_number(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Dollar_numberContext dollar_number() {
		Dollar_numberContext _localctx = new Dollar_numberContext(Context, State);
		EnterRule(_localctx, 308, RULE_dollar_number);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3171; Match(DOLLAR_NUMBER);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Comparison_modContext : ParserRuleContext {
		public ITerminalNode LEFT_PAREN() { return GetToken(PlPgSqlParser.LEFT_PAREN, 0); }
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlPgSqlParser.RIGHT_PAREN, 0); }
		public ITerminalNode ALL() { return GetToken(PlPgSqlParser.ALL, 0); }
		public ITerminalNode ANY() { return GetToken(PlPgSqlParser.ANY, 0); }
		public ITerminalNode SOME() { return GetToken(PlPgSqlParser.SOME, 0); }
		public VexContext vex() {
			return GetRuleContext<VexContext>(0);
		}
		public Select_stmt_no_parensContext select_stmt_no_parens() {
			return GetRuleContext<Select_stmt_no_parensContext>(0);
		}
		public Comparison_modContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_comparison_mod; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitComparison_mod(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Comparison_modContext comparison_mod() {
		Comparison_modContext _localctx = new Comparison_modContext(Context, State);
		EnterRule(_localctx, 310, RULE_comparison_mod);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3173;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 366)) & ~0x3f) == 0 && ((1L << (_la - 366)) & ((1L << (ALL - 366)) | (1L << (ANY - 366)) | (1L << (SOME - 366)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 3174; Match(LEFT_PAREN);
			State = 3177;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,485,Context) ) {
			case 1:
				{
				State = 3175; vex(0);
				}
				break;
			case 2:
				{
				State = 3176; select_stmt_no_parens();
				}
				break;
			}
			State = 3179; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Case_expressionContext : ParserRuleContext {
		public VexContext _vex;
		public IList<VexContext> _r = new List<VexContext>();
		public ITerminalNode CASE() { return GetToken(PlPgSqlParser.CASE, 0); }
		public ITerminalNode END() { return GetToken(PlPgSqlParser.END, 0); }
		public VexContext[] vex() {
			return GetRuleContexts<VexContext>();
		}
		public VexContext vex(int i) {
			return GetRuleContext<VexContext>(i);
		}
		public ITerminalNode[] WHEN() { return GetTokens(PlPgSqlParser.WHEN); }
		public ITerminalNode WHEN(int i) {
			return GetToken(PlPgSqlParser.WHEN, i);
		}
		public ITerminalNode[] THEN() { return GetTokens(PlPgSqlParser.THEN); }
		public ITerminalNode THEN(int i) {
			return GetToken(PlPgSqlParser.THEN, i);
		}
		public ITerminalNode ELSE() { return GetToken(PlPgSqlParser.ELSE, 0); }
		public Case_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_case_expression; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCase_expression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Case_expressionContext case_expression() {
		Case_expressionContext _localctx = new Case_expressionContext(Context, State);
		EnterRule(_localctx, 312, RULE_case_expression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3181; Match(CASE);
			State = 3183;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ABORT) | (1L << ABSOLUTE) | (1L << ACCESS) | (1L << ACTION) | (1L << ADD) | (1L << ADMIN) | (1L << AFTER) | (1L << AGGREGATE) | (1L << ALSO) | (1L << ALTER) | (1L << ALWAYS) | (1L << ASSERTION) | (1L << ASSIGNMENT) | (1L << AT) | (1L << ATTACH) | (1L << ATTRIBUTE) | (1L << BACKWARD) | (1L << BEFORE) | (1L << BEGIN) | (1L << BY) | (1L << CACHE) | (1L << CALL) | (1L << CALLED) | (1L << CASCADE) | (1L << CASCADED) | (1L << CATALOG) | (1L << CHAIN) | (1L << CHARACTERISTICS) | (1L << CHECKPOINT) | (1L << CLASS) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMENTS) | (1L << COMMIT) | (1L << COMMITTED) | (1L << CONFIGURATION) | (1L << CONFLICT) | (1L << CONNECTION) | (1L << CONSTRAINTS) | (1L << CONTENT) | (1L << CONTINUE) | (1L << CONVERSION) | (1L << COPY) | (1L << COST) | (1L << CSV) | (1L << CUBE) | (1L << CURRENT) | (1L << CURSOR) | (1L << CYCLE) | (1L << DATA) | (1L << DATABASE) | (1L << DAY) | (1L << DEALLOCATE) | (1L << DECLARE) | (1L << DEFAULTS) | (1L << DEFERRED) | (1L << DEFINER) | (1L << DELETE) | (1L << DELIMITER) | (1L << DELIMITERS) | (1L << DEPENDS))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (DETACH - 64)) | (1L << (DICTIONARY - 64)) | (1L << (DISABLE - 64)) | (1L << (DISCARD - 64)) | (1L << (DOCUMENT - 64)) | (1L << (DOMAIN - 64)) | (1L << (DOUBLE - 64)) | (1L << (DROP - 64)) | (1L << (EACH - 64)) | (1L << (ENABLE - 64)) | (1L << (ENCODING - 64)) | (1L << (ENCRYPTED - 64)) | (1L << (ENUM - 64)) | (1L << (ESCAPE - 64)) | (1L << (EVENT - 64)) | (1L << (EXCLUDE - 64)) | (1L << (EXCLUDING - 64)) | (1L << (EXCLUSIVE - 64)) | (1L << (EXECUTE - 64)) | (1L << (EXPLAIN - 64)) | (1L << (EXTENSION - 64)) | (1L << (EXTERNAL - 64)) | (1L << (FAMILY - 64)) | (1L << (FILTER - 64)) | (1L << (FIRST - 64)) | (1L << (FOLLOWING - 64)) | (1L << (FORCE - 64)) | (1L << (FORWARD - 64)) | (1L << (FUNCTION - 64)) | (1L << (FUNCTIONS - 64)) | (1L << (GENERATED - 64)) | (1L << (GLOBAL - 64)) | (1L << (GRANTED - 64)) | (1L << (GROUPS - 64)) | (1L << (HANDLER - 64)) | (1L << (HEADER - 64)) | (1L << (HOLD - 64)) | (1L << (HOUR - 64)) | (1L << (IDENTITY - 64)) | (1L << (IF - 64)) | (1L << (IMMEDIATE - 64)) | (1L << (IMMUTABLE - 64)) | (1L << (IMPLICIT - 64)) | (1L << (IMPORT - 64)) | (1L << (INCLUDE - 64)) | (1L << (INCLUDING - 64)) | (1L << (INCREMENT - 64)) | (1L << (INDEX - 64)) | (1L << (INDEXES - 64)) | (1L << (INHERIT - 64)) | (1L << (INHERITS - 64)) | (1L << (INLINE - 64)) | (1L << (INPUT - 64)) | (1L << (INSENSITIVE - 64)) | (1L << (INSERT - 64)) | (1L << (INSTEAD - 64)) | (1L << (INVOKER - 64)) | (1L << (ISOLATION - 64)) | (1L << (KEY - 64)) | (1L << (LABEL - 64)) | (1L << (LANGUAGE - 64)) | (1L << (LARGE - 64)) | (1L << (LAST - 64)) | (1L << (LEAKPROOF - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (LEVEL - 128)) | (1L << (LISTEN - 128)) | (1L << (LOAD - 128)) | (1L << (LOCAL - 128)) | (1L << (LOCATION - 128)) | (1L << (LOCK - 128)) | (1L << (LOCKED - 128)) | (1L << (LOGGED - 128)) | (1L << (MAPPING - 128)) | (1L << (MATCH - 128)) | (1L << (MATERIALIZED - 128)) | (1L << (MAXVALUE - 128)) | (1L << (METHOD - 128)) | (1L << (MINUTE - 128)) | (1L << (MINVALUE - 128)) | (1L << (MODE - 128)) | (1L << (MONTH - 128)) | (1L << (MOVE - 128)) | (1L << (NAME - 128)) | (1L << (NAMES - 128)) | (1L << (NEW - 128)) | (1L << (NEXT - 128)) | (1L << (NO - 128)) | (1L << (NOTHING - 128)) | (1L << (NOTIFY - 128)) | (1L << (NOWAIT - 128)) | (1L << (NULLS - 128)) | (1L << (OBJECT - 128)) | (1L << (OF - 128)) | (1L << (OFF - 128)) | (1L << (OIDS - 128)) | (1L << (OLD - 128)) | (1L << (OPERATOR - 128)) | (1L << (OPTION - 128)) | (1L << (OPTIONS - 128)) | (1L << (ORDINALITY - 128)) | (1L << (OTHERS - 128)) | (1L << (OVER - 128)) | (1L << (OVERRIDING - 128)) | (1L << (OWNED - 128)) | (1L << (OWNER - 128)) | (1L << (PARALLEL - 128)) | (1L << (PARSER - 128)) | (1L << (PARTIAL - 128)) | (1L << (PARTITION - 128)) | (1L << (PASSING - 128)) | (1L << (PASSWORD - 128)) | (1L << (PLANS - 128)) | (1L << (POLICY - 128)) | (1L << (PRECEDING - 128)) | (1L << (PREPARE - 128)) | (1L << (PREPARED - 128)) | (1L << (PRESERVE - 128)) | (1L << (PRIOR - 128)) | (1L << (PRIVILEGES - 128)) | (1L << (PROCEDURAL - 128)) | (1L << (PROCEDURE - 128)) | (1L << (PROCEDURES - 128)) | (1L << (PROGRAM - 128)) | (1L << (PUBLICATION - 128)) | (1L << (QUOTE - 128)) | (1L << (RANGE - 128)) | (1L << (READ - 128)) | (1L << (REASSIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (RECHECK - 192)) | (1L << (RECURSIVE - 192)) | (1L << (REF - 192)) | (1L << (REFERENCING - 192)) | (1L << (REFRESH - 192)) | (1L << (REINDEX - 192)) | (1L << (RELATIVE - 192)) | (1L << (RELEASE - 192)) | (1L << (RENAME - 192)) | (1L << (REPEATABLE - 192)) | (1L << (REPLACE - 192)) | (1L << (REPLICA - 192)) | (1L << (RESET - 192)) | (1L << (RESTART - 192)) | (1L << (RESTRICT - 192)) | (1L << (RETURNS - 192)) | (1L << (REVOKE - 192)) | (1L << (ROLE - 192)) | (1L << (ROLLBACK - 192)) | (1L << (ROLLUP - 192)) | (1L << (ROUTINE - 192)) | (1L << (ROUTINES - 192)) | (1L << (ROWS - 192)) | (1L << (RULE - 192)) | (1L << (SAVEPOINT - 192)) | (1L << (SCHEMA - 192)) | (1L << (SCHEMAS - 192)) | (1L << (SCROLL - 192)) | (1L << (SEARCH - 192)) | (1L << (SECOND - 192)) | (1L << (SECURITY - 192)) | (1L << (SEQUENCE - 192)) | (1L << (SEQUENCES - 192)) | (1L << (SERIALIZABLE - 192)) | (1L << (SERVER - 192)) | (1L << (SESSION - 192)) | (1L << (SET - 192)) | (1L << (SETS - 192)) | (1L << (SHARE - 192)) | (1L << (SHOW - 192)) | (1L << (SIMPLE - 192)) | (1L << (SKIP_ - 192)) | (1L << (SNAPSHOT - 192)) | (1L << (SQL - 192)) | (1L << (STABLE - 192)) | (1L << (STANDALONE - 192)) | (1L << (START - 192)) | (1L << (STATEMENT - 192)) | (1L << (STATISTICS - 192)) | (1L << (STDIN - 192)) | (1L << (STDOUT - 192)) | (1L << (STORAGE - 192)) | (1L << (STORED - 192)) | (1L << (STRICT - 192)) | (1L << (STRIP - 192)) | (1L << (SUBSCRIPTION - 192)) | (1L << (SUPPORT - 192)) | (1L << (SYSID - 192)) | (1L << (SYSTEM - 192)) | (1L << (TABLES - 192)) | (1L << (TABLESPACE - 192)) | (1L << (TEMP - 192)) | (1L << (TEMPLATE - 192)) | (1L << (TEMPORARY - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (TEXT - 256)) | (1L << (TIES - 256)) | (1L << (TRANSACTION - 256)) | (1L << (TRANSFORM - 256)) | (1L << (TRIGGER - 256)) | (1L << (TRUNCATE - 256)) | (1L << (TRUSTED - 256)) | (1L << (TYPE - 256)) | (1L << (TYPES - 256)) | (1L << (UNBOUNDED - 256)) | (1L << (UNCOMMITTED - 256)) | (1L << (UNENCRYPTED - 256)) | (1L << (UNKNOWN - 256)) | (1L << (UNLISTEN - 256)) | (1L << (UNLOGGED - 256)) | (1L << (UNTIL - 256)) | (1L << (UPDATE - 256)) | (1L << (VACUUM - 256)) | (1L << (VALID - 256)) | (1L << (VALIDATE - 256)) | (1L << (VALIDATOR - 256)) | (1L << (VALUE - 256)) | (1L << (VARYING - 256)) | (1L << (VERSION - 256)) | (1L << (VIEW - 256)) | (1L << (VIEWS - 256)) | (1L << (VOLATILE - 256)) | (1L << (WHITESPACE - 256)) | (1L << (WITHIN - 256)) | (1L << (WITHOUT - 256)) | (1L << (WORK - 256)) | (1L << (WRAPPER - 256)) | (1L << (WRITE - 256)) | (1L << (XML - 256)) | (1L << (YEAR - 256)) | (1L << (YES - 256)) | (1L << (ZONE - 256)) | (1L << (BETWEEN - 256)) | (1L << (BIGINT - 256)) | (1L << (BIT - 256)) | (1L << (BOOLEAN - 256)) | (1L << (CHAR - 256)) | (1L << (CHARACTER - 256)) | (1L << (COALESCE - 256)) | (1L << (DEC - 256)) | (1L << (DECIMAL - 256)) | (1L << (EXISTS - 256)) | (1L << (EXTRACT - 256)) | (1L << (FLOAT - 256)) | (1L << (GREATEST - 256)) | (1L << (GROUPING - 256)) | (1L << (INOUT - 256)) | (1L << (INT - 256)) | (1L << (INTEGER - 256)) | (1L << (INTERVAL - 256)) | (1L << (LEAST - 256)) | (1L << (NATIONAL - 256)) | (1L << (NCHAR - 256)) | (1L << (NONE - 256)) | (1L << (NULLIF - 256)) | (1L << (NUMERIC - 256)) | (1L << (OUT - 256)) | (1L << (OVERLAY - 256)) | (1L << (POSITION - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (PRECISION - 320)) | (1L << (REAL - 320)) | (1L << (ROW - 320)) | (1L << (SETOF - 320)) | (1L << (SMALLINT - 320)) | (1L << (SUBSTRING - 320)) | (1L << (TIME - 320)) | (1L << (TIMESTAMP - 320)) | (1L << (TREAT - 320)) | (1L << (TRIM - 320)) | (1L << (VALUES - 320)) | (1L << (VARCHAR - 320)) | (1L << (XMLATTRIBUTES - 320)) | (1L << (XMLCONCAT - 320)) | (1L << (XMLELEMENT - 320)) | (1L << (XMLEXISTS - 320)) | (1L << (XMLFOREST - 320)) | (1L << (XMLNAMESPACES - 320)) | (1L << (XMLPARSE - 320)) | (1L << (XMLPI - 320)) | (1L << (XMLROOT - 320)) | (1L << (XMLSERIALIZE - 320)) | (1L << (XMLTABLE - 320)) | (1L << (AUTHORIZATION - 320)) | (1L << (BINARY - 320)) | (1L << (COLLATION - 320)) | (1L << (CONCURRENTLY - 320)) | (1L << (CROSS - 320)) | (1L << (CURRENT_SCHEMA - 320)) | (1L << (FREEZE - 320)) | (1L << (FULL - 320)) | (1L << (ILIKE - 320)) | (1L << (INNER - 320)) | (1L << (IS - 320)) | (1L << (ISNULL - 320)) | (1L << (JOIN - 320)) | (1L << (LEFT - 320)) | (1L << (LIKE - 320)) | (1L << (NATURAL - 320)) | (1L << (NOTNULL - 320)) | (1L << (OUTER - 320)) | (1L << (OVERLAPS - 320)) | (1L << (RIGHT - 320)) | (1L << (SIMILAR - 320)) | (1L << (TABLESAMPLE - 320)) | (1L << (VERBOSE - 320)) | (1L << (ALL - 320)) | (1L << (ANY - 320)) | (1L << (ARRAY - 320)) | (1L << (CASE - 320)) | (1L << (CAST - 320)) | (1L << (CURRENT_CATALOG - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (CURRENT_DATE - 384)) | (1L << (CURRENT_TIME - 384)) | (1L << (CURRENT_TIMESTAMP - 384)) | (1L << (CURRENT_USER - 384)) | (1L << (FALSE - 384)) | (1L << (LOCALTIME - 384)) | (1L << (LOCALTIMESTAMP - 384)) | (1L << (NOT - 384)) | (1L << (NULL - 384)) | (1L << (ON - 384)) | (1L << (SESSION_USER - 384)) | (1L << (SOME - 384)) | (1L << (TRUE - 384)) | (1L << (USER - 384)) | (1L << (ALIGNMENT - 384)) | (1L << (BASETYPE - 384)) | (1L << (BUFFERS - 384)) | (1L << (BYPASSRLS - 384)) | (1L << (CANONICAL - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (CATEGORY - 448)) | (1L << (COLLATABLE - 448)) | (1L << (COMBINEFUNC - 448)) | (1L << (COMMUTATOR - 448)) | (1L << (CONNECT - 448)) | (1L << (COSTS - 448)) | (1L << (CREATEDB - 448)) | (1L << (CREATEROLE - 448)) | (1L << (DESERIALFUNC - 448)) | (1L << (DETERMINISTIC - 448)) | (1L << (DISABLE_PAGE_SKIPPING - 448)) | (1L << (ELEMENT - 448)) | (1L << (EXTENDED - 448)) | (1L << (FINALFUNC - 448)) | (1L << (FINALFUNC_EXTRA - 448)) | (1L << (FINALFUNC_MODIFY - 448)) | (1L << (FORCE_NOT_NULL - 448)) | (1L << (FORCE_NULL - 448)) | (1L << (FORCE_QUOTE - 448)) | (1L << (FORMAT - 448)) | (1L << (GETTOKEN - 448)) | (1L << (HASH - 448)) | (1L << (HASHES - 448)) | (1L << (HEADLINE - 448)) | (1L << (HYPOTHETICAL - 448)) | (1L << (INDEX_CLEANUP - 448)) | (1L << (INIT - 448)) | (1L << (INITCOND - 448)) | (1L << (INTERNALLENGTH - 448)) | (1L << (JSON - 448)) | (1L << (LC_COLLATE - 448)) | (1L << (LC_CTYPE - 448)) | (1L << (LEFTARG - 448)) | (1L << (LEXIZE - 448)) | (1L << (LEXTYPES - 448)) | (1L << (LIST - 448)) | (1L << (LOCALE - 448)) | (1L << (LOGIN - 448)) | (1L << (MAIN - 448)) | (1L << (MERGES - 448)) | (1L << (MFINALFUNC - 448)) | (1L << (MFINALFUNC_EXTRA - 448)) | (1L << (MFINALFUNC_MODIFY - 448)) | (1L << (MINITCOND - 448)) | (1L << (MINVFUNC - 448)) | (1L << (MODULUS - 448)) | (1L << (MSFUNC - 448)) | (1L << (MSSPACE - 448)) | (1L << (MSTYPE - 448)) | (1L << (NEGATOR - 448)) | (1L << (NOBYPASSRLS - 448)) | (1L << (NOCREATEDB - 448)) | (1L << (NOCREATEROLE - 448)) | (1L << (NOINHERIT - 448)) | (1L << (NOLOGIN - 448)) | (1L << (NOREPLICATION - 448)) | (1L << (NOSUPERUSER - 448)) | (1L << (OUTPUT - 448)) | (1L << (PASSEDBYVALUE - 448)) | (1L << (PATH - 448)) | (1L << (PERMISSIVE - 448)) | (1L << (PLAIN - 448)) | (1L << (PREFERRED - 448)) | (1L << (PROVIDER - 448)))) != 0) || ((((_la - 512)) & ~0x3f) == 0 && ((1L << (_la - 512)) & ((1L << (READ_ONLY - 512)) | (1L << (READ_WRITE - 512)) | (1L << (RECEIVE - 512)) | (1L << (REMAINDER - 512)) | (1L << (REPLICATION - 512)) | (1L << (RESTRICTED - 512)) | (1L << (RESTRICTIVE - 512)) | (1L << (RIGHTARG - 512)) | (1L << (SAFE - 512)) | (1L << (SEND - 512)) | (1L << (SERIALFUNC - 512)) | (1L << (SETTINGS - 512)) | (1L << (SFUNC - 512)) | (1L << (SHAREABLE - 512)) | (1L << (SKIP_LOCKED - 512)) | (1L << (SORTOP - 512)) | (1L << (SSPACE - 512)) | (1L << (STYPE - 512)) | (1L << (SUBTYPE_DIFF - 512)) | (1L << (SUBTYPE_OPCLASS - 512)) | (1L << (SUBTYPE - 512)) | (1L << (SUMMARY - 512)) | (1L << (SUPERUSER - 512)) | (1L << (TIMING - 512)) | (1L << (TYPMOD_IN - 512)) | (1L << (TYPMOD_OUT - 512)) | (1L << (UNSAFE - 512)) | (1L << (USAGE - 512)) | (1L << (VARIABLE - 512)) | (1L << (YAML - 512)) | (1L << (ALIAS - 512)) | (1L << (ASSERT - 512)) | (1L << (CONSTANT - 512)) | (1L << (DATATYPE - 512)) | (1L << (DEBUG - 512)) | (1L << (DETAIL - 512)) | (1L << (DIAGNOSTICS - 512)) | (1L << (ELSEIF - 512)) | (1L << (ELSIF - 512)) | (1L << (ERRCODE - 512)) | (1L << (EXIT - 512)) | (1L << (EXCEPTION - 512)) | (1L << (FOREACH - 512)) | (1L << (GET - 512)) | (1L << (HINT - 512)) | (1L << (INFO - 512)) | (1L << (LOG - 512)) | (1L << (LOOP - 512)) | (1L << (MESSAGE - 512)) | (1L << (NOTICE - 512)) | (1L << (OPEN - 512)) | (1L << (PERFORM - 512)) | (1L << (QUERY - 512)) | (1L << (RAISE - 512)) | (1L << (RECORD - 512)) | (1L << (RETURN - 512)) | (1L << (REVERSE - 512)) | (1L << (ROWTYPE - 512)) | (1L << (SLICE - 512)) | (1L << (SQLSTATE - 512)) | (1L << (STACKED - 512)) | (1L << (WARNING - 512)) | (1L << (WHILE - 512)))) != 0) || ((((_la - 585)) & ~0x3f) == 0 && ((1L << (_la - 585)) & ((1L << (LEFT_PAREN - 585)) | (1L << (PLUS - 585)) | (1L << (MINUS - 585)) | (1L << (MULTIPLY - 585)) | (1L << (LESS_LESS - 585)) | (1L << (GREATER_GREATER - 585)) | (1L << (HASH_SIGN - 585)) | (1L << (OP_CHARS - 585)) | (1L << (NUMBER_LITERAL - 585)) | (1L << (REAL_NUMBER - 585)) | (1L << (DOLLAR_NUMBER - 585)) | (1L << (Identifier - 585)) | (1L << (QuotedIdentifier - 585)) | (1L << (Character_String_Literal - 585)) | (1L << (BeginDollarStringConstant - 585)))) != 0)) {
				{
				State = 3182; vex(0);
				}
			}

			State = 3190;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 3185; Match(WHEN);
				State = 3186; vex(0);
				State = 3187; Match(THEN);
				State = 3188; _localctx._vex = vex(0);
				_localctx._r.Add(_localctx._vex);
				}
				}
				State = 3192;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==WHEN );
			State = 3196;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ELSE) {
				{
				State = 3194; Match(ELSE);
				State = 3195; _localctx._vex = vex(0);
				_localctx._r.Add(_localctx._vex);
				}
			}

			State = 3198; Match(END);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Unsigned_value_specificationContext : ParserRuleContext {
		public Unsigned_numeric_literalContext unsigned_numeric_literal() {
			return GetRuleContext<Unsigned_numeric_literalContext>(0);
		}
		public Character_stringContext character_string() {
			return GetRuleContext<Character_stringContext>(0);
		}
		public Truth_valueContext truth_value() {
			return GetRuleContext<Truth_valueContext>(0);
		}
		public Unsigned_value_specificationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unsigned_value_specification; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnsigned_value_specification(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Unsigned_value_specificationContext unsigned_value_specification() {
		Unsigned_value_specificationContext _localctx = new Unsigned_value_specificationContext(Context, State);
		EnterRule(_localctx, 314, RULE_unsigned_value_specification);
		try {
			State = 3203;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case NUMBER_LITERAL:
			case REAL_NUMBER:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3200; unsigned_numeric_literal();
				}
				break;
			case Character_String_Literal:
			case BeginDollarStringConstant:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3201; character_string();
				}
				break;
			case FALSE:
			case ON:
			case TRUE:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3202; truth_value();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Unsigned_numeric_literalContext : ParserRuleContext {
		public ITerminalNode NUMBER_LITERAL() { return GetToken(PlPgSqlParser.NUMBER_LITERAL, 0); }
		public ITerminalNode REAL_NUMBER() { return GetToken(PlPgSqlParser.REAL_NUMBER, 0); }
		public Unsigned_numeric_literalContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unsigned_numeric_literal; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnsigned_numeric_literal(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Unsigned_numeric_literalContext unsigned_numeric_literal() {
		Unsigned_numeric_literalContext _localctx = new Unsigned_numeric_literalContext(Context, State);
		EnterRule(_localctx, 316, RULE_unsigned_numeric_literal);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3205;
			_la = TokenStream.LA(1);
			if ( !(_la==NUMBER_LITERAL || _la==REAL_NUMBER) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Type_listContext : ParserRuleContext {
		public Data_typeContext[] data_type() {
			return GetRuleContexts<Data_typeContext>();
		}
		public Data_typeContext data_type(int i) {
			return GetRuleContext<Data_typeContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlPgSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlPgSqlParser.COMMA, i);
		}
		public Type_listContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type_list; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType_list(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Type_listContext type_list() {
		Type_listContext _localctx = new Type_listContext(Context, State);
		EnterRule(_localctx, 318, RULE_type_list);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3207; data_type();
			State = 3212;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 3208; Match(COMMA);
				State = 3209; data_type();
				}
				}
				State = 3214;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VexContext : ParserRuleContext {
		public ITerminalNode LEFT_PAREN() { return GetToken(PlPgSqlParser.LEFT_PAREN, 0); }
		public VexContext[] vex() {
			return GetRuleContexts<VexContext>();
		}
		public VexContext vex(int i) {
			return GetRuleContext<VexContext>(i);
		}
		public ITerminalNode RIGHT_PAREN() { return GetToken(PlPgSqlParser.RIGHT_PAREN, 0); }
		public Indirection_listContext indirection_list() {
			return GetRuleContext<Indirection_listContext>(0);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PlPgSqlParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PlPgSqlParser.COMMA, i);
		}
		public ITerminalNode PLUS() { return GetToken(PlPgSqlParser.PLUS, 0); }
		public ITerminalNode MINUS() { return GetToken(PlPgSqlParser.MINUS, 0); }
		public OpContext op() {
			return GetRuleContext<OpContext>(0);
		}
		public ITerminalNode NOT() { return GetToken(PlPgSqlParser.NOT, 0); }
		public Value_expression_primaryContext value_expression_primary() {
			return GetRuleContext<Value_expression_primaryContext>(0);
		}
		public ITerminalNode AT() { return GetToken(PlPgSqlParser.AT, 0); }
		public ITerminalNode TIME() { return GetToken(PlPgSqlParser.TIME, 0); }
		public ITerminalNode ZONE() { return GetToken(PlPgSqlParser.ZONE, 0); }
		public ITerminalNode EXP() { return GetToken(PlPgSqlParser.EXP, 0); }
		public ITerminalNode MULTIPLY() { return GetToken(PlPgSqlParser.MULTIPLY, 0); }
		public ITerminalNode DIVIDE() { return GetToken(PlPgSqlParser.DIVIDE, 0); }
		public ITerminalNode MODULAR() { return GetToken(PlPgSqlParser.MODULAR, 0); }
		public ITerminalNode BETWEEN() { return GetToken(PlPgSqlParser.BETWEEN, 0); }
		public Vex_bContext vex_b() {
			return GetRuleContext<Vex_bContext>(0);
		}
		public ITerminalNode AND() { return GetToken(PlPgSqlParser.AND, 0); }
		public ITerminalNode ASYMMETRIC() { return GetToken(PlPgSqlParser.ASYMMETRIC, 0); }
		public ITerminalNode SYMMETRIC() { return GetToken(PlPgSqlParser.SYMMETRIC, 0); }
		public ITerminalNode LIKE() { return GetToken(PlPgSqlParser.LIKE, 0); }
		public ITerminalNode ILIKE() { return GetToken(PlPgSqlParser.ILIKE, 0); }
		public ITerminalNode SIMILAR() { return GetToken(PlPgSqlParser.SIMILAR, 0); }
		public ITerminalNode TO() { return GetToken(PlPgSqlParser.TO, 0); }
		public ITerminalNode ESCAPE() { return GetToken(PlPgSqlParser.ESCAPE, 0); }
		public ITerminalNode LTH() { return GetToken(PlPgSqlParser.LTH, 0); }
		public ITerminalNode GTH() { return GetToken(PlPgSqlParser.GTH, 0); }
		public ITerminalNode LEQ() { return GetToken(PlPgSqlParser.LEQ, 0); }
		public ITerminalNode GEQ() { return GetToken(PlPgSqlParser.GEQ, 0); }
		public ITerminalNode EQUAL() { return GetToken(PlPgSqlParser.EQUAL, 0); }
		public ITerminalNode NOT_EQUAL() { return GetToken(PlPgSqlParser.NOT_EQUAL, 0); }
		public ITerminalNode IS() { return GetToken(PlPgSqlParser.IS, 0); }
		public ITerminalNode DISTINCT() { return GetToken(PlPgSqlParser.DISTINCT, 0); }
		public ITerminalNode FROM() { return GetToken(PlPgSqlParser.FROM, 0); }
		public ITerminalNode OR() { return GetToken(PlPgSqlParser.OR, 0); }
		public ITerminalNode CAST_EXPRESSION() { return GetToken(PlPgSqlParser.CAST_EXPRESSION, 0); }
		public Data_typeContext data_type() {
			return GetRuleContext<Data_typeContext>(0);
		}
		public Collate_identifierContext collate_identifier() {
			return GetRuleContext<Collate_identifierContext>(0);
		}
		public ITerminalNode IN() { return GetToken(PlPgSqlParser.IN, 0); }
		public Select_stmt_no_parensContext select_stmt_no_parens() {
			return GetRuleContext<Select_stmt_no_parensContext>(0);
		}
		public Truth_valueContext truth_value() {
			return GetRuleContext<Truth_valueContext>(0);
		}
		public ITerminalNode NULL() { return GetToken(PlPgSqlParser.NULL, 0); }
		public ITerminalNode DOCUMENT() { return GetToken(PlPgSqlParser.DOCUMENT, 0); }
		public ITerminalNode UNKNOWN() { return GetToken(PlPgSqlParser.UNKNOWN, 0); }
		public ITerminalNode OF() { return GetToken(PlPgSqlParser.OF, 0); }
		public Type_listContext type_list() {
			return GetRuleContext<Type_listContext>(0);
		}
		public ITerminalNode ISNULL() { return GetToken(PlPgSqlParser.ISNULL, 0); }
		public ITerminalNode NOTNULL() { return GetToken(PlPgSqlParser.NOTNULL, 0); }
		public VexContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_vex; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVex(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public VexContext vex() {
		return vex(0);
	}

	private VexContext vex(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		VexContext _localctx = new VexContext(Context, _parentState);
		VexContext _prevctx = _localctx;
		int _startState = 320;
		EnterRecursionRule(_localctx, 320, RULE_vex, _p);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 3240;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,493,Context) ) {
			case 1:
				{
				State = 3216; Match(LEFT_PAREN);
				State = 3217; vex(0);
				State = 3218; Match(RIGHT_PAREN);
				State = 3220;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,491,Context) ) {
				case 1:
					{
					State = 3219; indirection_list();
					}
					break;
				}
				}
				break;
			case 2:
				{
				State = 3222; Match(LEFT_PAREN);
				State = 3223; vex(0);
				State = 3226;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					{
					State = 3224; Match(COMMA);
					State = 3225; vex(0);
					}
					}
					State = 3228;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( _la==COMMA );
				State = 3230; Match(RIGHT_PAREN);
				}
				break;
			case 3:
				{
				State = 3232;
				_la = TokenStream.LA(1);
				if ( !(_la==PLUS || _la==MINUS) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 3233; vex(24);
				}
				break;
			case 4:
				{
				State = 3234; op();
				State = 3235; vex(18);
				}
				break;
			case 5:
				{
				State = 3237; Match(NOT);
				State = 3238; vex(4);
				}
				break;
			case 6:
				{
				State = 3239; value_expression_primary();
				}
				break;
			}
			Context.Stop = TokenStream.LT(-1);
			State = 3377;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,510,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 3375;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,509,Context) ) {
					case 1:
						{
						_localctx = new VexContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_vex);
						State = 3242;
						if (!(Precpred(Context, 23))) throw new FailedPredicateException(this, "Precpred(Context, 23)");
						State = 3243; Match(AT);
						State = 3244; Match(TIME);
						State = 3245; Match(ZONE);
						State = 3246; vex(24);
						}
						break;
					case 2:
						{
						_localctx = new VexContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_vex);
						State = 3247;
						if (!(Precpred(Context, 22))) throw new FailedPredicateException(this, "Precpred(Context, 22)");
						State = 3248; Match(EXP);
						State = 3249; vex(23);
						}
						break;
					case 3:
						{
						_localctx = new VexContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_vex);
						State = 3250;
						if (!(Precpred(Context, 21))) throw new FailedPredicateException(this, "Precpred(Context, 21)");
						State = 3251;
						_la = TokenStream.LA(1);
						if ( !(((((_la - 589)) & ~0x3f) == 0 && ((1L << (_la - 589)) & ((1L << (MULTIPLY - 589)) | (1L << (DIVIDE - 589)) | (1L << (MODULAR - 589)))) != 0)) ) {
						ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 3252; vex(22);
						}
						break;
					case 4:
						{
						_localctx = new VexContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_vex);
						State = 3253;
						if (!(Precpred(Context, 20))) throw new FailedPredicateException(this, "Precpred(Context, 20)");
						State = 3254;
						_la = TokenStream.LA(1);
						if ( !(_la==PLUS || _la==MINUS) ) {
						ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 3255; vex(21);
						}
						break;
					case 5:
						{
						_localctx = new VexContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_vex);
						State = 3256;
						if (!(Precpred(Context, 19))) throw new FailedPredicateException(this, "Precpred(Context, 19)");
						State = 3257; op();
						State = 3258; vex(20);
						}
						break;
					case 6:
						{
						_localctx = new VexContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_vex);
						State = 3260;
						if (!(Precpred(Context, 15))) throw new FailedPredicateException(this, "Precpred(Context, 15)");
						State = 3262;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==NOT) {
							{
							State = 3261; Match(NOT);
							}
						}

						State = 3264; Match(BETWEEN);
						State = 3266;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==ASYMMETRIC || _la==SYMMETRIC) {
							{
							State = 3265;
							_la = TokenStream.LA(1);
							if ( !(_la==ASYMMETRIC || _la==SYMMETRIC) ) {
							ErrorHandler.RecoverInline(this);
							}
							else {
								ErrorHandler.ReportMatch(this);
							    Consume();
							}
							}
						}

						State = 3268; vex_b(0);
						State = 3269; Match(AND);
						State = 3270; vex(16);
						}
						break;
					case 7:
						{
						_localctx = new VexContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_vex);
						State = 3272;
						if (!(Precpred(Context, 14))) throw new FailedPredicateException(this, "Precpred(Context, 14)");
						State = 3274;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==NOT) {
							{
							State = 3273; Match(NOT);
							}
						}

						State = 3280;
						ErrorHandler.Sync(this);
						switch (TokenStream.LA(1)) {
						case LIKE:
							{
							State = 3276; Match(LIKE);
							}
							break;
						case ILIKE:
							{
							State = 3277; Match(ILIKE);
							}
							break;
						case SIMILAR:
							{
							State = 3278; Match(SIMILAR);
							State = 3279; Match(TO);
							}
							break;
						default:
							throw new NoViableAltException(this);
						}
						State = 3282; vex(15);
						}
						break;
					case 8:
						{
						_localctx = new VexContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_vex);
						State = 3283;
						if (!(Precpred(Context, 13))) throw new FailedPredicateException(this, "Precpred(Context, 13)");
						State = 3285;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==NOT) {
							{
							State = 3284; Match(NOT);
							}
						}

						State = 3291;
						ErrorHandler.Sync(this);
						switch (TokenStream.LA(1)) {
						case LIKE:
							{
							State = 3287; Match(LIKE);
							}
							break;
						case ILIKE:
							{
							State = 3288; Match(ILIKE);
							}
							break;
						case SIMILAR:
							{
							State = 3289; Match(SIMILAR);
							State = 3290; Match(TO);
							}
							break;
						default:
							throw new NoViableAltException(this);
						}
						State = 3293; vex(0);
						State = 3294; Match(ESCAPE);
						State = 3295; vex(14);
						}
						break;
					case 9:
						{
						_localctx = new VexContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_vex);
						State = 3297;
						if (!(Precpred(Context, 12))) throw new FailedPredicateException(this, "Precpred(Context, 12)");
						State = 3298;
						_la = TokenStream.LA(1);
						if ( !(((((_la - 576)) & ~0x3f) == 0 && ((1L << (_la - 576)) & ((1L << (EQUAL - 576)) | (1L << (NOT_EQUAL - 576)) | (1L << (LTH - 576)) | (1L << (LEQ - 576)) | (1L << (GTH - 576)) | (1L << (GEQ - 576)))) != 0)) ) {
						ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 3299; vex(13);
						}
						break;
					case 10:
						{
						_localctx = new VexContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_vex);
						State = 3300;
						if (!(Precpred(Context, 10))) throw new FailedPredicateException(this, "Precpred(Context, 10)");
						State = 3301; Match(IS);
						State = 3303;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==NOT) {
							{
							State = 3302; Match(NOT);
							}
						}

						State = 3305; Match(DISTINCT);
						State = 3306; Match(FROM);
						State = 3307; vex(11);
						}
						break;
					case 11:
						{
						_localctx = new VexContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_vex);
						State = 3308;
						if (!(Precpred(Context, 3))) throw new FailedPredicateException(this, "Precpred(Context, 3)");
						State = 3309; Match(AND);
						State = 3310; vex(4);
						}
						break;
					case 12:
						{
						_localctx = new VexContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_vex);
						State = 3311;
						if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
						State = 3312; Match(OR);
						State = 3313; vex(3);
						}
						break;
					case 13:
						{
						_localctx = new VexContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_vex);
						State = 3314;
						if (!(Precpred(Context, 28))) throw new FailedPredicateException(this, "Precpred(Context, 28)");
						State = 3315; Match(CAST_EXPRESSION);
						State = 3316; data_type();
						}
						break;
					case 14:
						{
						_localctx = new VexContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_vex);
						State = 3317;
						if (!(Precpred(Context, 25))) throw new FailedPredicateException(this, "Precpred(Context, 25)");
						State = 3318; collate_identifier();
						}
						break;
					case 15:
						{
						_localctx = new VexContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_vex);
						State = 3319;
						if (!(Precpred(Context, 17))) throw new FailedPredicateException(this, "Precpred(Context, 17)");
						State = 3320; op();
						}
						break;
					case 16:
						{
						_localctx = new VexContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_vex);
						State = 3321;
						if (!(Precpred(Context, 16))) throw new FailedPredicateException(this, "Precpred(Context, 16)");
						State = 3323;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==NOT) {
							{
							State = 3322; Match(NOT);
							}
						}

						State = 3325; Match(IN);
						State = 3326; Match(LEFT_PAREN);
						State = 3336;
						ErrorHandler.Sync(this);
						switch ( Interpreter.AdaptivePredict(TokenStream,503,Context) ) {
						case 1:
							{
							State = 3327; select_stmt_no_parens();
							}
							break;
						case 2:
							{
							State = 3328; vex(0);
							State = 3333;
							ErrorHandler.Sync(this);
							_la = TokenStream.LA(1);
							while (_la==COMMA) {
								{
								{
								State = 3329; Match(COMMA);
								State = 3330; vex(0);
								}
								}
								State = 3335;
								ErrorHandler.Sync(this);
								_la = TokenStream.LA(1);
							}
							}
							break;
						}
						State = 3338; Match(RIGHT_PAREN);
						}
						break;
					case 17:
						{
						_localctx = new VexContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_vex);
						State = 3340;
						if (!(Precpred(Context, 11))) throw new FailedPredicateException(this, "Precpred(Context, 11)");
						State = 3341; Match(IS);
						State = 3343;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==NOT) {
							{
							State = 3342; Match(NOT);
							}
						}

						State = 3347;
						ErrorHandler.Sync(this);
						switch (TokenStream.LA(1)) {
						case FALSE:
						case ON:
						case TRUE:
							{
							State = 3345; truth_value();
							}
							break;
						case NULL:
							{
							State = 3346; Match(NULL);
							}
							break;
						default:
							throw new NoViableAltException(this);
						}
						}
						break;
					case 18:
						{
						_localctx = new VexContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_vex);
						State = 3349;
						if (!(Precpred(Context, 9))) throw new FailedPredicateException(this, "Precpred(Context, 9)");
						State = 3350; Match(IS);
						State = 3352;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==NOT) {
							{
							State = 3351; Match(NOT);
							}
						}

						State = 3354; Match(DOCUMENT);
						}
						break;
					case 19:
						{
						_localctx = new VexContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_vex);
						State = 3355;
						if (!(Precpred(Context, 8))) throw new FailedPredicateException(this, "Precpred(Context, 8)");
						State = 3356; Match(IS);
						State = 3358;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==NOT) {
							{
							State = 3357; Match(NOT);
							}
						}

						State = 3360; Match(UNKNOWN);
						}
						break;
					case 20:
						{
						_localctx = new VexContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_vex);
						State = 3361;
						if (!(Precpred(Context, 7))) throw new FailedPredicateException(this, "Precpred(Context, 7)");
						State = 3362; Match(IS);
						State = 3364;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==NOT) {
							{
							State = 3363; Match(NOT);
							}
						}

						State = 3366; Match(OF);
						State = 3367; Match(LEFT_PAREN);
						State = 3368; type_list();
						State = 3369; Match(RIGHT_PAREN);
						}
						break;
					case 21:
						{
						_localctx = new VexContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_vex);
						State = 3371;
						if (!(Precpred(Context, 6))) throw new FailedPredicateException(this, "Precpred(Context, 6)");
						State = 3372; Match(ISNULL);
						}
						break;
					case 22:
						{
						_localctx = new VexContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_vex);
						State = 3373;
						if (!(Precpred(Context, 5))) throw new FailedPredicateException(this, "Precpred(Context, 5)");
						State = 3374; Match(NOTNULL);
						}
						break;
					}
					} 
				}
				State = 3379;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,510,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class Tokens_nonreservedContext : ParserRuleContext {
		public ITerminalNode ABORT() { return GetToken(PlPgSqlParser.ABORT, 0); }
		public ITerminalNode ABSOLUTE() { return GetToken(PlPgSqlParser.ABSOLUTE, 0); }
		public ITerminalNode ACCESS() { return GetToken(PlPgSqlParser.ACCESS, 0); }
		public ITerminalNode ACTION() { return GetToken(PlPgSqlParser.ACTION, 0); }
		public ITerminalNode ADD() { return GetToken(PlPgSqlParser.ADD, 0); }
		public ITerminalNode ADMIN() { return GetToken(PlPgSqlParser.ADMIN, 0); }
		public ITerminalNode AFTER() { return GetToken(PlPgSqlParser.AFTER, 0); }
		public ITerminalNode AGGREGATE() { return GetToken(PlPgSqlParser.AGGREGATE, 0); }
		public ITerminalNode ALSO() { return GetToken(PlPgSqlParser.ALSO, 0); }
		public ITerminalNode ALTER() { return GetToken(PlPgSqlParser.ALTER, 0); }
		public ITerminalNode ALWAYS() { return GetToken(PlPgSqlParser.ALWAYS, 0); }
		public ITerminalNode ASSERTION() { return GetToken(PlPgSqlParser.ASSERTION, 0); }
		public ITerminalNode ASSIGNMENT() { return GetToken(PlPgSqlParser.ASSIGNMENT, 0); }
		public ITerminalNode AT() { return GetToken(PlPgSqlParser.AT, 0); }
		public ITerminalNode ATTACH() { return GetToken(PlPgSqlParser.ATTACH, 0); }
		public ITerminalNode ATTRIBUTE() { return GetToken(PlPgSqlParser.ATTRIBUTE, 0); }
		public ITerminalNode BACKWARD() { return GetToken(PlPgSqlParser.BACKWARD, 0); }
		public ITerminalNode BEFORE() { return GetToken(PlPgSqlParser.BEFORE, 0); }
		public ITerminalNode BEGIN() { return GetToken(PlPgSqlParser.BEGIN, 0); }
		public ITerminalNode BY() { return GetToken(PlPgSqlParser.BY, 0); }
		public ITerminalNode CACHE() { return GetToken(PlPgSqlParser.CACHE, 0); }
		public ITerminalNode CALL() { return GetToken(PlPgSqlParser.CALL, 0); }
		public ITerminalNode CALLED() { return GetToken(PlPgSqlParser.CALLED, 0); }
		public ITerminalNode CASCADE() { return GetToken(PlPgSqlParser.CASCADE, 0); }
		public ITerminalNode CASCADED() { return GetToken(PlPgSqlParser.CASCADED, 0); }
		public ITerminalNode CATALOG() { return GetToken(PlPgSqlParser.CATALOG, 0); }
		public ITerminalNode CHAIN() { return GetToken(PlPgSqlParser.CHAIN, 0); }
		public ITerminalNode CHARACTERISTICS() { return GetToken(PlPgSqlParser.CHARACTERISTICS, 0); }
		public ITerminalNode CHECKPOINT() { return GetToken(PlPgSqlParser.CHECKPOINT, 0); }
		public ITerminalNode CLASS() { return GetToken(PlPgSqlParser.CLASS, 0); }
		public ITerminalNode CLOSE() { return GetToken(PlPgSqlParser.CLOSE, 0); }
		public ITerminalNode CLUSTER() { return GetToken(PlPgSqlParser.CLUSTER, 0); }
		public ITerminalNode COLUMNS() { return GetToken(PlPgSqlParser.COLUMNS, 0); }
		public ITerminalNode COMMENT() { return GetToken(PlPgSqlParser.COMMENT, 0); }
		public ITerminalNode COMMENTS() { return GetToken(PlPgSqlParser.COMMENTS, 0); }
		public ITerminalNode COMMIT() { return GetToken(PlPgSqlParser.COMMIT, 0); }
		public ITerminalNode COMMITTED() { return GetToken(PlPgSqlParser.COMMITTED, 0); }
		public ITerminalNode CONFIGURATION() { return GetToken(PlPgSqlParser.CONFIGURATION, 0); }
		public ITerminalNode CONFLICT() { return GetToken(PlPgSqlParser.CONFLICT, 0); }
		public ITerminalNode CONNECTION() { return GetToken(PlPgSqlParser.CONNECTION, 0); }
		public ITerminalNode CONSTRAINTS() { return GetToken(PlPgSqlParser.CONSTRAINTS, 0); }
		public ITerminalNode CONTENT() { return GetToken(PlPgSqlParser.CONTENT, 0); }
		public ITerminalNode CONTINUE() { return GetToken(PlPgSqlParser.CONTINUE, 0); }
		public ITerminalNode CONVERSION() { return GetToken(PlPgSqlParser.CONVERSION, 0); }
		public ITerminalNode COPY() { return GetToken(PlPgSqlParser.COPY, 0); }
		public ITerminalNode COST() { return GetToken(PlPgSqlParser.COST, 0); }
		public ITerminalNode CSV() { return GetToken(PlPgSqlParser.CSV, 0); }
		public ITerminalNode CUBE() { return GetToken(PlPgSqlParser.CUBE, 0); }
		public ITerminalNode CURRENT() { return GetToken(PlPgSqlParser.CURRENT, 0); }
		public ITerminalNode CURSOR() { return GetToken(PlPgSqlParser.CURSOR, 0); }
		public ITerminalNode CYCLE() { return GetToken(PlPgSqlParser.CYCLE, 0); }
		public ITerminalNode DATA() { return GetToken(PlPgSqlParser.DATA, 0); }
		public ITerminalNode DATABASE() { return GetToken(PlPgSqlParser.DATABASE, 0); }
		public ITerminalNode DAY() { return GetToken(PlPgSqlParser.DAY, 0); }
		public ITerminalNode DEALLOCATE() { return GetToken(PlPgSqlParser.DEALLOCATE, 0); }
		public ITerminalNode DECLARE() { return GetToken(PlPgSqlParser.DECLARE, 0); }
		public ITerminalNode DEFAULTS() { return GetToken(PlPgSqlParser.DEFAULTS, 0); }
		public ITerminalNode DEFERRED() { return GetToken(PlPgSqlParser.DEFERRED, 0); }
		public ITerminalNode DEFINER() { return GetToken(PlPgSqlParser.DEFINER, 0); }
		public ITerminalNode DELETE() { return GetToken(PlPgSqlParser.DELETE, 0); }
		public ITerminalNode DELIMITER() { return GetToken(PlPgSqlParser.DELIMITER, 0); }
		public ITerminalNode DELIMITERS() { return GetToken(PlPgSqlParser.DELIMITERS, 0); }
		public ITerminalNode DEPENDS() { return GetToken(PlPgSqlParser.DEPENDS, 0); }
		public ITerminalNode DETACH() { return GetToken(PlPgSqlParser.DETACH, 0); }
		public ITerminalNode DICTIONARY() { return GetToken(PlPgSqlParser.DICTIONARY, 0); }
		public ITerminalNode DISABLE() { return GetToken(PlPgSqlParser.DISABLE, 0); }
		public ITerminalNode DISCARD() { return GetToken(PlPgSqlParser.DISCARD, 0); }
		public ITerminalNode DOCUMENT() { return GetToken(PlPgSqlParser.DOCUMENT, 0); }
		public ITerminalNode DOMAIN() { return GetToken(PlPgSqlParser.DOMAIN, 0); }
		public ITerminalNode DOUBLE() { return GetToken(PlPgSqlParser.DOUBLE, 0); }
		public ITerminalNode DROP() { return GetToken(PlPgSqlParser.DROP, 0); }
		public ITerminalNode EACH() { return GetToken(PlPgSqlParser.EACH, 0); }
		public ITerminalNode ENABLE() { return GetToken(PlPgSqlParser.ENABLE, 0); }
		public ITerminalNode ENCODING() { return GetToken(PlPgSqlParser.ENCODING, 0); }
		public ITerminalNode ENCRYPTED() { return GetToken(PlPgSqlParser.ENCRYPTED, 0); }
		public ITerminalNode ENUM() { return GetToken(PlPgSqlParser.ENUM, 0); }
		public ITerminalNode ESCAPE() { return GetToken(PlPgSqlParser.ESCAPE, 0); }
		public ITerminalNode EVENT() { return GetToken(PlPgSqlParser.EVENT, 0); }
		public ITerminalNode EXCLUDE() { return GetToken(PlPgSqlParser.EXCLUDE, 0); }
		public ITerminalNode EXCLUDING() { return GetToken(PlPgSqlParser.EXCLUDING, 0); }
		public ITerminalNode EXCLUSIVE() { return GetToken(PlPgSqlParser.EXCLUSIVE, 0); }
		public ITerminalNode EXECUTE() { return GetToken(PlPgSqlParser.EXECUTE, 0); }
		public ITerminalNode EXPLAIN() { return GetToken(PlPgSqlParser.EXPLAIN, 0); }
		public ITerminalNode EXTENSION() { return GetToken(PlPgSqlParser.EXTENSION, 0); }
		public ITerminalNode EXTERNAL() { return GetToken(PlPgSqlParser.EXTERNAL, 0); }
		public ITerminalNode FAMILY() { return GetToken(PlPgSqlParser.FAMILY, 0); }
		public ITerminalNode FILTER() { return GetToken(PlPgSqlParser.FILTER, 0); }
		public ITerminalNode FIRST() { return GetToken(PlPgSqlParser.FIRST, 0); }
		public ITerminalNode FOLLOWING() { return GetToken(PlPgSqlParser.FOLLOWING, 0); }
		public ITerminalNode FORCE() { return GetToken(PlPgSqlParser.FORCE, 0); }
		public ITerminalNode FORWARD() { return GetToken(PlPgSqlParser.FORWARD, 0); }
		public ITerminalNode FUNCTION() { return GetToken(PlPgSqlParser.FUNCTION, 0); }
		public ITerminalNode FUNCTIONS() { return GetToken(PlPgSqlParser.FUNCTIONS, 0); }
		public ITerminalNode GENERATED() { return GetToken(PlPgSqlParser.GENERATED, 0); }
		public ITerminalNode GLOBAL() { return GetToken(PlPgSqlParser.GLOBAL, 0); }
		public ITerminalNode GRANTED() { return GetToken(PlPgSqlParser.GRANTED, 0); }
		public ITerminalNode GROUPS() { return GetToken(PlPgSqlParser.GROUPS, 0); }
		public ITerminalNode HANDLER() { return GetToken(PlPgSqlParser.HANDLER, 0); }
		public ITerminalNode HEADER() { return GetToken(PlPgSqlParser.HEADER, 0); }
		public ITerminalNode HOLD() { return GetToken(PlPgSqlParser.HOLD, 0); }
		public ITerminalNode HOUR() { return GetToken(PlPgSqlParser.HOUR, 0); }
		public ITerminalNode IDENTITY() { return GetToken(PlPgSqlParser.IDENTITY, 0); }
		public ITerminalNode IF() { return GetToken(PlPgSqlParser.IF, 0); }
		public ITerminalNode IMMEDIATE() { return GetToken(PlPgSqlParser.IMMEDIATE, 0); }
		public ITerminalNode IMMUTABLE() { return GetToken(PlPgSqlParser.IMMUTABLE, 0); }
		public ITerminalNode IMPLICIT() { return GetToken(PlPgSqlParser.IMPLICIT, 0); }
		public ITerminalNode IMPORT() { return GetToken(PlPgSqlParser.IMPORT, 0); }
		public ITerminalNode INCLUDE() { return GetToken(PlPgSqlParser.INCLUDE, 0); }
		public ITerminalNode INCLUDING() { return GetToken(PlPgSqlParser.INCLUDING, 0); }
		public ITerminalNode INCREMENT() { return GetToken(PlPgSqlParser.INCREMENT, 0); }
		public ITerminalNode INDEX() { return GetToken(PlPgSqlParser.INDEX, 0); }
		public ITerminalNode INDEXES() { return GetToken(PlPgSqlParser.INDEXES, 0); }
		public ITerminalNode INHERIT() { return GetToken(PlPgSqlParser.INHERIT, 0); }
		public ITerminalNode INHERITS() { return GetToken(PlPgSqlParser.INHERITS, 0); }
		public ITerminalNode INLINE() { return GetToken(PlPgSqlParser.INLINE, 0); }
		public ITerminalNode INPUT() { return GetToken(PlPgSqlParser.INPUT, 0); }
		public ITerminalNode INSENSITIVE() { return GetToken(PlPgSqlParser.INSENSITIVE, 0); }
		public ITerminalNode INSERT() { return GetToken(PlPgSqlParser.INSERT, 0); }
		public ITerminalNode INSTEAD() { return GetToken(PlPgSqlParser.INSTEAD, 0); }
		public ITerminalNode INVOKER() { return GetToken(PlPgSqlParser.INVOKER, 0); }
		public ITerminalNode ISOLATION() { return GetToken(PlPgSqlParser.ISOLATION, 0); }
		public ITerminalNode KEY() { return GetToken(PlPgSqlParser.KEY, 0); }
		public ITerminalNode LABEL() { return GetToken(PlPgSqlParser.LABEL, 0); }
		public ITerminalNode LANGUAGE() { return GetToken(PlPgSqlParser.LANGUAGE, 0); }
		public ITerminalNode LARGE() { return GetToken(PlPgSqlParser.LARGE, 0); }
		public ITerminalNode LAST() { return GetToken(PlPgSqlParser.LAST, 0); }
		public ITerminalNode LEAKPROOF() { return GetToken(PlPgSqlParser.LEAKPROOF, 0); }
		public ITerminalNode LEVEL() { return GetToken(PlPgSqlParser.LEVEL, 0); }
		public ITerminalNode LISTEN() { return GetToken(PlPgSqlParser.LISTEN, 0); }
		public ITerminalNode LOAD() { return GetToken(PlPgSqlParser.LOAD, 0); }
		public ITerminalNode LOCAL() { return GetToken(PlPgSqlParser.LOCAL, 0); }
		public ITerminalNode LOCATION() { return GetToken(PlPgSqlParser.LOCATION, 0); }
		public ITerminalNode LOCK() { return GetToken(PlPgSqlParser.LOCK, 0); }
		public ITerminalNode LOCKED() { return GetToken(PlPgSqlParser.LOCKED, 0); }
		public ITerminalNode LOGGED() { return GetToken(PlPgSqlParser.LOGGED, 0); }
		public ITerminalNode MAPPING() { return GetToken(PlPgSqlParser.MAPPING, 0); }
		public ITerminalNode MATCH() { return GetToken(PlPgSqlParser.MATCH, 0); }
		public ITerminalNode MATERIALIZED() { return GetToken(PlPgSqlParser.MATERIALIZED, 0); }
		public ITerminalNode MAXVALUE() { return GetToken(PlPgSqlParser.MAXVALUE, 0); }
		public ITerminalNode METHOD() { return GetToken(PlPgSqlParser.METHOD, 0); }
		public ITerminalNode MINUTE() { return GetToken(PlPgSqlParser.MINUTE, 0); }
		public ITerminalNode MINVALUE() { return GetToken(PlPgSqlParser.MINVALUE, 0); }
		public ITerminalNode MODE() { return GetToken(PlPgSqlParser.MODE, 0); }
		public ITerminalNode MONTH() { return GetToken(PlPgSqlParser.MONTH, 0); }
		public ITerminalNode MOVE() { return GetToken(PlPgSqlParser.MOVE, 0); }
		public ITerminalNode NAME() { return GetToken(PlPgSqlParser.NAME, 0); }
		public ITerminalNode NAMES() { return GetToken(PlPgSqlParser.NAMES, 0); }
		public ITerminalNode NEW() { return GetToken(PlPgSqlParser.NEW, 0); }
		public ITerminalNode NEXT() { return GetToken(PlPgSqlParser.NEXT, 0); }
		public ITerminalNode NO() { return GetToken(PlPgSqlParser.NO, 0); }
		public ITerminalNode NOTHING() { return GetToken(PlPgSqlParser.NOTHING, 0); }
		public ITerminalNode NOTIFY() { return GetToken(PlPgSqlParser.NOTIFY, 0); }
		public ITerminalNode NOWAIT() { return GetToken(PlPgSqlParser.NOWAIT, 0); }
		public ITerminalNode NULLS() { return GetToken(PlPgSqlParser.NULLS, 0); }
		public ITerminalNode OBJECT() { return GetToken(PlPgSqlParser.OBJECT, 0); }
		public ITerminalNode OF() { return GetToken(PlPgSqlParser.OF, 0); }
		public ITerminalNode OFF() { return GetToken(PlPgSqlParser.OFF, 0); }
		public ITerminalNode OIDS() { return GetToken(PlPgSqlParser.OIDS, 0); }
		public ITerminalNode OLD() { return GetToken(PlPgSqlParser.OLD, 0); }
		public ITerminalNode OPERATOR() { return GetToken(PlPgSqlParser.OPERATOR, 0); }
		public ITerminalNode OPTION() { return GetToken(PlPgSqlParser.OPTION, 0); }
		public ITerminalNode OPTIONS() { return GetToken(PlPgSqlParser.OPTIONS, 0); }
		public ITerminalNode ORDINALITY() { return GetToken(PlPgSqlParser.ORDINALITY, 0); }
		public ITerminalNode OTHERS() { return GetToken(PlPgSqlParser.OTHERS, 0); }
		public ITerminalNode OVER() { return GetToken(PlPgSqlParser.OVER, 0); }
		public ITerminalNode OVERRIDING() { return GetToken(PlPgSqlParser.OVERRIDING, 0); }
		public ITerminalNode OWNED() { return GetToken(PlPgSqlParser.OWNED, 0); }
		public ITerminalNode OWNER() { return GetToken(PlPgSqlParser.OWNER, 0); }
		public ITerminalNode PARALLEL() { return GetToken(PlPgSqlParser.PARALLEL, 0); }
		public ITerminalNode PARSER() { return GetToken(PlPgSqlParser.PARSER, 0); }
		public ITerminalNode PARTIAL() { return GetToken(PlPgSqlParser.PARTIAL, 0); }
		public ITerminalNode PARTITION() { return GetToken(PlPgSqlParser.PARTITION, 0); }
		public ITerminalNode PASSING() { return GetToken(PlPgSqlParser.PASSING, 0); }
		public ITerminalNode PASSWORD() { return GetToken(PlPgSqlParser.PASSWORD, 0); }
		public ITerminalNode PLANS() { return GetToken(PlPgSqlParser.PLANS, 0); }
		public ITerminalNode POLICY() { return GetToken(PlPgSqlParser.POLICY, 0); }
		public ITerminalNode PRECEDING() { return GetToken(PlPgSqlParser.PRECEDING, 0); }
		public ITerminalNode PREPARE() { return GetToken(PlPgSqlParser.PREPARE, 0); }
		public ITerminalNode PREPARED() { return GetToken(PlPgSqlParser.PREPARED, 0); }
		public ITerminalNode PRESERVE() { return GetToken(PlPgSqlParser.PRESERVE, 0); }
		public ITerminalNode PRIOR() { return GetToken(PlPgSqlParser.PRIOR, 0); }
		public ITerminalNode PRIVILEGES() { return GetToken(PlPgSqlParser.PRIVILEGES, 0); }
		public ITerminalNode PROCEDURAL() { return GetToken(PlPgSqlParser.PROCEDURAL, 0); }
		public ITerminalNode PROCEDURE() { return GetToken(PlPgSqlParser.PROCEDURE, 0); }
		public ITerminalNode PROCEDURES() { return GetToken(PlPgSqlParser.PROCEDURES, 0); }
		public ITerminalNode PROGRAM() { return GetToken(PlPgSqlParser.PROGRAM, 0); }
		public ITerminalNode PUBLICATION() { return GetToken(PlPgSqlParser.PUBLICATION, 0); }
		public ITerminalNode QUOTE() { return GetToken(PlPgSqlParser.QUOTE, 0); }
		public ITerminalNode RANGE() { return GetToken(PlPgSqlParser.RANGE, 0); }
		public ITerminalNode READ() { return GetToken(PlPgSqlParser.READ, 0); }
		public ITerminalNode REASSIGN() { return GetToken(PlPgSqlParser.REASSIGN, 0); }
		public ITerminalNode RECHECK() { return GetToken(PlPgSqlParser.RECHECK, 0); }
		public ITerminalNode RECURSIVE() { return GetToken(PlPgSqlParser.RECURSIVE, 0); }
		public ITerminalNode REF() { return GetToken(PlPgSqlParser.REF, 0); }
		public ITerminalNode REFERENCING() { return GetToken(PlPgSqlParser.REFERENCING, 0); }
		public ITerminalNode REFRESH() { return GetToken(PlPgSqlParser.REFRESH, 0); }
		public ITerminalNode REINDEX() { return GetToken(PlPgSqlParser.REINDEX, 0); }
		public ITerminalNode RELATIVE() { return GetToken(PlPgSqlParser.RELATIVE, 0); }
		public ITerminalNode RELEASE() { return GetToken(PlPgSqlParser.RELEASE, 0); }
		public ITerminalNode RENAME() { return GetToken(PlPgSqlParser.RENAME, 0); }
		public ITerminalNode REPEATABLE() { return GetToken(PlPgSqlParser.REPEATABLE, 0); }
		public ITerminalNode REPLACE() { return GetToken(PlPgSqlParser.REPLACE, 0); }
		public ITerminalNode REPLICA() { return GetToken(PlPgSqlParser.REPLICA, 0); }
		public ITerminalNode RESET() { return GetToken(PlPgSqlParser.RESET, 0); }
		public ITerminalNode RESTART() { return GetToken(PlPgSqlParser.RESTART, 0); }
		public ITerminalNode RESTRICT() { return GetToken(PlPgSqlParser.RESTRICT, 0); }
		public ITerminalNode RETURNS() { return GetToken(PlPgSqlParser.RETURNS, 0); }
		public ITerminalNode REVOKE() { return GetToken(PlPgSqlParser.REVOKE, 0); }
		public ITerminalNode ROLE() { return GetToken(PlPgSqlParser.ROLE, 0); }
		public ITerminalNode ROLLBACK() { return GetToken(PlPgSqlParser.ROLLBACK, 0); }
		public ITerminalNode ROLLUP() { return GetToken(PlPgSqlParser.ROLLUP, 0); }
		public ITerminalNode ROUTINE() { return GetToken(PlPgSqlParser.ROUTINE, 0); }
		public ITerminalNode ROUTINES() { return GetToken(PlPgSqlParser.ROUTINES, 0); }
		public ITerminalNode ROWS() { return GetToken(PlPgSqlParser.ROWS, 0); }
		public ITerminalNode RULE() { return GetToken(PlPgSqlParser.RULE, 0); }
		public ITerminalNode SAVEPOINT() { return GetToken(PlPgSqlParser.SAVEPOINT, 0); }
		public ITerminalNode SCHEMA() { return GetToken(PlPgSqlParser.SCHEMA, 0); }
		public ITerminalNode SCHEMAS() { return GetToken(PlPgSqlParser.SCHEMAS, 0); }
		public ITerminalNode SCROLL() { return GetToken(PlPgSqlParser.SCROLL, 0); }
		public ITerminalNode SEARCH() { return GetToken(PlPgSqlParser.SEARCH, 0); }
		public ITerminalNode SECOND() { return GetToken(PlPgSqlParser.SECOND, 0); }
		public ITerminalNode SECURITY() { return GetToken(PlPgSqlParser.SECURITY, 0); }
		public ITerminalNode SEQUENCE() { return GetToken(PlPgSqlParser.SEQUENCE, 0); }
		public ITerminalNode SEQUENCES() { return GetToken(PlPgSqlParser.SEQUENCES, 0); }
		public ITerminalNode SERIALIZABLE() { return GetToken(PlPgSqlParser.SERIALIZABLE, 0); }
		public ITerminalNode SERVER() { return GetToken(PlPgSqlParser.SERVER, 0); }
		public ITerminalNode SESSION() { return GetToken(PlPgSqlParser.SESSION, 0); }
		public ITerminalNode SET() { return GetToken(PlPgSqlParser.SET, 0); }
		public ITerminalNode SETS() { return GetToken(PlPgSqlParser.SETS, 0); }
		public ITerminalNode SHARE() { return GetToken(PlPgSqlParser.SHARE, 0); }
		public ITerminalNode SHOW() { return GetToken(PlPgSqlParser.SHOW, 0); }
		public ITerminalNode SIMPLE() { return GetToken(PlPgSqlParser.SIMPLE, 0); }
		public ITerminalNode SKIP_() { return GetToken(PlPgSqlParser.SKIP_, 0); }
		public ITerminalNode SNAPSHOT() { return GetToken(PlPgSqlParser.SNAPSHOT, 0); }
		public ITerminalNode SQL() { return GetToken(PlPgSqlParser.SQL, 0); }
		public ITerminalNode STABLE() { return GetToken(PlPgSqlParser.STABLE, 0); }
		public ITerminalNode STANDALONE() { return GetToken(PlPgSqlParser.STANDALONE, 0); }
		public ITerminalNode START() { return GetToken(PlPgSqlParser.START, 0); }
		public ITerminalNode STATEMENT() { return GetToken(PlPgSqlParser.STATEMENT, 0); }
		public ITerminalNode STATISTICS() { return GetToken(PlPgSqlParser.STATISTICS, 0); }
		public ITerminalNode STDIN() { return GetToken(PlPgSqlParser.STDIN, 0); }
		public ITerminalNode STDOUT() { return GetToken(PlPgSqlParser.STDOUT, 0); }
		public ITerminalNode STORAGE() { return GetToken(PlPgSqlParser.STORAGE, 0); }
		public ITerminalNode STORED() { return GetToken(PlPgSqlParser.STORED, 0); }
		public ITerminalNode STRICT() { return GetToken(PlPgSqlParser.STRICT, 0); }
		public ITerminalNode STRIP() { return GetToken(PlPgSqlParser.STRIP, 0); }
		public ITerminalNode SUBSCRIPTION() { return GetToken(PlPgSqlParser.SUBSCRIPTION, 0); }
		public ITerminalNode SUPPORT() { return GetToken(PlPgSqlParser.SUPPORT, 0); }
		public ITerminalNode SYSID() { return GetToken(PlPgSqlParser.SYSID, 0); }
		public ITerminalNode SYSTEM() { return GetToken(PlPgSqlParser.SYSTEM, 0); }
		public ITerminalNode TABLES() { return GetToken(PlPgSqlParser.TABLES, 0); }
		public ITerminalNode TABLESPACE() { return GetToken(PlPgSqlParser.TABLESPACE, 0); }
		public ITerminalNode TEMP() { return GetToken(PlPgSqlParser.TEMP, 0); }
		public ITerminalNode TEMPLATE() { return GetToken(PlPgSqlParser.TEMPLATE, 0); }
		public ITerminalNode TEMPORARY() { return GetToken(PlPgSqlParser.TEMPORARY, 0); }
		public ITerminalNode TEXT() { return GetToken(PlPgSqlParser.TEXT, 0); }
		public ITerminalNode TIES() { return GetToken(PlPgSqlParser.TIES, 0); }
		public ITerminalNode TRANSACTION() { return GetToken(PlPgSqlParser.TRANSACTION, 0); }
		public ITerminalNode TRANSFORM() { return GetToken(PlPgSqlParser.TRANSFORM, 0); }
		public ITerminalNode TRIGGER() { return GetToken(PlPgSqlParser.TRIGGER, 0); }
		public ITerminalNode TRUNCATE() { return GetToken(PlPgSqlParser.TRUNCATE, 0); }
		public ITerminalNode TRUSTED() { return GetToken(PlPgSqlParser.TRUSTED, 0); }
		public ITerminalNode TYPE() { return GetToken(PlPgSqlParser.TYPE, 0); }
		public ITerminalNode TYPES() { return GetToken(PlPgSqlParser.TYPES, 0); }
		public ITerminalNode UNBOUNDED() { return GetToken(PlPgSqlParser.UNBOUNDED, 0); }
		public ITerminalNode UNCOMMITTED() { return GetToken(PlPgSqlParser.UNCOMMITTED, 0); }
		public ITerminalNode UNENCRYPTED() { return GetToken(PlPgSqlParser.UNENCRYPTED, 0); }
		public ITerminalNode UNKNOWN() { return GetToken(PlPgSqlParser.UNKNOWN, 0); }
		public ITerminalNode UNLISTEN() { return GetToken(PlPgSqlParser.UNLISTEN, 0); }
		public ITerminalNode UNLOGGED() { return GetToken(PlPgSqlParser.UNLOGGED, 0); }
		public ITerminalNode UNTIL() { return GetToken(PlPgSqlParser.UNTIL, 0); }
		public ITerminalNode UPDATE() { return GetToken(PlPgSqlParser.UPDATE, 0); }
		public ITerminalNode VACUUM() { return GetToken(PlPgSqlParser.VACUUM, 0); }
		public ITerminalNode VALID() { return GetToken(PlPgSqlParser.VALID, 0); }
		public ITerminalNode VALIDATE() { return GetToken(PlPgSqlParser.VALIDATE, 0); }
		public ITerminalNode VALIDATOR() { return GetToken(PlPgSqlParser.VALIDATOR, 0); }
		public ITerminalNode VALUE() { return GetToken(PlPgSqlParser.VALUE, 0); }
		public ITerminalNode VARYING() { return GetToken(PlPgSqlParser.VARYING, 0); }
		public ITerminalNode VERSION() { return GetToken(PlPgSqlParser.VERSION, 0); }
		public ITerminalNode VIEW() { return GetToken(PlPgSqlParser.VIEW, 0); }
		public ITerminalNode VIEWS() { return GetToken(PlPgSqlParser.VIEWS, 0); }
		public ITerminalNode VOLATILE() { return GetToken(PlPgSqlParser.VOLATILE, 0); }
		public ITerminalNode WHITESPACE() { return GetToken(PlPgSqlParser.WHITESPACE, 0); }
		public ITerminalNode WITHIN() { return GetToken(PlPgSqlParser.WITHIN, 0); }
		public ITerminalNode WITHOUT() { return GetToken(PlPgSqlParser.WITHOUT, 0); }
		public ITerminalNode WORK() { return GetToken(PlPgSqlParser.WORK, 0); }
		public ITerminalNode WRAPPER() { return GetToken(PlPgSqlParser.WRAPPER, 0); }
		public ITerminalNode WRITE() { return GetToken(PlPgSqlParser.WRITE, 0); }
		public ITerminalNode XML() { return GetToken(PlPgSqlParser.XML, 0); }
		public ITerminalNode YEAR() { return GetToken(PlPgSqlParser.YEAR, 0); }
		public ITerminalNode YES() { return GetToken(PlPgSqlParser.YES, 0); }
		public ITerminalNode ZONE() { return GetToken(PlPgSqlParser.ZONE, 0); }
		public Tokens_nonreservedContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tokens_nonreserved; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTokens_nonreserved(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Tokens_nonreservedContext tokens_nonreserved() {
		Tokens_nonreservedContext _localctx = new Tokens_nonreservedContext(Context, State);
		EnterRule(_localctx, 322, RULE_tokens_nonreserved);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3380;
			_la = TokenStream.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ABORT) | (1L << ABSOLUTE) | (1L << ACCESS) | (1L << ACTION) | (1L << ADD) | (1L << ADMIN) | (1L << AFTER) | (1L << AGGREGATE) | (1L << ALSO) | (1L << ALTER) | (1L << ALWAYS) | (1L << ASSERTION) | (1L << ASSIGNMENT) | (1L << AT) | (1L << ATTACH) | (1L << ATTRIBUTE) | (1L << BACKWARD) | (1L << BEFORE) | (1L << BEGIN) | (1L << BY) | (1L << CACHE) | (1L << CALL) | (1L << CALLED) | (1L << CASCADE) | (1L << CASCADED) | (1L << CATALOG) | (1L << CHAIN) | (1L << CHARACTERISTICS) | (1L << CHECKPOINT) | (1L << CLASS) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMENTS) | (1L << COMMIT) | (1L << COMMITTED) | (1L << CONFIGURATION) | (1L << CONFLICT) | (1L << CONNECTION) | (1L << CONSTRAINTS) | (1L << CONTENT) | (1L << CONTINUE) | (1L << CONVERSION) | (1L << COPY) | (1L << COST) | (1L << CSV) | (1L << CUBE) | (1L << CURRENT) | (1L << CURSOR) | (1L << CYCLE) | (1L << DATA) | (1L << DATABASE) | (1L << DAY) | (1L << DEALLOCATE) | (1L << DECLARE) | (1L << DEFAULTS) | (1L << DEFERRED) | (1L << DEFINER) | (1L << DELETE) | (1L << DELIMITER) | (1L << DELIMITERS) | (1L << DEPENDS))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (DETACH - 64)) | (1L << (DICTIONARY - 64)) | (1L << (DISABLE - 64)) | (1L << (DISCARD - 64)) | (1L << (DOCUMENT - 64)) | (1L << (DOMAIN - 64)) | (1L << (DOUBLE - 64)) | (1L << (DROP - 64)) | (1L << (EACH - 64)) | (1L << (ENABLE - 64)) | (1L << (ENCODING - 64)) | (1L << (ENCRYPTED - 64)) | (1L << (ENUM - 64)) | (1L << (ESCAPE - 64)) | (1L << (EVENT - 64)) | (1L << (EXCLUDE - 64)) | (1L << (EXCLUDING - 64)) | (1L << (EXCLUSIVE - 64)) | (1L << (EXECUTE - 64)) | (1L << (EXPLAIN - 64)) | (1L << (EXTENSION - 64)) | (1L << (EXTERNAL - 64)) | (1L << (FAMILY - 64)) | (1L << (FILTER - 64)) | (1L << (FIRST - 64)) | (1L << (FOLLOWING - 64)) | (1L << (FORCE - 64)) | (1L << (FORWARD - 64)) | (1L << (FUNCTION - 64)) | (1L << (FUNCTIONS - 64)) | (1L << (GENERATED - 64)) | (1L << (GLOBAL - 64)) | (1L << (GRANTED - 64)) | (1L << (GROUPS - 64)) | (1L << (HANDLER - 64)) | (1L << (HEADER - 64)) | (1L << (HOLD - 64)) | (1L << (HOUR - 64)) | (1L << (IDENTITY - 64)) | (1L << (IF - 64)) | (1L << (IMMEDIATE - 64)) | (1L << (IMMUTABLE - 64)) | (1L << (IMPLICIT - 64)) | (1L << (IMPORT - 64)) | (1L << (INCLUDE - 64)) | (1L << (INCLUDING - 64)) | (1L << (INCREMENT - 64)) | (1L << (INDEX - 64)) | (1L << (INDEXES - 64)) | (1L << (INHERIT - 64)) | (1L << (INHERITS - 64)) | (1L << (INLINE - 64)) | (1L << (INPUT - 64)) | (1L << (INSENSITIVE - 64)) | (1L << (INSERT - 64)) | (1L << (INSTEAD - 64)) | (1L << (INVOKER - 64)) | (1L << (ISOLATION - 64)) | (1L << (KEY - 64)) | (1L << (LABEL - 64)) | (1L << (LANGUAGE - 64)) | (1L << (LARGE - 64)) | (1L << (LAST - 64)) | (1L << (LEAKPROOF - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (LEVEL - 128)) | (1L << (LISTEN - 128)) | (1L << (LOAD - 128)) | (1L << (LOCAL - 128)) | (1L << (LOCATION - 128)) | (1L << (LOCK - 128)) | (1L << (LOCKED - 128)) | (1L << (LOGGED - 128)) | (1L << (MAPPING - 128)) | (1L << (MATCH - 128)) | (1L << (MATERIALIZED - 128)) | (1L << (MAXVALUE - 128)) | (1L << (METHOD - 128)) | (1L << (MINUTE - 128)) | (1L << (MINVALUE - 128)) | (1L << (MODE - 128)) | (1L << (MONTH - 128)) | (1L << (MOVE - 128)) | (1L << (NAME - 128)) | (1L << (NAMES - 128)) | (1L << (NEW - 128)) | (1L << (NEXT - 128)) | (1L << (NO - 128)) | (1L << (NOTHING - 128)) | (1L << (NOTIFY - 128)) | (1L << (NOWAIT - 128)) | (1L << (NULLS - 128)) | (1L << (OBJECT - 128)) | (1L << (OF - 128)) | (1L << (OFF - 128)) | (1L << (OIDS - 128)) | (1L << (OLD - 128)) | (1L << (OPERATOR - 128)) | (1L << (OPTION - 128)) | (1L << (OPTIONS - 128)) | (1L << (ORDINALITY - 128)) | (1L << (OTHERS - 128)) | (1L << (OVER - 128)) | (1L << (OVERRIDING - 128)) | (1L << (OWNED - 128)) | (1L << (OWNER - 128)) | (1L << (PARALLEL - 128)) | (1L << (PARSER - 128)) | (1L << (PARTIAL - 128)) | (1L << (PARTITION - 128)) | (1L << (PASSING - 128)) | (1L << (PASSWORD - 128)) | (1L << (PLANS - 128)) | (1L << (POLICY - 128)) | (1L << (PRECEDING - 128)) | (1L << (PREPARE - 128)) | (1L << (PREPARED - 128)) | (1L << (PRESERVE - 128)) | (1L << (PRIOR - 128)) | (1L << (PRIVILEGES - 128)) | (1L << (PROCEDURAL - 128)) | (1L << (PROCEDURE - 128)) | (1L << (PROCEDURES - 128)) | (1L << (PROGRAM - 128)) | (1L << (PUBLICATION - 128)) | (1L << (QUOTE - 128)) | (1L << (RANGE - 128)) | (1L << (READ - 128)) | (1L << (REASSIGN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (RECHECK - 192)) | (1L << (RECURSIVE - 192)) | (1L << (REF - 192)) | (1L << (REFERENCING - 192)) | (1L << (REFRESH - 192)) | (1L << (REINDEX - 192)) | (1L << (RELATIVE - 192)) | (1L << (RELEASE - 192)) | (1L << (RENAME - 192)) | (1L << (REPEATABLE - 192)) | (1L << (REPLACE - 192)) | (1L << (REPLICA - 192)) | (1L << (RESET - 192)) | (1L << (RESTART - 192)) | (1L << (RESTRICT - 192)) | (1L << (RETURNS - 192)) | (1L << (REVOKE - 192)) | (1L << (ROLE - 192)) | (1L << (ROLLBACK - 192)) | (1L << (ROLLUP - 192)) | (1L << (ROUTINE - 192)) | (1L << (ROUTINES - 192)) | (1L << (ROWS - 192)) | (1L << (RULE - 192)) | (1L << (SAVEPOINT - 192)) | (1L << (SCHEMA - 192)) | (1L << (SCHEMAS - 192)) | (1L << (SCROLL - 192)) | (1L << (SEARCH - 192)) | (1L << (SECOND - 192)) | (1L << (SECURITY - 192)) | (1L << (SEQUENCE - 192)) | (1L << (SEQUENCES - 192)) | (1L << (SERIALIZABLE - 192)) | (1L << (SERVER - 192)) | (1L << (SESSION - 192)) | (1L << (SET - 192)) | (1L << (SETS - 192)) | (1L << (SHARE - 192)) | (1L << (SHOW - 192)) | (1L << (SIMPLE - 192)) | (1L << (SKIP_ - 192)) | (1L << (SNAPSHOT - 192)) | (1L << (SQL - 192)) | (1L << (STABLE - 192)) | (1L << (STANDALONE - 192)) | (1L << (START - 192)) | (1L << (STATEMENT - 192)) | (1L << (STATISTICS - 192)) | (1L << (STDIN - 192)) | (1L << (STDOUT - 192)) | (1L << (STORAGE - 192)) | (1L << (STORED - 192)) | (1L << (STRICT - 192)) | (1L << (STRIP - 192)) | (1L << (SUBSCRIPTION - 192)) | (1L << (SUPPORT - 192)) | (1L << (SYSID - 192)) | (1L << (SYSTEM - 192)) | (1L << (TABLES - 192)) | (1L << (TABLESPACE - 192)) | (1L << (TEMP - 192)) | (1L << (TEMPLATE - 192)) | (1L << (TEMPORARY - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (TEXT - 256)) | (1L << (TIES - 256)) | (1L << (TRANSACTION - 256)) | (1L << (TRANSFORM - 256)) | (1L << (TRIGGER - 256)) | (1L << (TRUNCATE - 256)) | (1L << (TRUSTED - 256)) | (1L << (TYPE - 256)) | (1L << (TYPES - 256)) | (1L << (UNBOUNDED - 256)) | (1L << (UNCOMMITTED - 256)) | (1L << (UNENCRYPTED - 256)) | (1L << (UNKNOWN - 256)) | (1L << (UNLISTEN - 256)) | (1L << (UNLOGGED - 256)) | (1L << (UNTIL - 256)) | (1L << (UPDATE - 256)) | (1L << (VACUUM - 256)) | (1L << (VALID - 256)) | (1L << (VALIDATE - 256)) | (1L << (VALIDATOR - 256)) | (1L << (VALUE - 256)) | (1L << (VARYING - 256)) | (1L << (VERSION - 256)) | (1L << (VIEW - 256)) | (1L << (VIEWS - 256)) | (1L << (VOLATILE - 256)) | (1L << (WHITESPACE - 256)) | (1L << (WITHIN - 256)) | (1L << (WITHOUT - 256)) | (1L << (WORK - 256)) | (1L << (WRAPPER - 256)) | (1L << (WRITE - 256)) | (1L << (XML - 256)) | (1L << (YEAR - 256)) | (1L << (YES - 256)) | (1L << (ZONE - 256)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Tokens_nonreserved_except_function_typeContext : ParserRuleContext {
		public ITerminalNode BETWEEN() { return GetToken(PlPgSqlParser.BETWEEN, 0); }
		public ITerminalNode BIGINT() { return GetToken(PlPgSqlParser.BIGINT, 0); }
		public ITerminalNode BIT() { return GetToken(PlPgSqlParser.BIT, 0); }
		public ITerminalNode BOOLEAN() { return GetToken(PlPgSqlParser.BOOLEAN, 0); }
		public ITerminalNode CHAR() { return GetToken(PlPgSqlParser.CHAR, 0); }
		public ITerminalNode CHARACTER() { return GetToken(PlPgSqlParser.CHARACTER, 0); }
		public ITerminalNode COALESCE() { return GetToken(PlPgSqlParser.COALESCE, 0); }
		public ITerminalNode DEC() { return GetToken(PlPgSqlParser.DEC, 0); }
		public ITerminalNode DECIMAL() { return GetToken(PlPgSqlParser.DECIMAL, 0); }
		public ITerminalNode EXISTS() { return GetToken(PlPgSqlParser.EXISTS, 0); }
		public ITerminalNode EXTRACT() { return GetToken(PlPgSqlParser.EXTRACT, 0); }
		public ITerminalNode FLOAT() { return GetToken(PlPgSqlParser.FLOAT, 0); }
		public ITerminalNode GREATEST() { return GetToken(PlPgSqlParser.GREATEST, 0); }
		public ITerminalNode GROUPING() { return GetToken(PlPgSqlParser.GROUPING, 0); }
		public ITerminalNode INOUT() { return GetToken(PlPgSqlParser.INOUT, 0); }
		public ITerminalNode INT() { return GetToken(PlPgSqlParser.INT, 0); }
		public ITerminalNode INTEGER() { return GetToken(PlPgSqlParser.INTEGER, 0); }
		public ITerminalNode INTERVAL() { return GetToken(PlPgSqlParser.INTERVAL, 0); }
		public ITerminalNode LEAST() { return GetToken(PlPgSqlParser.LEAST, 0); }
		public ITerminalNode NATIONAL() { return GetToken(PlPgSqlParser.NATIONAL, 0); }
		public ITerminalNode NCHAR() { return GetToken(PlPgSqlParser.NCHAR, 0); }
		public ITerminalNode NONE() { return GetToken(PlPgSqlParser.NONE, 0); }
		public ITerminalNode NULLIF() { return GetToken(PlPgSqlParser.NULLIF, 0); }
		public ITerminalNode NUMERIC() { return GetToken(PlPgSqlParser.NUMERIC, 0); }
		public ITerminalNode OUT() { return GetToken(PlPgSqlParser.OUT, 0); }
		public ITerminalNode OVERLAY() { return GetToken(PlPgSqlParser.OVERLAY, 0); }
		public ITerminalNode POSITION() { return GetToken(PlPgSqlParser.POSITION, 0); }
		public ITerminalNode PRECISION() { return GetToken(PlPgSqlParser.PRECISION, 0); }
		public ITerminalNode REAL() { return GetToken(PlPgSqlParser.REAL, 0); }
		public ITerminalNode ROW() { return GetToken(PlPgSqlParser.ROW, 0); }
		public ITerminalNode SETOF() { return GetToken(PlPgSqlParser.SETOF, 0); }
		public ITerminalNode SMALLINT() { return GetToken(PlPgSqlParser.SMALLINT, 0); }
		public ITerminalNode SUBSTRING() { return GetToken(PlPgSqlParser.SUBSTRING, 0); }
		public ITerminalNode TIME() { return GetToken(PlPgSqlParser.TIME, 0); }
		public ITerminalNode TIMESTAMP() { return GetToken(PlPgSqlParser.TIMESTAMP, 0); }
		public ITerminalNode TREAT() { return GetToken(PlPgSqlParser.TREAT, 0); }
		public ITerminalNode TRIM() { return GetToken(PlPgSqlParser.TRIM, 0); }
		public ITerminalNode VALUES() { return GetToken(PlPgSqlParser.VALUES, 0); }
		public ITerminalNode VARCHAR() { return GetToken(PlPgSqlParser.VARCHAR, 0); }
		public ITerminalNode XMLATTRIBUTES() { return GetToken(PlPgSqlParser.XMLATTRIBUTES, 0); }
		public ITerminalNode XMLCONCAT() { return GetToken(PlPgSqlParser.XMLCONCAT, 0); }
		public ITerminalNode XMLELEMENT() { return GetToken(PlPgSqlParser.XMLELEMENT, 0); }
		public ITerminalNode XMLEXISTS() { return GetToken(PlPgSqlParser.XMLEXISTS, 0); }
		public ITerminalNode XMLFOREST() { return GetToken(PlPgSqlParser.XMLFOREST, 0); }
		public ITerminalNode XMLNAMESPACES() { return GetToken(PlPgSqlParser.XMLNAMESPACES, 0); }
		public ITerminalNode XMLPARSE() { return GetToken(PlPgSqlParser.XMLPARSE, 0); }
		public ITerminalNode XMLPI() { return GetToken(PlPgSqlParser.XMLPI, 0); }
		public ITerminalNode XMLROOT() { return GetToken(PlPgSqlParser.XMLROOT, 0); }
		public ITerminalNode XMLSERIALIZE() { return GetToken(PlPgSqlParser.XMLSERIALIZE, 0); }
		public ITerminalNode XMLTABLE() { return GetToken(PlPgSqlParser.XMLTABLE, 0); }
		public Tokens_nonreserved_except_function_typeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tokens_nonreserved_except_function_type; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTokens_nonreserved_except_function_type(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Tokens_nonreserved_except_function_typeContext tokens_nonreserved_except_function_type() {
		Tokens_nonreserved_except_function_typeContext _localctx = new Tokens_nonreserved_except_function_typeContext(Context, State);
		EnterRule(_localctx, 324, RULE_tokens_nonreserved_except_function_type);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3382;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 293)) & ~0x3f) == 0 && ((1L << (_la - 293)) & ((1L << (BETWEEN - 293)) | (1L << (BIGINT - 293)) | (1L << (BIT - 293)) | (1L << (BOOLEAN - 293)) | (1L << (CHAR - 293)) | (1L << (CHARACTER - 293)) | (1L << (COALESCE - 293)) | (1L << (DEC - 293)) | (1L << (DECIMAL - 293)) | (1L << (EXISTS - 293)) | (1L << (EXTRACT - 293)) | (1L << (FLOAT - 293)) | (1L << (GREATEST - 293)) | (1L << (GROUPING - 293)) | (1L << (INOUT - 293)) | (1L << (INT - 293)) | (1L << (INTEGER - 293)) | (1L << (INTERVAL - 293)) | (1L << (LEAST - 293)) | (1L << (NATIONAL - 293)) | (1L << (NCHAR - 293)) | (1L << (NONE - 293)) | (1L << (NULLIF - 293)) | (1L << (NUMERIC - 293)) | (1L << (OUT - 293)) | (1L << (OVERLAY - 293)) | (1L << (POSITION - 293)) | (1L << (PRECISION - 293)) | (1L << (REAL - 293)) | (1L << (ROW - 293)) | (1L << (SETOF - 293)) | (1L << (SMALLINT - 293)) | (1L << (SUBSTRING - 293)) | (1L << (TIME - 293)) | (1L << (TIMESTAMP - 293)) | (1L << (TREAT - 293)) | (1L << (TRIM - 293)) | (1L << (VALUES - 293)) | (1L << (VARCHAR - 293)) | (1L << (XMLATTRIBUTES - 293)) | (1L << (XMLCONCAT - 293)) | (1L << (XMLELEMENT - 293)) | (1L << (XMLEXISTS - 293)) | (1L << (XMLFOREST - 293)) | (1L << (XMLNAMESPACES - 293)) | (1L << (XMLPARSE - 293)) | (1L << (XMLPI - 293)) | (1L << (XMLROOT - 293)) | (1L << (XMLSERIALIZE - 293)) | (1L << (XMLTABLE - 293)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Tokens_reserved_except_function_typeContext : ParserRuleContext {
		public ITerminalNode AUTHORIZATION() { return GetToken(PlPgSqlParser.AUTHORIZATION, 0); }
		public ITerminalNode BINARY() { return GetToken(PlPgSqlParser.BINARY, 0); }
		public ITerminalNode COLLATION() { return GetToken(PlPgSqlParser.COLLATION, 0); }
		public ITerminalNode CONCURRENTLY() { return GetToken(PlPgSqlParser.CONCURRENTLY, 0); }
		public ITerminalNode CROSS() { return GetToken(PlPgSqlParser.CROSS, 0); }
		public ITerminalNode CURRENT_SCHEMA() { return GetToken(PlPgSqlParser.CURRENT_SCHEMA, 0); }
		public ITerminalNode FREEZE() { return GetToken(PlPgSqlParser.FREEZE, 0); }
		public ITerminalNode FULL() { return GetToken(PlPgSqlParser.FULL, 0); }
		public ITerminalNode ILIKE() { return GetToken(PlPgSqlParser.ILIKE, 0); }
		public ITerminalNode INNER() { return GetToken(PlPgSqlParser.INNER, 0); }
		public ITerminalNode IS() { return GetToken(PlPgSqlParser.IS, 0); }
		public ITerminalNode ISNULL() { return GetToken(PlPgSqlParser.ISNULL, 0); }
		public ITerminalNode JOIN() { return GetToken(PlPgSqlParser.JOIN, 0); }
		public ITerminalNode LEFT() { return GetToken(PlPgSqlParser.LEFT, 0); }
		public ITerminalNode LIKE() { return GetToken(PlPgSqlParser.LIKE, 0); }
		public ITerminalNode NATURAL() { return GetToken(PlPgSqlParser.NATURAL, 0); }
		public ITerminalNode NOTNULL() { return GetToken(PlPgSqlParser.NOTNULL, 0); }
		public ITerminalNode OUTER() { return GetToken(PlPgSqlParser.OUTER, 0); }
		public ITerminalNode OVERLAPS() { return GetToken(PlPgSqlParser.OVERLAPS, 0); }
		public ITerminalNode RIGHT() { return GetToken(PlPgSqlParser.RIGHT, 0); }
		public ITerminalNode SIMILAR() { return GetToken(PlPgSqlParser.SIMILAR, 0); }
		public ITerminalNode TABLESAMPLE() { return GetToken(PlPgSqlParser.TABLESAMPLE, 0); }
		public ITerminalNode VERBOSE() { return GetToken(PlPgSqlParser.VERBOSE, 0); }
		public Tokens_reserved_except_function_typeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tokens_reserved_except_function_type; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTokens_reserved_except_function_type(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Tokens_reserved_except_function_typeContext tokens_reserved_except_function_type() {
		Tokens_reserved_except_function_typeContext _localctx = new Tokens_reserved_except_function_typeContext(Context, State);
		EnterRule(_localctx, 326, RULE_tokens_reserved_except_function_type);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3384;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 343)) & ~0x3f) == 0 && ((1L << (_la - 343)) & ((1L << (AUTHORIZATION - 343)) | (1L << (BINARY - 343)) | (1L << (COLLATION - 343)) | (1L << (CONCURRENTLY - 343)) | (1L << (CROSS - 343)) | (1L << (CURRENT_SCHEMA - 343)) | (1L << (FREEZE - 343)) | (1L << (FULL - 343)) | (1L << (ILIKE - 343)) | (1L << (INNER - 343)) | (1L << (IS - 343)) | (1L << (ISNULL - 343)) | (1L << (JOIN - 343)) | (1L << (LEFT - 343)) | (1L << (LIKE - 343)) | (1L << (NATURAL - 343)) | (1L << (NOTNULL - 343)) | (1L << (OUTER - 343)) | (1L << (OVERLAPS - 343)) | (1L << (RIGHT - 343)) | (1L << (SIMILAR - 343)) | (1L << (TABLESAMPLE - 343)) | (1L << (VERBOSE - 343)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Tokens_reservedContext : ParserRuleContext {
		public ITerminalNode ALL() { return GetToken(PlPgSqlParser.ALL, 0); }
		public ITerminalNode ANALYSE() { return GetToken(PlPgSqlParser.ANALYSE, 0); }
		public ITerminalNode ANALYZE() { return GetToken(PlPgSqlParser.ANALYZE, 0); }
		public ITerminalNode AND() { return GetToken(PlPgSqlParser.AND, 0); }
		public ITerminalNode ANY() { return GetToken(PlPgSqlParser.ANY, 0); }
		public ITerminalNode ARRAY() { return GetToken(PlPgSqlParser.ARRAY, 0); }
		public ITerminalNode AS() { return GetToken(PlPgSqlParser.AS, 0); }
		public ITerminalNode ASC() { return GetToken(PlPgSqlParser.ASC, 0); }
		public ITerminalNode ASYMMETRIC() { return GetToken(PlPgSqlParser.ASYMMETRIC, 0); }
		public ITerminalNode BOTH() { return GetToken(PlPgSqlParser.BOTH, 0); }
		public ITerminalNode CASE() { return GetToken(PlPgSqlParser.CASE, 0); }
		public ITerminalNode CAST() { return GetToken(PlPgSqlParser.CAST, 0); }
		public ITerminalNode CHECK() { return GetToken(PlPgSqlParser.CHECK, 0); }
		public ITerminalNode COLLATE() { return GetToken(PlPgSqlParser.COLLATE, 0); }
		public ITerminalNode COLUMN() { return GetToken(PlPgSqlParser.COLUMN, 0); }
		public ITerminalNode CONSTRAINT() { return GetToken(PlPgSqlParser.CONSTRAINT, 0); }
		public ITerminalNode CREATE() { return GetToken(PlPgSqlParser.CREATE, 0); }
		public ITerminalNode CURRENT_CATALOG() { return GetToken(PlPgSqlParser.CURRENT_CATALOG, 0); }
		public ITerminalNode CURRENT_DATE() { return GetToken(PlPgSqlParser.CURRENT_DATE, 0); }
		public ITerminalNode CURRENT_ROLE() { return GetToken(PlPgSqlParser.CURRENT_ROLE, 0); }
		public ITerminalNode CURRENT_TIME() { return GetToken(PlPgSqlParser.CURRENT_TIME, 0); }
		public ITerminalNode CURRENT_TIMESTAMP() { return GetToken(PlPgSqlParser.CURRENT_TIMESTAMP, 0); }
		public ITerminalNode CURRENT_USER() { return GetToken(PlPgSqlParser.CURRENT_USER, 0); }
		public ITerminalNode DEFAULT() { return GetToken(PlPgSqlParser.DEFAULT, 0); }
		public ITerminalNode DEFERRABLE() { return GetToken(PlPgSqlParser.DEFERRABLE, 0); }
		public ITerminalNode DESC() { return GetToken(PlPgSqlParser.DESC, 0); }
		public ITerminalNode DISTINCT() { return GetToken(PlPgSqlParser.DISTINCT, 0); }
		public ITerminalNode DO() { return GetToken(PlPgSqlParser.DO, 0); }
		public ITerminalNode ELSE() { return GetToken(PlPgSqlParser.ELSE, 0); }
		public ITerminalNode END() { return GetToken(PlPgSqlParser.END, 0); }
		public ITerminalNode EXCEPT() { return GetToken(PlPgSqlParser.EXCEPT, 0); }
		public ITerminalNode FALSE() { return GetToken(PlPgSqlParser.FALSE, 0); }
		public ITerminalNode FETCH() { return GetToken(PlPgSqlParser.FETCH, 0); }
		public ITerminalNode FOR() { return GetToken(PlPgSqlParser.FOR, 0); }
		public ITerminalNode FOREIGN() { return GetToken(PlPgSqlParser.FOREIGN, 0); }
		public ITerminalNode FROM() { return GetToken(PlPgSqlParser.FROM, 0); }
		public ITerminalNode GRANT() { return GetToken(PlPgSqlParser.GRANT, 0); }
		public ITerminalNode GROUP() { return GetToken(PlPgSqlParser.GROUP, 0); }
		public ITerminalNode HAVING() { return GetToken(PlPgSqlParser.HAVING, 0); }
		public ITerminalNode IN() { return GetToken(PlPgSqlParser.IN, 0); }
		public ITerminalNode INITIALLY() { return GetToken(PlPgSqlParser.INITIALLY, 0); }
		public ITerminalNode INTERSECT() { return GetToken(PlPgSqlParser.INTERSECT, 0); }
		public ITerminalNode INTO() { return GetToken(PlPgSqlParser.INTO, 0); }
		public ITerminalNode LATERAL() { return GetToken(PlPgSqlParser.LATERAL, 0); }
		public ITerminalNode LEADING() { return GetToken(PlPgSqlParser.LEADING, 0); }
		public ITerminalNode LIMIT() { return GetToken(PlPgSqlParser.LIMIT, 0); }
		public ITerminalNode LOCALTIME() { return GetToken(PlPgSqlParser.LOCALTIME, 0); }
		public ITerminalNode LOCALTIMESTAMP() { return GetToken(PlPgSqlParser.LOCALTIMESTAMP, 0); }
		public ITerminalNode NOT() { return GetToken(PlPgSqlParser.NOT, 0); }
		public ITerminalNode NULL() { return GetToken(PlPgSqlParser.NULL, 0); }
		public ITerminalNode OFFSET() { return GetToken(PlPgSqlParser.OFFSET, 0); }
		public ITerminalNode ON() { return GetToken(PlPgSqlParser.ON, 0); }
		public ITerminalNode ONLY() { return GetToken(PlPgSqlParser.ONLY, 0); }
		public ITerminalNode OR() { return GetToken(PlPgSqlParser.OR, 0); }
		public ITerminalNode ORDER() { return GetToken(PlPgSqlParser.ORDER, 0); }
		public ITerminalNode PLACING() { return GetToken(PlPgSqlParser.PLACING, 0); }
		public ITerminalNode PRIMARY() { return GetToken(PlPgSqlParser.PRIMARY, 0); }
		public ITerminalNode REFERENCES() { return GetToken(PlPgSqlParser.REFERENCES, 0); }
		public ITerminalNode RETURNING() { return GetToken(PlPgSqlParser.RETURNING, 0); }
		public ITerminalNode SELECT() { return GetToken(PlPgSqlParser.SELECT, 0); }
		public ITerminalNode SESSION_USER() { return GetToken(PlPgSqlParser.SESSION_USER, 0); }
		public ITerminalNode SOME() { return GetToken(PlPgSqlParser.SOME, 0); }
		public ITerminalNode SYMMETRIC() { return GetToken(PlPgSqlParser.SYMMETRIC, 0); }
		public ITerminalNode TABLE() { return GetToken(PlPgSqlParser.TABLE, 0); }
		public ITerminalNode THEN() { return GetToken(PlPgSqlParser.THEN, 0); }
		public ITerminalNode TO() { return GetToken(PlPgSqlParser.TO, 0); }
		public ITerminalNode TRAILING() { return GetToken(PlPgSqlParser.TRAILING, 0); }
		public ITerminalNode TRUE() { return GetToken(PlPgSqlParser.TRUE, 0); }
		public ITerminalNode UNION() { return GetToken(PlPgSqlParser.UNION, 0); }
		public ITerminalNode UNIQUE() { return GetToken(PlPgSqlParser.UNIQUE, 0); }
		public ITerminalNode USER() { return GetToken(PlPgSqlParser.USER, 0); }
		public ITerminalNode USING() { return GetToken(PlPgSqlParser.USING, 0); }
		public ITerminalNode VARIADIC() { return GetToken(PlPgSqlParser.VARIADIC, 0); }
		public ITerminalNode WHEN() { return GetToken(PlPgSqlParser.WHEN, 0); }
		public ITerminalNode WHERE() { return GetToken(PlPgSqlParser.WHERE, 0); }
		public ITerminalNode WINDOW() { return GetToken(PlPgSqlParser.WINDOW, 0); }
		public ITerminalNode WITH() { return GetToken(PlPgSqlParser.WITH, 0); }
		public Tokens_reservedContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tokens_reserved; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTokens_reserved(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Tokens_reservedContext tokens_reserved() {
		Tokens_reservedContext _localctx = new Tokens_reservedContext(Context, State);
		EnterRule(_localctx, 328, RULE_tokens_reserved);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3386;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 366)) & ~0x3f) == 0 && ((1L << (_la - 366)) & ((1L << (ALL - 366)) | (1L << (ANALYSE - 366)) | (1L << (ANALYZE - 366)) | (1L << (AND - 366)) | (1L << (ANY - 366)) | (1L << (ARRAY - 366)) | (1L << (AS - 366)) | (1L << (ASC - 366)) | (1L << (ASYMMETRIC - 366)) | (1L << (BOTH - 366)) | (1L << (CASE - 366)) | (1L << (CAST - 366)) | (1L << (CHECK - 366)) | (1L << (COLLATE - 366)) | (1L << (COLUMN - 366)) | (1L << (CONSTRAINT - 366)) | (1L << (CREATE - 366)) | (1L << (CURRENT_CATALOG - 366)) | (1L << (CURRENT_DATE - 366)) | (1L << (CURRENT_ROLE - 366)) | (1L << (CURRENT_TIME - 366)) | (1L << (CURRENT_TIMESTAMP - 366)) | (1L << (CURRENT_USER - 366)) | (1L << (DEFAULT - 366)) | (1L << (DEFERRABLE - 366)) | (1L << (DESC - 366)) | (1L << (DISTINCT - 366)) | (1L << (DO - 366)) | (1L << (ELSE - 366)) | (1L << (END - 366)) | (1L << (EXCEPT - 366)) | (1L << (FALSE - 366)) | (1L << (FETCH - 366)) | (1L << (FOR - 366)) | (1L << (FOREIGN - 366)) | (1L << (FROM - 366)) | (1L << (GRANT - 366)) | (1L << (GROUP - 366)) | (1L << (HAVING - 366)) | (1L << (IN - 366)) | (1L << (INITIALLY - 366)) | (1L << (INTERSECT - 366)) | (1L << (INTO - 366)) | (1L << (LATERAL - 366)) | (1L << (LEADING - 366)) | (1L << (LIMIT - 366)) | (1L << (LOCALTIME - 366)) | (1L << (LOCALTIMESTAMP - 366)) | (1L << (NOT - 366)) | (1L << (NULL - 366)) | (1L << (OFFSET - 366)) | (1L << (ON - 366)) | (1L << (ONLY - 366)) | (1L << (OR - 366)) | (1L << (ORDER - 366)) | (1L << (PLACING - 366)) | (1L << (PRIMARY - 366)) | (1L << (REFERENCES - 366)) | (1L << (RETURNING - 366)) | (1L << (SELECT - 366)) | (1L << (SESSION_USER - 366)) | (1L << (SOME - 366)) | (1L << (SYMMETRIC - 366)) | (1L << (TABLE - 366)))) != 0) || ((((_la - 430)) & ~0x3f) == 0 && ((1L << (_la - 430)) & ((1L << (THEN - 430)) | (1L << (TO - 430)) | (1L << (TRAILING - 430)) | (1L << (TRUE - 430)) | (1L << (UNION - 430)) | (1L << (UNIQUE - 430)) | (1L << (USER - 430)) | (1L << (USING - 430)) | (1L << (VARIADIC - 430)) | (1L << (WHEN - 430)) | (1L << (WHERE - 430)) | (1L << (WINDOW - 430)) | (1L << (WITH - 430)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Tokens_nonkeywordContext : ParserRuleContext {
		public ITerminalNode ALIGNMENT() { return GetToken(PlPgSqlParser.ALIGNMENT, 0); }
		public ITerminalNode BASETYPE() { return GetToken(PlPgSqlParser.BASETYPE, 0); }
		public ITerminalNode BUFFERS() { return GetToken(PlPgSqlParser.BUFFERS, 0); }
		public ITerminalNode BYPASSRLS() { return GetToken(PlPgSqlParser.BYPASSRLS, 0); }
		public ITerminalNode CANONICAL() { return GetToken(PlPgSqlParser.CANONICAL, 0); }
		public ITerminalNode CATEGORY() { return GetToken(PlPgSqlParser.CATEGORY, 0); }
		public ITerminalNode COLLATABLE() { return GetToken(PlPgSqlParser.COLLATABLE, 0); }
		public ITerminalNode COMBINEFUNC() { return GetToken(PlPgSqlParser.COMBINEFUNC, 0); }
		public ITerminalNode COMMUTATOR() { return GetToken(PlPgSqlParser.COMMUTATOR, 0); }
		public ITerminalNode CONNECT() { return GetToken(PlPgSqlParser.CONNECT, 0); }
		public ITerminalNode COSTS() { return GetToken(PlPgSqlParser.COSTS, 0); }
		public ITerminalNode CREATEDB() { return GetToken(PlPgSqlParser.CREATEDB, 0); }
		public ITerminalNode CREATEROLE() { return GetToken(PlPgSqlParser.CREATEROLE, 0); }
		public ITerminalNode DESERIALFUNC() { return GetToken(PlPgSqlParser.DESERIALFUNC, 0); }
		public ITerminalNode DETERMINISTIC() { return GetToken(PlPgSqlParser.DETERMINISTIC, 0); }
		public ITerminalNode DISABLE_PAGE_SKIPPING() { return GetToken(PlPgSqlParser.DISABLE_PAGE_SKIPPING, 0); }
		public ITerminalNode ELEMENT() { return GetToken(PlPgSqlParser.ELEMENT, 0); }
		public ITerminalNode EXTENDED() { return GetToken(PlPgSqlParser.EXTENDED, 0); }
		public ITerminalNode FINALFUNC() { return GetToken(PlPgSqlParser.FINALFUNC, 0); }
		public ITerminalNode FINALFUNC_EXTRA() { return GetToken(PlPgSqlParser.FINALFUNC_EXTRA, 0); }
		public ITerminalNode FINALFUNC_MODIFY() { return GetToken(PlPgSqlParser.FINALFUNC_MODIFY, 0); }
		public ITerminalNode FORCE_NOT_NULL() { return GetToken(PlPgSqlParser.FORCE_NOT_NULL, 0); }
		public ITerminalNode FORCE_NULL() { return GetToken(PlPgSqlParser.FORCE_NULL, 0); }
		public ITerminalNode FORCE_QUOTE() { return GetToken(PlPgSqlParser.FORCE_QUOTE, 0); }
		public ITerminalNode FORMAT() { return GetToken(PlPgSqlParser.FORMAT, 0); }
		public ITerminalNode GETTOKEN() { return GetToken(PlPgSqlParser.GETTOKEN, 0); }
		public ITerminalNode HASH() { return GetToken(PlPgSqlParser.HASH, 0); }
		public ITerminalNode HASHES() { return GetToken(PlPgSqlParser.HASHES, 0); }
		public ITerminalNode HEADLINE() { return GetToken(PlPgSqlParser.HEADLINE, 0); }
		public ITerminalNode HYPOTHETICAL() { return GetToken(PlPgSqlParser.HYPOTHETICAL, 0); }
		public ITerminalNode INDEX_CLEANUP() { return GetToken(PlPgSqlParser.INDEX_CLEANUP, 0); }
		public ITerminalNode INIT() { return GetToken(PlPgSqlParser.INIT, 0); }
		public ITerminalNode INITCOND() { return GetToken(PlPgSqlParser.INITCOND, 0); }
		public ITerminalNode INTERNALLENGTH() { return GetToken(PlPgSqlParser.INTERNALLENGTH, 0); }
		public ITerminalNode JSON() { return GetToken(PlPgSqlParser.JSON, 0); }
		public ITerminalNode LC_COLLATE() { return GetToken(PlPgSqlParser.LC_COLLATE, 0); }
		public ITerminalNode LC_CTYPE() { return GetToken(PlPgSqlParser.LC_CTYPE, 0); }
		public ITerminalNode LEFTARG() { return GetToken(PlPgSqlParser.LEFTARG, 0); }
		public ITerminalNode LEXIZE() { return GetToken(PlPgSqlParser.LEXIZE, 0); }
		public ITerminalNode LEXTYPES() { return GetToken(PlPgSqlParser.LEXTYPES, 0); }
		public ITerminalNode LIST() { return GetToken(PlPgSqlParser.LIST, 0); }
		public ITerminalNode LOCALE() { return GetToken(PlPgSqlParser.LOCALE, 0); }
		public ITerminalNode LOGIN() { return GetToken(PlPgSqlParser.LOGIN, 0); }
		public ITerminalNode MAIN() { return GetToken(PlPgSqlParser.MAIN, 0); }
		public ITerminalNode MERGES() { return GetToken(PlPgSqlParser.MERGES, 0); }
		public ITerminalNode MFINALFUNC() { return GetToken(PlPgSqlParser.MFINALFUNC, 0); }
		public ITerminalNode MFINALFUNC_EXTRA() { return GetToken(PlPgSqlParser.MFINALFUNC_EXTRA, 0); }
		public ITerminalNode MFINALFUNC_MODIFY() { return GetToken(PlPgSqlParser.MFINALFUNC_MODIFY, 0); }
		public ITerminalNode MINITCOND() { return GetToken(PlPgSqlParser.MINITCOND, 0); }
		public ITerminalNode MINVFUNC() { return GetToken(PlPgSqlParser.MINVFUNC, 0); }
		public ITerminalNode MODULUS() { return GetToken(PlPgSqlParser.MODULUS, 0); }
		public ITerminalNode MSFUNC() { return GetToken(PlPgSqlParser.MSFUNC, 0); }
		public ITerminalNode MSSPACE() { return GetToken(PlPgSqlParser.MSSPACE, 0); }
		public ITerminalNode MSTYPE() { return GetToken(PlPgSqlParser.MSTYPE, 0); }
		public ITerminalNode NEGATOR() { return GetToken(PlPgSqlParser.NEGATOR, 0); }
		public ITerminalNode NOBYPASSRLS() { return GetToken(PlPgSqlParser.NOBYPASSRLS, 0); }
		public ITerminalNode NOCREATEDB() { return GetToken(PlPgSqlParser.NOCREATEDB, 0); }
		public ITerminalNode NOCREATEROLE() { return GetToken(PlPgSqlParser.NOCREATEROLE, 0); }
		public ITerminalNode NOINHERIT() { return GetToken(PlPgSqlParser.NOINHERIT, 0); }
		public ITerminalNode NOLOGIN() { return GetToken(PlPgSqlParser.NOLOGIN, 0); }
		public ITerminalNode NOREPLICATION() { return GetToken(PlPgSqlParser.NOREPLICATION, 0); }
		public ITerminalNode NOSUPERUSER() { return GetToken(PlPgSqlParser.NOSUPERUSER, 0); }
		public ITerminalNode OUTPUT() { return GetToken(PlPgSqlParser.OUTPUT, 0); }
		public ITerminalNode PASSEDBYVALUE() { return GetToken(PlPgSqlParser.PASSEDBYVALUE, 0); }
		public ITerminalNode PATH() { return GetToken(PlPgSqlParser.PATH, 0); }
		public ITerminalNode PERMISSIVE() { return GetToken(PlPgSqlParser.PERMISSIVE, 0); }
		public ITerminalNode PLAIN() { return GetToken(PlPgSqlParser.PLAIN, 0); }
		public ITerminalNode PREFERRED() { return GetToken(PlPgSqlParser.PREFERRED, 0); }
		public ITerminalNode PROVIDER() { return GetToken(PlPgSqlParser.PROVIDER, 0); }
		public ITerminalNode READ_ONLY() { return GetToken(PlPgSqlParser.READ_ONLY, 0); }
		public ITerminalNode READ_WRITE() { return GetToken(PlPgSqlParser.READ_WRITE, 0); }
		public ITerminalNode RECEIVE() { return GetToken(PlPgSqlParser.RECEIVE, 0); }
		public ITerminalNode REPLICATION() { return GetToken(PlPgSqlParser.REPLICATION, 0); }
		public ITerminalNode REMAINDER() { return GetToken(PlPgSqlParser.REMAINDER, 0); }
		public ITerminalNode RESTRICTED() { return GetToken(PlPgSqlParser.RESTRICTED, 0); }
		public ITerminalNode RESTRICTIVE() { return GetToken(PlPgSqlParser.RESTRICTIVE, 0); }
		public ITerminalNode RIGHTARG() { return GetToken(PlPgSqlParser.RIGHTARG, 0); }
		public ITerminalNode SAFE() { return GetToken(PlPgSqlParser.SAFE, 0); }
		public ITerminalNode SEND() { return GetToken(PlPgSqlParser.SEND, 0); }
		public ITerminalNode SERIALFUNC() { return GetToken(PlPgSqlParser.SERIALFUNC, 0); }
		public ITerminalNode SETTINGS() { return GetToken(PlPgSqlParser.SETTINGS, 0); }
		public ITerminalNode SFUNC() { return GetToken(PlPgSqlParser.SFUNC, 0); }
		public ITerminalNode SHAREABLE() { return GetToken(PlPgSqlParser.SHAREABLE, 0); }
		public ITerminalNode SKIP_LOCKED() { return GetToken(PlPgSqlParser.SKIP_LOCKED, 0); }
		public ITerminalNode SORTOP() { return GetToken(PlPgSqlParser.SORTOP, 0); }
		public ITerminalNode SSPACE() { return GetToken(PlPgSqlParser.SSPACE, 0); }
		public ITerminalNode STYPE() { return GetToken(PlPgSqlParser.STYPE, 0); }
		public ITerminalNode SUBTYPE() { return GetToken(PlPgSqlParser.SUBTYPE, 0); }
		public ITerminalNode SUBTYPE_DIFF() { return GetToken(PlPgSqlParser.SUBTYPE_DIFF, 0); }
		public ITerminalNode SUBTYPE_OPCLASS() { return GetToken(PlPgSqlParser.SUBTYPE_OPCLASS, 0); }
		public ITerminalNode SUMMARY() { return GetToken(PlPgSqlParser.SUMMARY, 0); }
		public ITerminalNode SUPERUSER() { return GetToken(PlPgSqlParser.SUPERUSER, 0); }
		public ITerminalNode TIMING() { return GetToken(PlPgSqlParser.TIMING, 0); }
		public ITerminalNode TYPMOD_IN() { return GetToken(PlPgSqlParser.TYPMOD_IN, 0); }
		public ITerminalNode TYPMOD_OUT() { return GetToken(PlPgSqlParser.TYPMOD_OUT, 0); }
		public ITerminalNode UNSAFE() { return GetToken(PlPgSqlParser.UNSAFE, 0); }
		public ITerminalNode USAGE() { return GetToken(PlPgSqlParser.USAGE, 0); }
		public ITerminalNode VARIABLE() { return GetToken(PlPgSqlParser.VARIABLE, 0); }
		public ITerminalNode YAML() { return GetToken(PlPgSqlParser.YAML, 0); }
		public ITerminalNode ALIAS() { return GetToken(PlPgSqlParser.ALIAS, 0); }
		public ITerminalNode ASSERT() { return GetToken(PlPgSqlParser.ASSERT, 0); }
		public ITerminalNode CONSTANT() { return GetToken(PlPgSqlParser.CONSTANT, 0); }
		public ITerminalNode DATATYPE() { return GetToken(PlPgSqlParser.DATATYPE, 0); }
		public ITerminalNode DEBUG() { return GetToken(PlPgSqlParser.DEBUG, 0); }
		public ITerminalNode DETAIL() { return GetToken(PlPgSqlParser.DETAIL, 0); }
		public ITerminalNode DIAGNOSTICS() { return GetToken(PlPgSqlParser.DIAGNOSTICS, 0); }
		public ITerminalNode ELSEIF() { return GetToken(PlPgSqlParser.ELSEIF, 0); }
		public ITerminalNode ELSIF() { return GetToken(PlPgSqlParser.ELSIF, 0); }
		public ITerminalNode ERRCODE() { return GetToken(PlPgSqlParser.ERRCODE, 0); }
		public ITerminalNode EXIT() { return GetToken(PlPgSqlParser.EXIT, 0); }
		public ITerminalNode EXCEPTION() { return GetToken(PlPgSqlParser.EXCEPTION, 0); }
		public ITerminalNode FOREACH() { return GetToken(PlPgSqlParser.FOREACH, 0); }
		public ITerminalNode GET() { return GetToken(PlPgSqlParser.GET, 0); }
		public ITerminalNode HINT() { return GetToken(PlPgSqlParser.HINT, 0); }
		public ITerminalNode INFO() { return GetToken(PlPgSqlParser.INFO, 0); }
		public ITerminalNode LOG() { return GetToken(PlPgSqlParser.LOG, 0); }
		public ITerminalNode LOOP() { return GetToken(PlPgSqlParser.LOOP, 0); }
		public ITerminalNode MESSAGE() { return GetToken(PlPgSqlParser.MESSAGE, 0); }
		public ITerminalNode NOTICE() { return GetToken(PlPgSqlParser.NOTICE, 0); }
		public ITerminalNode OPEN() { return GetToken(PlPgSqlParser.OPEN, 0); }
		public ITerminalNode PERFORM() { return GetToken(PlPgSqlParser.PERFORM, 0); }
		public ITerminalNode QUERY() { return GetToken(PlPgSqlParser.QUERY, 0); }
		public ITerminalNode RAISE() { return GetToken(PlPgSqlParser.RAISE, 0); }
		public ITerminalNode RECORD() { return GetToken(PlPgSqlParser.RECORD, 0); }
		public ITerminalNode RETURN() { return GetToken(PlPgSqlParser.RETURN, 0); }
		public ITerminalNode REVERSE() { return GetToken(PlPgSqlParser.REVERSE, 0); }
		public ITerminalNode ROWTYPE() { return GetToken(PlPgSqlParser.ROWTYPE, 0); }
		public ITerminalNode SLICE() { return GetToken(PlPgSqlParser.SLICE, 0); }
		public ITerminalNode SQLSTATE() { return GetToken(PlPgSqlParser.SQLSTATE, 0); }
		public ITerminalNode STACKED() { return GetToken(PlPgSqlParser.STACKED, 0); }
		public ITerminalNode WARNING() { return GetToken(PlPgSqlParser.WARNING, 0); }
		public ITerminalNode WHILE() { return GetToken(PlPgSqlParser.WHILE, 0); }
		public Tokens_nonkeywordContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tokens_nonkeyword; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlPgSqlParserVisitor<TResult> typedVisitor = visitor as IPlPgSqlParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTokens_nonkeyword(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Tokens_nonkeywordContext tokens_nonkeyword() {
		Tokens_nonkeywordContext _localctx = new Tokens_nonkeywordContext(Context, State);
		EnterRule(_localctx, 330, RULE_tokens_nonkeyword);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3388;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 443)) & ~0x3f) == 0 && ((1L << (_la - 443)) & ((1L << (ALIGNMENT - 443)) | (1L << (BASETYPE - 443)) | (1L << (BUFFERS - 443)) | (1L << (BYPASSRLS - 443)) | (1L << (CANONICAL - 443)) | (1L << (CATEGORY - 443)) | (1L << (COLLATABLE - 443)) | (1L << (COMBINEFUNC - 443)) | (1L << (COMMUTATOR - 443)) | (1L << (CONNECT - 443)) | (1L << (COSTS - 443)) | (1L << (CREATEDB - 443)) | (1L << (CREATEROLE - 443)) | (1L << (DESERIALFUNC - 443)) | (1L << (DETERMINISTIC - 443)) | (1L << (DISABLE_PAGE_SKIPPING - 443)) | (1L << (ELEMENT - 443)) | (1L << (EXTENDED - 443)) | (1L << (FINALFUNC - 443)) | (1L << (FINALFUNC_EXTRA - 443)) | (1L << (FINALFUNC_MODIFY - 443)) | (1L << (FORCE_NOT_NULL - 443)) | (1L << (FORCE_NULL - 443)) | (1L << (FORCE_QUOTE - 443)) | (1L << (FORMAT - 443)) | (1L << (GETTOKEN - 443)) | (1L << (HASH - 443)) | (1L << (HASHES - 443)) | (1L << (HEADLINE - 443)) | (1L << (HYPOTHETICAL - 443)) | (1L << (INDEX_CLEANUP - 443)) | (1L << (INIT - 443)) | (1L << (INITCOND - 443)) | (1L << (INTERNALLENGTH - 443)) | (1L << (JSON - 443)) | (1L << (LC_COLLATE - 443)) | (1L << (LC_CTYPE - 443)) | (1L << (LEFTARG - 443)) | (1L << (LEXIZE - 443)) | (1L << (LEXTYPES - 443)) | (1L << (LIST - 443)) | (1L << (LOCALE - 443)) | (1L << (LOGIN - 443)) | (1L << (MAIN - 443)) | (1L << (MERGES - 443)) | (1L << (MFINALFUNC - 443)) | (1L << (MFINALFUNC_EXTRA - 443)) | (1L << (MFINALFUNC_MODIFY - 443)) | (1L << (MINITCOND - 443)) | (1L << (MINVFUNC - 443)) | (1L << (MODULUS - 443)) | (1L << (MSFUNC - 443)) | (1L << (MSSPACE - 443)) | (1L << (MSTYPE - 443)) | (1L << (NEGATOR - 443)) | (1L << (NOBYPASSRLS - 443)) | (1L << (NOCREATEDB - 443)) | (1L << (NOCREATEROLE - 443)) | (1L << (NOINHERIT - 443)) | (1L << (NOLOGIN - 443)) | (1L << (NOREPLICATION - 443)) | (1L << (NOSUPERUSER - 443)) | (1L << (OUTPUT - 443)) | (1L << (PASSEDBYVALUE - 443)))) != 0) || ((((_la - 507)) & ~0x3f) == 0 && ((1L << (_la - 507)) & ((1L << (PATH - 507)) | (1L << (PERMISSIVE - 507)) | (1L << (PLAIN - 507)) | (1L << (PREFERRED - 507)) | (1L << (PROVIDER - 507)) | (1L << (READ_ONLY - 507)) | (1L << (READ_WRITE - 507)) | (1L << (RECEIVE - 507)) | (1L << (REMAINDER - 507)) | (1L << (REPLICATION - 507)) | (1L << (RESTRICTED - 507)) | (1L << (RESTRICTIVE - 507)) | (1L << (RIGHTARG - 507)) | (1L << (SAFE - 507)) | (1L << (SEND - 507)) | (1L << (SERIALFUNC - 507)) | (1L << (SETTINGS - 507)) | (1L << (SFUNC - 507)) | (1L << (SHAREABLE - 507)) | (1L << (SKIP_LOCKED - 507)) | (1L << (SORTOP - 507)) | (1L << (SSPACE - 507)) | (1L << (STYPE - 507)) | (1L << (SUBTYPE_DIFF - 507)) | (1L << (SUBTYPE_OPCLASS - 507)) | (1L << (SUBTYPE - 507)) | (1L << (SUMMARY - 507)) | (1L << (SUPERUSER - 507)) | (1L << (TIMING - 507)) | (1L << (TYPMOD_IN - 507)) | (1L << (TYPMOD_OUT - 507)) | (1L << (UNSAFE - 507)) | (1L << (USAGE - 507)) | (1L << (VARIABLE - 507)) | (1L << (YAML - 507)) | (1L << (ALIAS - 507)) | (1L << (ASSERT - 507)) | (1L << (CONSTANT - 507)) | (1L << (DATATYPE - 507)) | (1L << (DEBUG - 507)) | (1L << (DETAIL - 507)) | (1L << (DIAGNOSTICS - 507)) | (1L << (ELSEIF - 507)) | (1L << (ELSIF - 507)) | (1L << (ERRCODE - 507)) | (1L << (EXIT - 507)) | (1L << (EXCEPTION - 507)) | (1L << (FOREACH - 507)) | (1L << (GET - 507)) | (1L << (HINT - 507)) | (1L << (INFO - 507)) | (1L << (LOG - 507)) | (1L << (LOOP - 507)) | (1L << (MESSAGE - 507)) | (1L << (NOTICE - 507)) | (1L << (OPEN - 507)) | (1L << (PERFORM - 507)) | (1L << (QUERY - 507)) | (1L << (RAISE - 507)) | (1L << (RECORD - 507)) | (1L << (RETURN - 507)) | (1L << (REVERSE - 507)) | (1L << (ROWTYPE - 507)) | (1L << (SLICE - 507)))) != 0) || ((((_la - 571)) & ~0x3f) == 0 && ((1L << (_la - 571)) & ((1L << (SQLSTATE - 571)) | (1L << (STACKED - 571)) | (1L << (WARNING - 571)) | (1L << (WHILE - 571)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public override bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
		switch (ruleIndex) {
		case 9: return select_ops_sempred((Select_opsContext)_localctx, predIndex);
		case 32: return from_item_sempred((From_itemContext)_localctx, predIndex);
		case 146: return vex_b_sempred((Vex_bContext)_localctx, predIndex);
		case 160: return vex_sempred((VexContext)_localctx, predIndex);
		}
		return true;
	}
	private bool select_ops_sempred(Select_opsContext _localctx, int predIndex) {
		switch (predIndex) {
		case 0: return Precpred(Context, 2);
		}
		return true;
	}
	private bool from_item_sempred(From_itemContext _localctx, int predIndex) {
		switch (predIndex) {
		case 1: return Precpred(Context, 5);
		case 2: return Precpred(Context, 2);
		case 3: return Precpred(Context, 4);
		case 4: return Precpred(Context, 3);
		}
		return true;
	}
	private bool vex_b_sempred(Vex_bContext _localctx, int predIndex) {
		switch (predIndex) {
		case 5: return Precpred(Context, 12);
		case 6: return Precpred(Context, 11);
		case 7: return Precpred(Context, 10);
		case 8: return Precpred(Context, 9);
		case 9: return Precpred(Context, 6);
		case 10: return Precpred(Context, 5);
		case 11: return Precpred(Context, 16);
		case 12: return Precpred(Context, 7);
		case 13: return Precpred(Context, 4);
		case 14: return Precpred(Context, 3);
		case 15: return Precpred(Context, 2);
		}
		return true;
	}
	private bool vex_sempred(VexContext _localctx, int predIndex) {
		switch (predIndex) {
		case 16: return Precpred(Context, 23);
		case 17: return Precpred(Context, 22);
		case 18: return Precpred(Context, 21);
		case 19: return Precpred(Context, 20);
		case 20: return Precpred(Context, 19);
		case 21: return Precpred(Context, 15);
		case 22: return Precpred(Context, 14);
		case 23: return Precpred(Context, 13);
		case 24: return Precpred(Context, 12);
		case 25: return Precpred(Context, 10);
		case 26: return Precpred(Context, 3);
		case 27: return Precpred(Context, 2);
		case 28: return Precpred(Context, 28);
		case 29: return Precpred(Context, 25);
		case 30: return Precpred(Context, 17);
		case 31: return Precpred(Context, 16);
		case 32: return Precpred(Context, 11);
		case 33: return Precpred(Context, 9);
		case 34: return Precpred(Context, 8);
		case 35: return Precpred(Context, 7);
		case 36: return Precpred(Context, 6);
		case 37: return Precpred(Context, 5);
		}
		return true;
	}

	private static char[] _serializedATN = {
		'\x3', '\x608B', '\xA72A', '\x8133', '\xB9ED', '\x417C', '\x3BE7', '\x7786', 
		'\x5964', '\x3', '\x270', '\xD41', '\x4', '\x2', '\t', '\x2', '\x4', '\x3', 
		'\t', '\x3', '\x4', '\x4', '\t', '\x4', '\x4', '\x5', '\t', '\x5', '\x4', 
		'\x6', '\t', '\x6', '\x4', '\a', '\t', '\a', '\x4', '\b', '\t', '\b', 
		'\x4', '\t', '\t', '\t', '\x4', '\n', '\t', '\n', '\x4', '\v', '\t', '\v', 
		'\x4', '\f', '\t', '\f', '\x4', '\r', '\t', '\r', '\x4', '\xE', '\t', 
		'\xE', '\x4', '\xF', '\t', '\xF', '\x4', '\x10', '\t', '\x10', '\x4', 
		'\x11', '\t', '\x11', '\x4', '\x12', '\t', '\x12', '\x4', '\x13', '\t', 
		'\x13', '\x4', '\x14', '\t', '\x14', '\x4', '\x15', '\t', '\x15', '\x4', 
		'\x16', '\t', '\x16', '\x4', '\x17', '\t', '\x17', '\x4', '\x18', '\t', 
		'\x18', '\x4', '\x19', '\t', '\x19', '\x4', '\x1A', '\t', '\x1A', '\x4', 
		'\x1B', '\t', '\x1B', '\x4', '\x1C', '\t', '\x1C', '\x4', '\x1D', '\t', 
		'\x1D', '\x4', '\x1E', '\t', '\x1E', '\x4', '\x1F', '\t', '\x1F', '\x4', 
		' ', '\t', ' ', '\x4', '!', '\t', '!', '\x4', '\"', '\t', '\"', '\x4', 
		'#', '\t', '#', '\x4', '$', '\t', '$', '\x4', '%', '\t', '%', '\x4', '&', 
		'\t', '&', '\x4', '\'', '\t', '\'', '\x4', '(', '\t', '(', '\x4', ')', 
		'\t', ')', '\x4', '*', '\t', '*', '\x4', '+', '\t', '+', '\x4', ',', '\t', 
		',', '\x4', '-', '\t', '-', '\x4', '.', '\t', '.', '\x4', '/', '\t', '/', 
		'\x4', '\x30', '\t', '\x30', '\x4', '\x31', '\t', '\x31', '\x4', '\x32', 
		'\t', '\x32', '\x4', '\x33', '\t', '\x33', '\x4', '\x34', '\t', '\x34', 
		'\x4', '\x35', '\t', '\x35', '\x4', '\x36', '\t', '\x36', '\x4', '\x37', 
		'\t', '\x37', '\x4', '\x38', '\t', '\x38', '\x4', '\x39', '\t', '\x39', 
		'\x4', ':', '\t', ':', '\x4', ';', '\t', ';', '\x4', '<', '\t', '<', '\x4', 
		'=', '\t', '=', '\x4', '>', '\t', '>', '\x4', '?', '\t', '?', '\x4', '@', 
		'\t', '@', '\x4', '\x41', '\t', '\x41', '\x4', '\x42', '\t', '\x42', '\x4', 
		'\x43', '\t', '\x43', '\x4', '\x44', '\t', '\x44', '\x4', '\x45', '\t', 
		'\x45', '\x4', '\x46', '\t', '\x46', '\x4', 'G', '\t', 'G', '\x4', 'H', 
		'\t', 'H', '\x4', 'I', '\t', 'I', '\x4', 'J', '\t', 'J', '\x4', 'K', '\t', 
		'K', '\x4', 'L', '\t', 'L', '\x4', 'M', '\t', 'M', '\x4', 'N', '\t', 'N', 
		'\x4', 'O', '\t', 'O', '\x4', 'P', '\t', 'P', '\x4', 'Q', '\t', 'Q', '\x4', 
		'R', '\t', 'R', '\x4', 'S', '\t', 'S', '\x4', 'T', '\t', 'T', '\x4', 'U', 
		'\t', 'U', '\x4', 'V', '\t', 'V', '\x4', 'W', '\t', 'W', '\x4', 'X', '\t', 
		'X', '\x4', 'Y', '\t', 'Y', '\x4', 'Z', '\t', 'Z', '\x4', '[', '\t', '[', 
		'\x4', '\\', '\t', '\\', '\x4', ']', '\t', ']', '\x4', '^', '\t', '^', 
		'\x4', '_', '\t', '_', '\x4', '`', '\t', '`', '\x4', '\x61', '\t', '\x61', 
		'\x4', '\x62', '\t', '\x62', '\x4', '\x63', '\t', '\x63', '\x4', '\x64', 
		'\t', '\x64', '\x4', '\x65', '\t', '\x65', '\x4', '\x66', '\t', '\x66', 
		'\x4', 'g', '\t', 'g', '\x4', 'h', '\t', 'h', '\x4', 'i', '\t', 'i', '\x4', 
		'j', '\t', 'j', '\x4', 'k', '\t', 'k', '\x4', 'l', '\t', 'l', '\x4', 'm', 
		'\t', 'm', '\x4', 'n', '\t', 'n', '\x4', 'o', '\t', 'o', '\x4', 'p', '\t', 
		'p', '\x4', 'q', '\t', 'q', '\x4', 'r', '\t', 'r', '\x4', 's', '\t', 's', 
		'\x4', 't', '\t', 't', '\x4', 'u', '\t', 'u', '\x4', 'v', '\t', 'v', '\x4', 
		'w', '\t', 'w', '\x4', 'x', '\t', 'x', '\x4', 'y', '\t', 'y', '\x4', 'z', 
		'\t', 'z', '\x4', '{', '\t', '{', '\x4', '|', '\t', '|', '\x4', '}', '\t', 
		'}', '\x4', '~', '\t', '~', '\x4', '\x7F', '\t', '\x7F', '\x4', '\x80', 
		'\t', '\x80', '\x4', '\x81', '\t', '\x81', '\x4', '\x82', '\t', '\x82', 
		'\x4', '\x83', '\t', '\x83', '\x4', '\x84', '\t', '\x84', '\x4', '\x85', 
		'\t', '\x85', '\x4', '\x86', '\t', '\x86', '\x4', '\x87', '\t', '\x87', 
		'\x4', '\x88', '\t', '\x88', '\x4', '\x89', '\t', '\x89', '\x4', '\x8A', 
		'\t', '\x8A', '\x4', '\x8B', '\t', '\x8B', '\x4', '\x8C', '\t', '\x8C', 
		'\x4', '\x8D', '\t', '\x8D', '\x4', '\x8E', '\t', '\x8E', '\x4', '\x8F', 
		'\t', '\x8F', '\x4', '\x90', '\t', '\x90', '\x4', '\x91', '\t', '\x91', 
		'\x4', '\x92', '\t', '\x92', '\x4', '\x93', '\t', '\x93', '\x4', '\x94', 
		'\t', '\x94', '\x4', '\x95', '\t', '\x95', '\x4', '\x96', '\t', '\x96', 
		'\x4', '\x97', '\t', '\x97', '\x4', '\x98', '\t', '\x98', '\x4', '\x99', 
		'\t', '\x99', '\x4', '\x9A', '\t', '\x9A', '\x4', '\x9B', '\t', '\x9B', 
		'\x4', '\x9C', '\t', '\x9C', '\x4', '\x9D', '\t', '\x9D', '\x4', '\x9E', 
		'\t', '\x9E', '\x4', '\x9F', '\t', '\x9F', '\x4', '\xA0', '\t', '\xA0', 
		'\x4', '\xA1', '\t', '\xA1', '\x4', '\xA2', '\t', '\xA2', '\x4', '\xA3', 
		'\t', '\xA3', '\x4', '\xA4', '\t', '\xA4', '\x4', '\xA5', '\t', '\xA5', 
		'\x4', '\xA6', '\t', '\xA6', '\x4', '\xA7', '\t', '\xA7', '\x3', '\x2', 
		'\x3', '\x2', '\x5', '\x2', '\x151', '\n', '\x2', '\x3', '\x2', '\x3', 
		'\x2', '\x3', '\x3', '\x5', '\x3', '\x156', '\n', '\x3', '\x3', '\x3', 
		'\x5', '\x3', '\x159', '\n', '\x3', '\x3', '\x3', '\x3', '\x3', '\x3', 
		'\x3', '\x5', '\x3', '\x15E', '\n', '\x3', '\x3', '\x3', '\x5', '\x3', 
		'\x161', '\n', '\x3', '\x3', '\x3', '\x5', '\x3', '\x164', '\n', '\x3', 
		'\x3', '\x4', '\x3', '\x4', '\x3', '\x4', '\x5', '\x4', '\x169', '\n', 
		'\x4', '\x3', '\x5', '\x3', '\x5', '\x3', '\x5', '\x5', '\x5', '\x16E', 
		'\n', '\x5', '\x3', '\x6', '\x3', '\x6', '\x3', '\x6', '\x3', '\x6', '\x3', 
		'\a', '\x3', '\a', '\a', '\a', '\x176', '\n', '\a', '\f', '\a', '\xE', 
		'\a', '\x179', '\v', '\a', '\x3', '\b', '\a', '\b', '\x17C', '\n', '\b', 
		'\f', '\b', '\xE', '\b', '\x17F', '\v', '\b', '\x3', '\b', '\x3', '\b', 
		'\x3', '\b', '\x3', '\b', '\x3', '\t', '\x5', '\t', '\x186', '\n', '\t', 
		'\x3', '\t', '\x3', '\t', '\x5', '\t', '\x18A', '\n', '\t', '\x3', '\t', 
		'\x3', '\t', '\x5', '\t', '\x18E', '\n', '\t', '\x3', '\t', '\x3', '\t', 
		'\x5', '\t', '\x192', '\n', '\t', '\x3', '\t', '\x3', '\t', '\x3', '\t', 
		'\x3', '\t', '\x5', '\t', '\x198', '\n', '\t', '\x3', '\t', '\x5', '\t', 
		'\x19B', '\n', '\t', '\x3', '\t', '\x5', '\t', '\x19E', '\n', '\t', '\x3', 
		'\t', '\x3', '\t', '\x3', '\t', '\x3', '\t', '\x3', '\t', '\x5', '\t', 
		'\x1A5', '\n', '\t', '\x3', '\t', '\x3', '\t', '\x5', '\t', '\x1A9', '\n', 
		'\t', '\x3', '\n', '\x5', '\n', '\x1AC', '\n', '\n', '\x3', '\n', '\x3', 
		'\n', '\a', '\n', '\x1B0', '\n', '\n', '\f', '\n', '\xE', '\n', '\x1B3', 
		'\v', '\n', '\x3', '\v', '\x3', '\v', '\x3', '\v', '\x3', '\v', '\x3', 
		'\v', '\x3', '\v', '\x5', '\v', '\x1BB', '\n', '\v', '\x3', '\v', '\x3', 
		'\v', '\x3', '\v', '\x5', '\v', '\x1C0', '\n', '\v', '\x3', '\v', '\a', 
		'\v', '\x1C3', '\n', '\v', '\f', '\v', '\xE', '\v', '\x1C6', '\v', '\v', 
		'\x3', '\f', '\x3', '\f', '\x3', '\f', '\x3', '\f', '\x3', '\f', '\x3', 
		'\f', '\x3', '\f', '\a', '\f', '\x1CF', '\n', '\f', '\f', '\f', '\xE', 
		'\f', '\x1D2', '\v', '\f', '\x3', '\f', '\x3', '\f', '\x5', '\f', '\x1D6', 
		'\n', '\f', '\x5', '\f', '\x1D8', '\n', '\f', '\x3', '\f', '\x5', '\f', 
		'\x1DB', '\n', '\f', '\x3', '\f', '\x5', '\f', '\x1DE', '\n', '\f', '\x3', 
		'\f', '\x3', '\f', '\x3', '\f', '\x3', '\f', '\a', '\f', '\x1E4', '\n', 
		'\f', '\f', '\f', '\xE', '\f', '\x1E7', '\v', '\f', '\x5', '\f', '\x1E9', 
		'\n', '\f', '\x3', '\f', '\x3', '\f', '\x5', '\f', '\x1ED', '\n', '\f', 
		'\x3', '\f', '\x5', '\f', '\x1F0', '\n', '\f', '\x3', '\f', '\x3', '\f', 
		'\x5', '\f', '\x1F4', '\n', '\f', '\x3', '\f', '\x3', '\f', '\x3', '\f', 
		'\x3', '\f', '\x3', '\f', '\x3', '\f', '\x3', '\f', '\x3', '\f', '\x3', 
		'\f', '\a', '\f', '\x1FF', '\n', '\f', '\f', '\f', '\xE', '\f', '\x202', 
		'\v', '\f', '\x5', '\f', '\x204', '\n', '\f', '\x3', '\f', '\x3', '\f', 
		'\x5', '\f', '\x208', '\n', '\f', '\x3', '\f', '\x3', '\f', '\x5', '\f', 
		'\x20C', '\n', '\f', '\x3', '\f', '\x5', '\f', '\x20F', '\n', '\f', '\x3', 
		'\r', '\x3', '\r', '\x5', '\r', '\x213', '\n', '\r', '\x3', '\r', '\x5', 
		'\r', '\x216', '\n', '\r', '\x3', '\r', '\x5', '\r', '\x219', '\n', '\r', 
		'\x3', '\r', '\x5', '\r', '\x21C', '\n', '\r', '\x3', '\r', '\x3', '\r', 
		'\x3', '\xE', '\x3', '\xE', '\x3', '\xE', '\x3', '\xE', '\x3', '\xE', 
		'\x3', '\xE', '\x3', '\xE', '\x5', '\xE', '\x227', '\n', '\xE', '\x3', 
		'\xE', '\x3', '\xE', '\x3', '\xE', '\x3', '\xE', '\x3', '\xE', '\x3', 
		'\xE', '\x3', '\xE', '\x5', '\xE', '\x230', '\n', '\xE', '\x5', '\xE', 
		'\x232', '\n', '\xE', '\x3', '\xF', '\x3', '\xF', '\x3', '\xF', '\x3', 
		'\xF', '\x3', '\xF', '\x5', '\xF', '\x239', '\n', '\xF', '\x3', '\x10', 
		'\x3', '\x10', '\x3', '\x10', '\x3', '\x10', '\x3', '\x11', '\x3', '\x11', 
		'\x3', '\x11', '\a', '\x11', '\x242', '\n', '\x11', '\f', '\x11', '\xE', 
		'\x11', '\x245', '\v', '\x11', '\x3', '\x12', '\x3', '\x12', '\x5', '\x12', 
		'\x249', '\n', '\x12', '\x3', '\x12', '\x5', '\x12', '\x24C', '\n', '\x12', 
		'\x3', '\x12', '\x5', '\x12', '\x24F', '\n', '\x12', '\x3', '\x13', '\x3', 
		'\x13', '\x3', '\x13', '\x3', '\x14', '\x3', '\x14', '\x3', '\x14', '\x3', 
		'\x14', '\x5', '\x14', '\x258', '\n', '\x14', '\x3', '\x15', '\x3', '\x15', 
		'\x3', '\x15', '\x3', '\x15', '\x3', '\x15', '\x3', '\x15', '\x3', '\x15', 
		'\x3', '\x15', '\x5', '\x15', '\x262', '\n', '\x15', '\x3', '\x16', '\x3', 
		'\x16', '\x3', '\x16', '\x3', '\x16', '\x3', '\x16', '\x3', '\x16', '\x3', 
		'\x16', '\x3', '\x16', '\x3', '\x16', '\x3', '\x16', '\x3', '\x16', '\x3', 
		'\x16', '\x3', '\x16', '\x5', '\x16', '\x271', '\n', '\x16', '\x3', '\x17', 
		'\x3', '\x17', '\x3', '\x18', '\x3', '\x18', '\x3', '\x18', '\x3', '\x18', 
		'\a', '\x18', '\x279', '\n', '\x18', '\f', '\x18', '\xE', '\x18', '\x27C', 
		'\v', '\x18', '\x3', '\x19', '\x3', '\x19', '\x3', '\x19', '\x5', '\x19', 
		'\x281', '\n', '\x19', '\x3', '\x19', '\x3', '\x19', '\x3', '\x19', '\x5', 
		'\x19', '\x286', '\n', '\x19', '\a', '\x19', '\x288', '\n', '\x19', '\f', 
		'\x19', '\xE', '\x19', '\x28B', '\v', '\x19', '\x3', '\x19', '\x3', '\x19', 
		'\x3', '\x1A', '\x3', '\x1A', '\x3', '\x1A', '\x3', '\x1A', '\x3', '\x1A', 
		'\a', '\x1A', '\x294', '\n', '\x1A', '\f', '\x1A', '\xE', '\x1A', '\x297', 
		'\v', '\x1A', '\x3', '\x1B', '\x3', '\x1B', '\x3', '\x1B', '\x3', '\x1B', 
		'\x3', '\x1B', '\x5', '\x1B', '\x29E', '\n', '\x1B', '\x5', '\x1B', '\x2A0', 
		'\n', '\x1B', '\x3', '\x1C', '\x3', '\x1C', '\x3', '\x1C', '\a', '\x1C', 
		'\x2A5', '\n', '\x1C', '\f', '\x1C', '\xE', '\x1C', '\x2A8', '\v', '\x1C', 
		'\x3', '\x1D', '\x3', '\x1D', '\x3', '\x1D', '\x3', '\x1D', '\x5', '\x1D', 
		'\x2AE', '\n', '\x1D', '\x3', '\x1E', '\x3', '\x1E', '\x3', '\x1E', '\x3', 
		'\x1E', '\x5', '\x1E', '\x2B4', '\n', '\x1E', '\x3', '\x1F', '\x3', '\x1F', 
		'\x3', '\x1F', '\x3', '\x1F', '\x3', ' ', '\x3', ' ', '\x3', ' ', '\a', 
		' ', '\x2BD', '\n', ' ', '\f', ' ', '\xE', ' ', '\x2C0', '\v', ' ', '\x3', 
		'!', '\x3', '!', '\x3', '!', '\x3', '!', '\x3', '!', '\x3', '!', '\x3', 
		'!', '\x5', '!', '\x2C9', '\n', '!', '\x3', '!', '\x3', '!', '\x3', '!', 
		'\x3', '!', '\x5', '!', '\x2CF', '\n', '!', '\x3', '\"', '\x3', '\"', 
		'\x3', '\"', '\x3', '\"', '\x3', '\"', '\x5', '\"', '\x2D6', '\n', '\"', 
		'\x3', '\"', '\x5', '\"', '\x2D9', '\n', '\"', '\x3', '\"', '\x3', '\"', 
		'\x3', '\"', '\x3', '\"', '\x3', '\"', '\x3', '\"', '\x3', '\"', '\x3', 
		'\"', '\x3', '\"', '\x5', '\"', '\x2E4', '\n', '\"', '\x5', '\"', '\x2E6', 
		'\n', '\"', '\x3', '\"', '\x3', '\"', '\x3', '\"', '\x3', '\"', '\x3', 
		'\"', '\x3', '\"', '\x5', '\"', '\x2EE', '\n', '\"', '\x5', '\"', '\x2F0', 
		'\n', '\"', '\x3', '\"', '\x3', '\"', '\x3', '\"', '\x3', '\"', '\x3', 
		'\"', '\x3', '\"', '\x3', '\"', '\x3', '\"', '\x3', '\"', '\x5', '\"', 
		'\x2FB', '\n', '\"', '\x5', '\"', '\x2FD', '\n', '\"', '\x3', '\"', '\x3', 
		'\"', '\x3', '\"', '\x3', '\"', '\x3', '\"', '\a', '\"', '\x304', '\n', 
		'\"', '\f', '\"', '\xE', '\"', '\x307', '\v', '\"', '\x3', '#', '\x5', 
		'#', '\x30A', '\n', '#', '\x3', '#', '\x3', '#', '\x5', '#', '\x30E', 
		'\n', '#', '\x3', '#', '\x5', '#', '\x311', '\n', '#', '\x3', '#', '\x3', 
		'#', '\x3', '#', '\x3', '#', '\x3', '#', '\x3', '#', '\a', '#', '\x319', 
		'\n', '#', '\f', '#', '\xE', '#', '\x31C', '\v', '#', '\x3', '#', '\x3', 
		'#', '\x3', '#', '\x5', '#', '\x321', '\n', '#', '\x5', '#', '\x323', 
		'\n', '#', '\x3', '#', '\x5', '#', '\x326', '\n', '#', '\x3', '#', '\x3', 
		'#', '\x3', '#', '\x3', '#', '\x5', '#', '\x32C', '\n', '#', '\x3', '#', 
		'\x3', '#', '\x3', '#', '\x5', '#', '\x331', '\n', '#', '\x3', '#', '\x3', 
		'#', '\x3', '#', '\x5', '#', '\x336', '\n', '#', '\x3', '#', '\x3', '#', 
		'\x3', '#', '\x3', '#', '\x3', '#', '\a', '#', '\x33D', '\n', '#', '\f', 
		'#', '\xE', '#', '\x340', '\v', '#', '\x3', '#', '\x3', '#', '\x3', '#', 
		'\x5', '#', '\x345', '\n', '#', '\x5', '#', '\x347', '\n', '#', '\x3', 
		'#', '\x5', '#', '\x34A', '\n', '#', '\x3', '#', '\x3', '#', '\x3', '#', 
		'\x3', '#', '\x3', '#', '\x3', '#', '\x5', '#', '\x352', '\n', '#', '\x3', 
		'#', '\x3', '#', '\x3', '#', '\x3', '#', '\x5', '#', '\x358', '\n', '#', 
		'\a', '#', '\x35A', '\n', '#', '\f', '#', '\xE', '#', '\x35D', '\v', '#', 
		'\x3', '#', '\x3', '#', '\x3', '#', '\x5', '#', '\x362', '\n', '#', '\x3', 
		'#', '\x5', '#', '\x365', '\n', '#', '\x3', '#', '\x3', '#', '\x3', '#', 
		'\x3', '#', '\x3', '#', '\a', '#', '\x36C', '\n', '#', '\f', '#', '\xE', 
		'#', '\x36F', '\v', '#', '\x3', '#', '\x3', '#', '\x5', '#', '\x373', 
		'\n', '#', '\x5', '#', '\x375', '\n', '#', '\x5', '#', '\x377', '\n', 
		'#', '\x3', '$', '\x3', '$', '\x3', '$', '\x3', '$', '\x3', '$', '\x3', 
		'$', '\x3', '$', '\a', '$', '\x380', '\n', '$', '\f', '$', '\xE', '$', 
		'\x383', '\v', '$', '\x3', '$', '\x3', '$', '\x3', '%', '\x5', '%', '\x388', 
		'\n', '%', '\x3', '%', '\x3', '%', '\x3', '%', '\x5', '%', '\x38D', '\n', 
		'%', '\x3', '%', '\x6', '%', '\x390', '\n', '%', '\r', '%', '\xE', '%', 
		'\x391', '\x5', '%', '\x394', '\n', '%', '\x3', '&', '\x3', '&', '\x5', 
		'&', '\x398', '\n', '&', '\x3', '&', '\x3', '&', '\x3', '\'', '\x3', '\'', 
		'\x3', '\'', '\x5', '\'', '\x39F', '\n', '\'', '\x3', '\'', '\x5', '\'', 
		'\x3A2', '\n', '\'', '\x3', '\'', '\x3', '\'', '\x3', '\'', '\x5', '\'', 
		'\x3A7', '\n', '\'', '\x3', '\'', '\x3', '\'', '\x5', '\'', '\x3AB', '\n', 
		'\'', '\x3', '\'', '\x3', '\'', '\x3', '\'', '\x3', '\'', '\x5', '\'', 
		'\x3B1', '\n', '\'', '\x3', '\'', '\x3', '\'', '\x3', '\'', '\x3', '\'', 
		'\x5', '\'', '\x3B7', '\n', '\'', '\x3', '\'', '\x5', '\'', '\x3BA', '\n', 
		'\'', '\x3', '\'', '\x5', '\'', '\x3BD', '\n', '\'', '\x3', '\'', '\x3', 
		'\'', '\x5', '\'', '\x3C1', '\n', '\'', '\x3', '\'', '\x5', '\'', '\x3C4', 
		'\n', '\'', '\x3', '\'', '\x3', '\'', '\x5', '\'', '\x3C8', '\n', '\'', 
		'\x3', '\'', '\x5', '\'', '\x3CB', '\n', '\'', '\x3', '\'', '\x3', '\'', 
		'\x5', '\'', '\x3CF', '\n', '\'', '\x3', '\'', '\x3', '\'', '\x3', '\'', 
		'\x3', '\'', '\x5', '\'', '\x3D5', '\n', '\'', '\x3', '\'', '\x3', '\'', 
		'\x3', '\'', '\x5', '\'', '\x3DA', '\n', '\'', '\x3', '\'', '\x3', '\'', 
		'\x5', '\'', '\x3DE', '\n', '\'', '\x3', '\'', '\x3', '\'', '\x3', '\'', 
		'\x5', '\'', '\x3E3', '\n', '\'', '\x3', '\'', '\x3', '\'', '\x5', '\'', 
		'\x3E7', '\n', '\'', '\x3', '\'', '\x3', '\'', '\x3', '\'', '\x3', '\'', 
		'\x3', '\'', '\a', '\'', '\x3EE', '\n', '\'', '\f', '\'', '\xE', '\'', 
		'\x3F1', '\v', '\'', '\x3', '\'', '\x3', '\'', '\x5', '\'', '\x3F5', '\n', 
		'\'', '\x5', '\'', '\x3F7', '\n', '\'', '\x3', '(', '\x3', '(', '\x3', 
		'(', '\x3', '(', '\x3', '(', '\x5', '(', '\x3FE', '\n', '(', '\x3', ')', 
		'\x3', ')', '\x3', ')', '\x5', ')', '\x403', '\n', ')', '\x3', '*', '\x3', 
		'*', '\x3', '*', '\x3', '*', '\x3', '*', '\x3', '*', '\x3', '*', '\x3', 
		'*', '\x3', '*', '\x3', '*', '\x3', '*', '\x3', '*', '\x3', '*', '\x3', 
		'*', '\x3', '*', '\x3', '*', '\x3', '*', '\x3', '*', '\x3', '*', '\x3', 
		'*', '\x3', '*', '\x3', '*', '\x3', '*', '\x3', '*', '\x3', '*', '\x3', 
		'*', '\x3', '*', '\x5', '*', '\x420', '\n', '*', '\x3', '+', '\x3', '+', 
		'\x3', '+', '\x3', '+', '\x3', ',', '\x3', ',', '\x3', ',', '\x3', ',', 
		'\x5', ',', '\x42A', '\n', ',', '\x3', ',', '\x3', ',', '\x3', '-', '\x3', 
		'-', '\x3', '-', '\x5', '-', '\x431', '\n', '-', '\x3', '-', '\x3', '-', 
		'\x3', '-', '\a', '-', '\x436', '\n', '-', '\f', '-', '\xE', '-', '\x439', 
		'\v', '-', '\x3', '-', '\x5', '-', '\x43C', '\n', '-', '\x5', '-', '\x43E', 
		'\n', '-', '\x3', '-', '\x3', '-', '\x3', '-', '\x3', '-', '\x3', '-', 
		'\x3', '-', '\x3', '-', '\x5', '-', '\x447', '\n', '-', '\x3', '-', '\x5', 
		'-', '\x44A', '\n', '-', '\x3', '-', '\x3', '-', '\x3', '-', '\x5', '-', 
		'\x44F', '\n', '-', '\x5', '-', '\x451', '\n', '-', '\x3', '-', '\x3', 
		'-', '\x3', '-', '\x3', '-', '\x3', '-', '\x3', '-', '\x5', '-', '\x459', 
		'\n', '-', '\x3', '.', '\x3', '.', '\x3', '.', '\x3', '.', '\x3', '.', 
		'\x3', '.', '\x3', '.', '\x3', '.', '\x3', '.', '\x3', '.', '\x5', '.', 
		'\x465', '\n', '.', '\x3', '.', '\x3', '.', '\x3', '.', '\x3', '.', '\x5', 
		'.', '\x46B', '\n', '.', '\a', '.', '\x46D', '\n', '.', '\f', '.', '\xE', 
		'.', '\x470', '\v', '.', '\x3', '.', '\x3', '.', '\x5', '.', '\x474', 
		'\n', '.', '\x3', '.', '\x3', '.', '\a', '.', '\x478', '\n', '.', '\f', 
		'.', '\xE', '.', '\x47B', '\v', '.', '\x3', '.', '\x3', '.', '\x3', '.', 
		'\x3', '.', '\x3', '.', '\x3', '.', '\x3', '.', '\x5', '.', '\x484', '\n', 
		'.', '\x3', '.', '\x3', '.', '\x3', '.', '\x3', '.', '\x5', '.', '\x48A', 
		'\n', '.', '\a', '.', '\x48C', '\n', '.', '\f', '.', '\xE', '.', '\x48F', 
		'\v', '.', '\x3', '.', '\x3', '.', '\x3', '.', '\x3', '.', '\x3', '.', 
		'\x3', '.', '\x3', '.', '\x3', '.', '\x5', '.', '\x499', '\n', '.', '\x3', 
		'.', '\x3', '.', '\x3', '.', '\x3', '.', '\x3', '.', '\x3', '.', '\x3', 
		'.', '\x3', '.', '\x3', '.', '\x3', '.', '\x5', '.', '\x4A5', '\n', '.', 
		'\x3', '.', '\x3', '.', '\x3', '.', '\x3', '.', '\x3', '.', '\x3', '.', 
		'\x5', '.', '\x4AD', '\n', '.', '\x5', '.', '\x4AF', '\n', '.', '\x3', 
		'.', '\x3', '.', '\x3', '.', '\x3', '.', '\x3', '.', '\x3', '.', '\x3', 
		'.', '\x3', '.', '\x5', '.', '\x4B9', '\n', '.', '\x3', '.', '\x3', '.', 
		'\x3', '.', '\x5', '.', '\x4BE', '\n', '.', '\x3', '.', '\x3', '.', '\x3', 
		'.', '\x3', '.', '\x3', '.', '\x3', '.', '\x3', '.', '\x3', '.', '\x3', 
		'.', '\x3', '.', '\x3', '.', '\x3', '.', '\x3', '.', '\x3', '.', '\x3', 
		'.', '\x3', '.', '\x3', '.', '\x3', '.', '\x3', '.', '\x3', '.', '\x3', 
		'.', '\x3', '.', '\x3', '.', '\x3', '.', '\x3', '.', '\x3', '.', '\x3', 
		'.', '\x3', '.', '\a', '.', '\x4DC', '\n', '.', '\f', '.', '\xE', '.', 
		'\x4DF', '\v', '.', '\x3', '.', '\x3', '.', '\x3', '.', '\x5', '.', '\x4E4', 
		'\n', '.', '\x3', '.', '\x3', '.', '\x3', '.', '\x3', '.', '\x5', '.', 
		'\x4EA', '\n', '.', '\x3', '.', '\x3', '.', '\x3', '.', '\x5', '.', '\x4EF', 
		'\n', '.', '\x3', '.', '\x3', '.', '\x3', '.', '\x3', '.', '\a', '.', 
		'\x4F5', '\n', '.', '\f', '.', '\xE', '.', '\x4F8', '\v', '.', '\x3', 
		'.', '\x3', '.', '\x5', '.', '\x4FC', '\n', '.', '\x3', '/', '\x3', '/', 
		'\x3', '/', '\x3', '/', '\x5', '/', '\x502', '\n', '/', '\x3', '/', '\x3', 
		'/', '\x5', '/', '\x506', '\n', '/', '\x3', '/', '\x5', '/', '\x509', 
		'\n', '/', '\x3', '/', '\x5', '/', '\x50C', '\n', '/', '\x3', '/', '\x3', 
		'/', '\x5', '/', '\x510', '\n', '/', '\x3', '\x30', '\x3', '\x30', '\x3', 
		'\x30', '\x5', '\x30', '\x515', '\n', '\x30', '\x3', '\x30', '\x3', '\x30', 
		'\x3', '\x30', '\x3', '\x30', '\x3', '\x30', '\x5', '\x30', '\x51C', '\n', 
		'\x30', '\x3', '\x30', '\x3', '\x30', '\x3', '\x30', '\x5', '\x30', '\x521', 
		'\n', '\x30', '\x5', '\x30', '\x523', '\n', '\x30', '\x3', '\x30', '\x3', 
		'\x30', '\x3', '\x30', '\x3', '\x30', '\x3', '\x30', '\x3', '\x30', '\x3', 
		'\x30', '\a', '\x30', '\x52C', '\n', '\x30', '\f', '\x30', '\xE', '\x30', 
		'\x52F', '\v', '\x30', '\x3', '\x30', '\x3', '\x30', '\x5', '\x30', '\x533', 
		'\n', '\x30', '\x3', '\x30', '\x3', '\x30', '\x5', '\x30', '\x537', '\n', 
		'\x30', '\x3', '\x30', '\x3', '\x30', '\x3', '\x30', '\x3', '\x30', '\x3', 
		'\x30', '\x3', '\x30', '\x3', '\x30', '\x3', '\x30', '\x3', '\x30', '\x3', 
		'\x30', '\x3', '\x30', '\x3', '\x30', '\x3', '\x30', '\x3', '\x30', '\x3', 
		'\x30', '\x3', '\x30', '\x3', '\x30', '\x3', '\x30', '\x5', '\x30', '\x54B', 
		'\n', '\x30', '\x3', '\x30', '\x3', '\x30', '\x3', '\x30', '\x3', '\x30', 
		'\x3', '\x30', '\x3', '\x30', '\x3', '\x30', '\x3', '\x30', '\x5', '\x30', 
		'\x555', '\n', '\x30', '\x3', '\x31', '\x3', '\x31', '\x3', '\x31', '\x5', 
		'\x31', '\x55A', '\n', '\x31', '\x3', '\x31', '\x3', '\x31', '\x5', '\x31', 
		'\x55E', '\n', '\x31', '\x3', '\x31', '\x3', '\x31', '\x5', '\x31', '\x562', 
		'\n', '\x31', '\x3', '\x31', '\x3', '\x31', '\x5', '\x31', '\x566', '\n', 
		'\x31', '\x5', '\x31', '\x568', '\n', '\x31', '\x3', '\x32', '\x3', '\x32', 
		'\x3', '\x32', '\x3', '\x32', '\x3', '\x32', '\x3', '\x32', '\x5', '\x32', 
		'\x570', '\n', '\x32', '\x3', '\x33', '\x3', '\x33', '\x3', '\x33', '\x3', 
		'\x33', '\x3', '\x33', '\x3', '\x33', '\x3', '\x33', '\x3', '\x34', '\x3', 
		'\x34', '\x3', '\x34', '\x3', '\x34', '\x5', '\x34', '\x57D', '\n', '\x34', 
		'\x3', '\x34', '\x3', '\x34', '\x3', '\x34', '\x3', '\x34', '\x3', '\x35', 
		'\x3', '\x35', '\a', '\x35', '\x585', '\n', '\x35', '\f', '\x35', '\xE', 
		'\x35', '\x588', '\v', '\x35', '\x3', '\x35', '\x3', '\x35', '\x5', '\x35', 
		'\x58C', '\n', '\x35', '\x3', '\x36', '\x3', '\x36', '\x3', '\x36', '\x3', 
		'\x36', '\x3', '\x36', '\a', '\x36', '\x593', '\n', '\x36', '\f', '\x36', 
		'\xE', '\x36', '\x596', '\v', '\x36', '\x3', '\x36', '\x3', '\x36', '\x3', 
		'\x36', '\x3', '\x36', '\x3', '\x36', '\x3', '\x36', '\x3', '\x36', '\a', 
		'\x36', '\x59F', '\n', '\x36', '\f', '\x36', '\xE', '\x36', '\x5A2', '\v', 
		'\x36', '\x5', '\x36', '\x5A4', '\n', '\x36', '\x3', '\x36', '\x5', '\x36', 
		'\x5A7', '\n', '\x36', '\x3', '\x37', '\x3', '\x37', '\x3', '\x37', '\x3', 
		'\x37', '\x3', '\x37', '\x3', '\x37', '\x3', '\x38', '\x5', '\x38', '\x5B0', 
		'\n', '\x38', '\x3', '\x38', '\x3', '\x38', '\x3', '\x38', '\x5', '\x38', 
		'\x5B5', '\n', '\x38', '\x3', '\x38', '\x3', '\x38', '\x3', '\x39', '\x3', 
		'\x39', '\x3', ':', '\x3', ':', '\x3', ':', '\x3', ':', '\x3', ';', '\x3', 
		';', '\x3', ';', '\x3', ';', '\x3', '<', '\x3', '<', '\x3', '<', '\a', 
		'<', '\x5C6', '\n', '<', '\f', '<', '\xE', '<', '\x5C9', '\v', '<', '\x3', 
		'=', '\x5', '=', '\x5CC', '\n', '=', '\x3', '=', '\x3', '=', '\x3', '=', 
		'\x3', '=', '\x3', '=', '\a', '=', '\x5D3', '\n', '=', '\f', '=', '\xE', 
		'=', '\x5D6', '\v', '=', '\x3', '=', '\x3', '=', '\x5', '=', '\x5DA', 
		'\n', '=', '\x3', '>', '\x3', '>', '\x5', '>', '\x5DE', '\n', '>', '\x3', 
		'>', '\x5', '>', '\x5E1', '\n', '>', '\x3', '>', '\x3', '>', '\x3', '>', 
		'\a', '>', '\x5E6', '\n', '>', '\f', '>', '\xE', '>', '\x5E9', '\v', '>', 
		'\x3', '?', '\x3', '?', '\x3', '@', '\x3', '@', '\x5', '@', '\x5EF', '\n', 
		'@', '\x3', '@', '\x3', '@', '\x3', '@', '\a', '@', '\x5F4', '\n', '@', 
		'\f', '@', '\xE', '@', '\x5F7', '\v', '@', '\x3', '\x41', '\x3', '\x41', 
		'\x3', '\x41', '\x3', '\x41', '\x3', '\x41', '\a', '\x41', '\x5FE', '\n', 
		'\x41', '\f', '\x41', '\xE', '\x41', '\x601', '\v', '\x41', '\x3', '\x41', 
		'\x3', '\x41', '\x5', '\x41', '\x605', '\n', '\x41', '\x3', '\x41', '\x3', 
		'\x41', '\x5', '\x41', '\x609', '\n', '\x41', '\x3', '\x41', '\x5', '\x41', 
		'\x60C', '\n', '\x41', '\x3', '\x41', '\x3', '\x41', '\x3', '\x41', '\x3', 
		'\x41', '\x3', '\x41', '\x5', '\x41', '\x613', '\n', '\x41', '\x3', '\x41', 
		'\x3', '\x41', '\x3', '\x42', '\x5', '\x42', '\x618', '\n', '\x42', '\x3', 
		'\x42', '\x3', '\x42', '\x3', '\x42', '\x5', '\x42', '\x61D', '\n', '\x42', 
		'\x3', '\x42', '\x3', '\x42', '\x5', '\x42', '\x621', '\n', '\x42', '\x3', 
		'\x42', '\x5', '\x42', '\x624', '\n', '\x42', '\x3', '\x42', '\x5', '\x42', 
		'\x627', '\n', '\x42', '\x3', '\x42', '\x3', '\x42', '\x3', '\x42', '\x3', 
		'\x42', '\a', '\x42', '\x62D', '\n', '\x42', '\f', '\x42', '\xE', '\x42', 
		'\x630', '\v', '\x42', '\x5', '\x42', '\x632', '\n', '\x42', '\x3', '\x42', 
		'\x3', '\x42', '\x3', '\x42', '\x3', '\x42', '\x3', '\x42', '\x5', '\x42', 
		'\x639', '\n', '\x42', '\x5', '\x42', '\x63B', '\n', '\x42', '\x3', '\x42', 
		'\x3', '\x42', '\x5', '\x42', '\x63F', '\n', '\x42', '\x3', '\x43', '\x5', 
		'\x43', '\x642', '\n', '\x43', '\x3', '\x43', '\x3', '\x43', '\x5', '\x43', 
		'\x646', '\n', '\x43', '\x3', '\x43', '\x3', '\x43', '\x5', '\x43', '\x64A', 
		'\n', '\x43', '\x3', '\x43', '\x5', '\x43', '\x64D', '\n', '\x43', '\x3', 
		'\x43', '\x5', '\x43', '\x650', '\n', '\x43', '\x3', '\x43', '\x3', '\x43', 
		'\x3', '\x43', '\x3', '\x43', '\a', '\x43', '\x656', '\n', '\x43', '\f', 
		'\x43', '\xE', '\x43', '\x659', '\v', '\x43', '\x3', '\x43', '\x3', '\x43', 
		'\x3', '\x43', '\x3', '\x43', '\a', '\x43', '\x65F', '\n', '\x43', '\f', 
		'\x43', '\xE', '\x43', '\x662', '\v', '\x43', '\x5', '\x43', '\x664', 
		'\n', '\x43', '\x3', '\x43', '\x3', '\x43', '\x3', '\x43', '\x3', '\x43', 
		'\x3', '\x43', '\x5', '\x43', '\x66B', '\n', '\x43', '\x5', '\x43', '\x66D', 
		'\n', '\x43', '\x3', '\x43', '\x3', '\x43', '\x5', '\x43', '\x671', '\n', 
		'\x43', '\x3', '\x44', '\x3', '\x44', '\x3', '\x44', '\x3', '\x44', '\x5', 
		'\x44', '\x677', '\n', '\x44', '\x3', '\x44', '\x3', '\x44', '\x3', '\x44', 
		'\x3', '\x44', '\a', '\x44', '\x67D', '\n', '\x44', '\f', '\x44', '\xE', 
		'\x44', '\x680', '\v', '\x44', '\x3', '\x44', '\x3', '\x44', '\x3', '\x44', 
		'\x5', '\x44', '\x685', '\n', '\x44', '\x3', '\x44', '\x3', '\x44', '\x3', 
		'\x44', '\x5', '\x44', '\x68A', '\n', '\x44', '\x3', '\x44', '\x3', '\x44', 
		'\x3', '\x44', '\x5', '\x44', '\x68F', '\n', '\x44', '\a', '\x44', '\x691', 
		'\n', '\x44', '\f', '\x44', '\xE', '\x44', '\x694', '\v', '\x44', '\x3', 
		'\x44', '\x3', '\x44', '\x5', '\x44', '\x698', '\n', '\x44', '\x5', '\x44', 
		'\x69A', '\n', '\x44', '\x3', '\x45', '\x3', '\x45', '\x5', '\x45', '\x69E', 
		'\n', '\x45', '\x3', '\x46', '\x6', '\x46', '\x6A1', '\n', '\x46', '\r', 
		'\x46', '\xE', '\x46', '\x6A2', '\x3', '\x46', '\a', '\x46', '\x6A6', 
		'\n', '\x46', '\f', '\x46', '\xE', '\x46', '\x6A9', '\v', '\x46', '\x3', 
		'\x46', '\x3', '\x46', '\x5', '\x46', '\x6AD', '\n', '\x46', '\x3', 'G', 
		'\x3', 'G', '\x3', 'G', '\x3', 'G', '\x3', 'G', '\x3', 'G', '\x3', 'G', 
		'\x3', 'G', '\x5', 'G', '\x6B7', '\n', 'G', '\x3', 'G', '\x3', 'G', '\x5', 
		'G', '\x6BB', '\n', 'G', '\x3', 'G', '\x5', 'G', '\x6BE', '\n', 'G', '\x3', 
		'H', '\x5', 'H', '\x6C1', '\n', 'H', '\x3', 'H', '\x3', 'H', '\x3', 'H', 
		'\x3', 'H', '\x3', 'H', '\x5', 'H', '\x6C8', '\n', 'H', '\x3', 'H', '\x3', 
		'H', '\x3', 'H', '\x5', 'H', '\x6CD', '\n', 'H', '\x3', 'H', '\x5', 'H', 
		'\x6D0', '\n', 'H', '\x3', 'H', '\x3', 'H', '\x3', 'H', '\x5', 'H', '\x6D5', 
		'\n', 'H', '\x3', 'H', '\x3', 'H', '\x3', 'H', '\x5', 'H', '\x6DA', '\n', 
		'H', '\x3', 'H', '\x5', 'H', '\x6DD', '\n', 'H', '\x3', 'H', '\x3', 'H', 
		'\x5', 'H', '\x6E1', '\n', 'H', '\x3', 'I', '\x3', 'I', '\x3', 'I', '\x3', 
		'I', '\x3', 'I', '\x3', 'I', '\x3', 'I', '\x3', 'I', '\a', 'I', '\x6EB', 
		'\n', 'I', '\f', 'I', '\xE', 'I', '\x6EE', '\v', 'I', '\x3', 'I', '\x3', 
		'I', '\x5', 'I', '\x6F2', '\n', 'I', '\x5', 'I', '\x6F4', '\n', 'I', '\x3', 
		'J', '\x3', 'J', '\x5', 'J', '\x6F8', '\n', 'J', '\x3', 'J', '\x3', 'J', 
		'\x3', 'J', '\x5', 'J', '\x6FD', '\n', 'J', '\x3', 'K', '\x3', 'K', '\x3', 
		'K', '\x3', 'L', '\x3', 'L', '\x3', 'L', '\x3', 'L', '\x3', 'M', '\x3', 
		'M', '\x3', 'M', '\x3', 'M', '\a', 'M', '\x70A', '\n', 'M', '\f', 'M', 
		'\xE', 'M', '\x70D', '\v', 'M', '\x3', 'M', '\x3', 'M', '\x3', 'N', '\x3', 
		'N', '\x3', 'N', '\x3', 'N', '\x5', 'N', '\x715', '\n', 'N', '\x3', 'N', 
		'\x3', 'N', '\x3', 'N', '\x5', 'N', '\x71A', '\n', 'N', '\x3', 'N', '\x3', 
		'N', '\x3', 'N', '\x5', 'N', '\x71F', '\n', 'N', '\x3', 'N', '\x3', 'N', 
		'\x5', 'N', '\x723', '\n', 'N', '\x3', 'N', '\x3', 'N', '\x3', 'N', '\x3', 
		'N', '\x3', 'N', '\x3', 'N', '\x3', 'N', '\x3', 'N', '\x5', 'N', '\x72D', 
		'\n', 'N', '\x3', 'N', '\x3', 'N', '\x3', 'N', '\x3', 'N', '\a', 'N', 
		'\x733', '\n', 'N', '\f', 'N', '\xE', 'N', '\x736', '\v', 'N', '\x5', 
		'N', '\x738', '\n', 'N', '\x3', 'N', '\x3', 'N', '\x3', 'N', '\x5', 'N', 
		'\x73D', '\n', 'N', '\x5', 'N', '\x73F', '\n', 'N', '\x3', 'O', '\x3', 
		'O', '\x3', 'O', '\x3', 'O', '\x3', 'O', '\x3', 'O', '\a', 'O', '\x747', 
		'\n', 'O', '\f', 'O', '\xE', 'O', '\x74A', '\v', 'O', '\x3', 'P', '\x3', 
		'P', '\x3', 'P', '\x3', 'Q', '\x3', 'Q', '\x3', 'Q', '\x3', 'Q', '\x3', 
		'Q', '\x3', 'Q', '\x3', 'Q', '\x3', 'Q', '\x3', 'Q', '\x5', 'Q', '\x758', 
		'\n', 'Q', '\x3', 'R', '\x3', 'R', '\x3', 'R', '\x3', 'R', '\x3', 'R', 
		'\x3', 'R', '\x6', 'R', '\x760', '\n', 'R', '\r', 'R', '\xE', 'R', '\x761', 
		'\x3', 'S', '\x3', 'S', '\x5', 'S', '\x766', '\n', 'S', '\a', 'S', '\x768', 
		'\n', 'S', '\f', 'S', '\xE', 'S', '\x76B', '\v', 'S', '\x3', 'T', '\x3', 
		'T', '\x3', 'T', '\x3', 'T', '\x3', 'T', '\x3', 'T', '\x3', 'T', '\x3', 
		'T', '\x5', 'T', '\x775', '\n', 'T', '\x3', 'U', '\x3', 'U', '\x3', 'U', 
		'\x3', 'U', '\x5', 'U', '\x77B', '\n', 'U', '\x3', 'U', '\x3', 'U', '\x3', 
		'U', '\x3', 'U', '\x5', 'U', '\x781', '\n', 'U', '\x3', 'U', '\x3', 'U', 
		'\x3', 'U', '\x3', 'U', '\a', 'U', '\x787', '\n', 'U', '\f', 'U', '\xE', 
		'U', '\x78A', '\v', 'U', '\x3', 'U', '\x5', 'U', '\x78D', '\n', 'U', '\x3', 
		'V', '\x3', 'V', '\x3', 'V', '\x3', 'V', '\x3', 'W', '\x3', 'W', '\x5', 
		'W', '\x795', '\n', 'W', '\x3', 'W', '\x3', 'W', '\x3', 'W', '\x3', 'W', 
		'\a', 'W', '\x79B', '\n', 'W', '\f', 'W', '\xE', 'W', '\x79E', '\v', 'W', 
		'\x3', 'X', '\x3', 'X', '\x3', 'X', '\x3', 'X', '\x3', 'X', '\x3', 'X', 
		'\a', 'X', '\x7A6', '\n', 'X', '\f', 'X', '\xE', 'X', '\x7A9', '\v', 'X', 
		'\x3', 'X', '\x3', 'X', '\x5', 'X', '\x7AD', '\n', 'X', '\x5', 'X', '\x7AF', 
		'\n', 'X', '\x3', 'X', '\x3', 'X', '\x3', 'X', '\x3', 'X', '\x3', 'X', 
		'\a', 'X', '\x7B6', '\n', 'X', '\f', 'X', '\xE', 'X', '\x7B9', '\v', 'X', 
		'\x5', 'X', '\x7BB', '\n', 'X', '\x3', 'X', '\x3', 'X', '\x5', 'X', '\x7BF', 
		'\n', 'X', '\x3', 'X', '\x5', 'X', '\x7C2', '\n', 'X', '\x3', 'X', '\x3', 
		'X', '\x5', 'X', '\x7C6', '\n', 'X', '\x3', 'X', '\x3', 'X', '\x3', 'X', 
		'\x3', 'X', '\x3', 'X', '\x3', 'X', '\x3', 'X', '\x3', 'X', '\x3', 'X', 
		'\a', 'X', '\x7D1', '\n', 'X', '\f', 'X', '\xE', 'X', '\x7D4', '\v', 'X', 
		'\x5', 'X', '\x7D6', '\n', 'X', '\x3', 'X', '\x3', 'X', '\x5', 'X', '\x7DA', 
		'\n', 'X', '\x3', 'X', '\x5', 'X', '\x7DD', '\n', 'X', '\x3', 'X', '\a', 
		'X', '\x7E0', '\n', 'X', '\f', 'X', '\xE', 'X', '\x7E3', '\v', 'X', '\x3', 
		'Y', '\x3', 'Y', '\x3', 'Y', '\x3', 'Y', '\x3', 'Y', '\x3', 'Y', '\x5', 
		'Y', '\x7EB', '\n', 'Y', '\x3', 'Z', '\x3', 'Z', '\x3', 'Z', '\x3', 'Z', 
		'\x3', 'Z', '\x3', 'Z', '\x5', 'Z', '\x7F3', '\n', 'Z', '\x3', 'Z', '\x3', 
		'Z', '\x3', 'Z', '\x3', 'Z', '\x3', 'Z', '\x5', 'Z', '\x7FA', '\n', 'Z', 
		'\x5', 'Z', '\x7FC', '\n', 'Z', '\x3', '[', '\x3', '[', '\x5', '[', '\x800', 
		'\n', '[', '\x3', '[', '\x5', '[', '\x803', '\n', '[', '\x3', '[', '\x3', 
		'[', '\x3', '[', '\x3', '[', '\a', '[', '\x809', '\n', '[', '\f', '[', 
		'\xE', '[', '\x80C', '\v', '[', '\x3', '[', '\x3', '[', '\x5', '[', '\x810', 
		'\n', '[', '\x3', '[', '\x3', '[', '\x3', '\\', '\x3', '\\', '\x3', '\\', 
		'\x3', '\\', '\x3', '\\', '\x3', '\\', '\x3', '\\', '\x5', '\\', '\x81B', 
		'\n', '\\', '\x5', '\\', '\x81D', '\n', '\\', '\x3', ']', '\x5', ']', 
		'\x820', '\n', ']', '\x3', ']', '\x3', ']', '\x5', ']', '\x824', '\n', 
		']', '\x3', ']', '\x3', ']', '\x5', ']', '\x828', '\n', ']', '\x3', ']', 
		'\x3', ']', '\x5', ']', '\x82C', '\n', ']', '\x3', ']', '\x3', ']', '\x5', 
		']', '\x830', '\n', ']', '\x3', ']', '\x5', ']', '\x833', '\n', ']', '\x3', 
		']', '\x5', ']', '\x836', '\n', ']', '\x3', ']', '\x5', ']', '\x839', 
		'\n', ']', '\x3', ']', '\x3', ']', '\x3', ']', '\x3', ']', '\x5', ']', 
		'\x83F', '\n', ']', '\x3', ']', '\x3', ']', '\x5', ']', '\x843', '\n', 
		']', '\x3', ']', '\x5', ']', '\x846', '\n', ']', '\x3', '^', '\x3', '^', 
		'\x3', '^', '\x3', '^', '\x3', '^', '\x5', '^', '\x84D', '\n', '^', '\x3', 
		'_', '\x3', '_', '\x3', '_', '\x3', '`', '\x3', '`', '\x3', '`', '\x3', 
		'`', '\a', '`', '\x856', '\n', '`', '\f', '`', '\xE', '`', '\x859', '\v', 
		'`', '\x3', '`', '\x3', '`', '\x3', '\x61', '\x3', '\x61', '\x3', '\x61', 
		'\x5', '\x61', '\x860', '\n', '\x61', '\x3', '\x62', '\x3', '\x62', '\x3', 
		'\x62', '\x3', '\x62', '\x3', '\x62', '\x3', '\x62', '\x3', '\x62', '\x5', 
		'\x62', '\x869', '\n', '\x62', '\x3', '\x63', '\x3', '\x63', '\x3', '\x63', 
		'\x3', '\x64', '\x3', '\x64', '\x3', '\x64', '\x3', '\x64', '\x3', '\x65', 
		'\x3', '\x65', '\x5', '\x65', '\x874', '\n', '\x65', '\x3', '\x65', '\x5', 
		'\x65', '\x877', '\n', '\x65', '\x3', '\x65', '\x5', '\x65', '\x87A', 
		'\n', '\x65', '\x3', '\x65', '\x5', '\x65', '\x87D', '\n', '\x65', '\x3', 
		'\x65', '\x3', '\x65', '\x5', '\x65', '\x881', '\n', '\x65', '\x3', '\x65', 
		'\x3', '\x65', '\x5', '\x65', '\x885', '\n', '\x65', '\x3', '\x65', '\x3', 
		'\x65', '\x5', '\x65', '\x889', '\n', '\x65', '\x3', '\x65', '\x3', '\x65', 
		'\x5', '\x65', '\x88D', '\n', '\x65', '\x3', '\x65', '\x5', '\x65', '\x890', 
		'\n', '\x65', '\x3', '\x65', '\x3', '\x65', '\x3', '\x65', '\x5', '\x65', 
		'\x895', '\n', '\x65', '\x3', '\x65', '\x3', '\x65', '\x5', '\x65', '\x899', 
		'\n', '\x65', '\x3', '\x65', '\x5', '\x65', '\x89C', '\n', '\x65', '\x3', 
		'\x66', '\x3', '\x66', '\x3', '\x66', '\x3', '\x66', '\a', '\x66', '\x8A2', 
		'\n', '\x66', '\f', '\x66', '\xE', '\x66', '\x8A5', '\v', '\x66', '\x3', 
		'\x66', '\x3', '\x66', '\x3', 'g', '\x3', 'g', '\x5', 'g', '\x8AB', '\n', 
		'g', '\x3', 'g', '\x3', 'g', '\x3', 'g', '\x3', 'h', '\x3', 'h', '\x3', 
		'h', '\x3', 'h', '\x3', 'h', '\x3', 'h', '\a', 'h', '\x8B6', '\n', 'h', 
		'\f', 'h', '\xE', 'h', '\x8B9', '\v', 'h', '\x3', 'h', '\x3', 'h', '\x5', 
		'h', '\x8BD', '\n', 'h', '\x3', 'i', '\x3', 'i', '\x3', 'i', '\x5', 'i', 
		'\x8C2', '\n', 'i', '\x3', 'i', '\x5', 'i', '\x8C5', '\n', 'i', '\x3', 
		'i', '\x5', 'i', '\x8C8', '\n', 'i', '\x3', 'i', '\x5', 'i', '\x8CB', 
		'\n', 'i', '\x3', 'i', '\x3', 'i', '\x3', 'i', '\x5', 'i', '\x8D0', '\n', 
		'i', '\x3', 'i', '\x3', 'i', '\x3', 'i', '\x3', 'j', '\x3', 'j', '\x5', 
		'j', '\x8D7', '\n', 'j', '\x3', 'j', '\x3', 'j', '\x5', 'j', '\x8DB', 
		'\n', 'j', '\x3', 'k', '\x3', 'k', '\x3', 'l', '\x3', 'l', '\x3', 'l', 
		'\x3', 'l', '\x5', 'l', '\x8E3', '\n', 'l', '\x3', 'l', '\x3', 'l', '\x3', 
		'l', '\x3', 'l', '\x3', 'l', '\x3', 'l', '\x3', 'l', '\x3', 'l', '\x3', 
		'l', '\x5', 'l', '\x8EE', '\n', 'l', '\x3', 'm', '\x3', 'm', '\x3', 'm', 
		'\x5', 'm', '\x8F3', '\n', 'm', '\x3', 'n', '\x3', 'n', '\x3', 'n', '\x3', 
		'n', '\x3', 'n', '\x3', 'n', '\x3', 'n', '\x3', 'n', '\x3', 'n', '\a', 
		'n', '\x8FE', '\n', 'n', '\f', 'n', '\xE', 'n', '\x901', '\v', 'n', '\x3', 
		'n', '\x3', 'n', '\x5', 'n', '\x905', '\n', 'n', '\x3', 'n', '\x3', 'n', 
		'\x3', 'n', '\x3', 'o', '\x3', 'o', '\x5', 'o', '\x90C', '\n', 'o', '\x3', 
		'o', '\x3', 'o', '\x3', 'o', '\x3', 'o', '\a', 'o', '\x912', '\n', 'o', 
		'\f', 'o', '\xE', 'o', '\x915', '\v', 'o', '\x3', 'o', '\x3', 'o', '\x3', 
		'o', '\x6', 'o', '\x91A', '\n', 'o', '\r', 'o', '\xE', 'o', '\x91B', '\x3', 
		'o', '\x3', 'o', '\x5', 'o', '\x920', '\n', 'o', '\x3', 'o', '\x3', 'o', 
		'\x3', 'o', '\x3', 'p', '\x5', 'p', '\x926', '\n', 'p', '\x3', 'p', '\x5', 
		'p', '\x929', '\n', 'p', '\x3', 'p', '\x3', 'p', '\x3', 'p', '\x3', 'p', 
		'\x3', 'p', '\x5', 'p', '\x930', '\n', 'p', '\x3', 'p', '\x3', 'p', '\x5', 
		'p', '\x934', '\n', 'p', '\x3', 'p', '\x3', 'p', '\x5', 'p', '\x938', 
		'\n', 'p', '\x5', 'p', '\x93A', '\n', 'p', '\x3', 'q', '\x3', 'q', '\x3', 
		'q', '\x3', 'q', '\x3', 'q', '\x3', 'q', '\x5', 'q', '\x942', '\n', 'q', 
		'\x3', 'q', '\x3', 'q', '\x3', 'q', '\x3', 'q', '\x3', 'q', '\x5', 'q', 
		'\x949', '\n', 'q', '\x3', 'q', '\x3', 'q', '\x3', 'q', '\x3', 'q', '\x3', 
		'q', '\x5', 'q', '\x950', '\n', 'q', '\x3', 'q', '\x3', 'q', '\x3', 'q', 
		'\x3', 'q', '\x3', 'q', '\x3', 'q', '\x3', 'q', '\x3', 'q', '\a', 'q', 
		'\x95A', '\n', 'q', '\f', 'q', '\xE', 'q', '\x95D', '\v', 'q', '\x3', 
		'q', '\x3', 'q', '\x5', 'q', '\x961', '\n', 'q', '\x3', 'q', '\x3', 'q', 
		'\x3', 'q', '\x3', 'q', '\x5', 'q', '\x967', '\n', 'q', '\x3', 'q', '\x3', 
		'q', '\x3', 'q', '\x3', 'q', '\x5', 'q', '\x96D', '\n', 'q', '\x3', 'r', 
		'\x3', 'r', '\x3', 'r', '\x5', 'r', '\x972', '\n', 'r', '\x3', 'r', '\x3', 
		'r', '\x3', 's', '\x3', 's', '\x3', 's', '\a', 's', '\x979', '\n', 's', 
		'\f', 's', '\xE', 's', '\x97C', '\v', 's', '\x3', 't', '\x3', 't', '\x3', 
		't', '\x5', 't', '\x981', '\n', 't', '\x3', 't', '\x5', 't', '\x984', 
		'\n', 't', '\x3', 't', '\x5', 't', '\x987', '\n', 't', '\x3', 'u', '\x3', 
		'u', '\x5', 'u', '\x98B', '\n', 'u', '\x3', 'u', '\x3', 'u', '\x3', 'u', 
		'\a', 'u', '\x990', '\n', 'u', '\f', 'u', '\xE', 'u', '\x993', '\v', 'u', 
		'\x3', 'u', '\x3', 'u', '\x3', 'u', '\x3', 'u', '\x5', 'u', '\x999', '\n', 
		'u', '\x3', 'u', '\x5', 'u', '\x99C', '\n', 'u', '\x3', 'v', '\x3', 'v', 
		'\x3', 'v', '\x3', 'v', '\x3', 'v', '\x3', 'v', '\x3', 'v', '\x3', 'v', 
		'\x3', 'v', '\x5', 'v', '\x9A7', '\n', 'v', '\x3', 'v', '\x5', 'v', '\x9AA', 
		'\n', 'v', '\x3', 'w', '\x5', 'w', '\x9AD', '\n', 'w', '\x3', 'w', '\x3', 
		'w', '\x5', 'w', '\x9B1', '\n', 'w', '\x3', 'x', '\x3', 'x', '\x3', 'x', 
		'\x5', 'x', '\x9B6', '\n', 'x', '\x3', 'x', '\x5', 'x', '\x9B9', '\n', 
		'x', '\x3', 'x', '\x3', 'x', '\x3', 'x', '\x5', 'x', '\x9BE', '\n', 'x', 
		'\x3', 'x', '\x3', 'x', '\x3', 'x', '\x3', 'x', '\x3', 'x', '\x3', 'x', 
		'\a', 'x', '\x9C6', '\n', 'x', '\f', 'x', '\xE', 'x', '\x9C9', '\v', 'x', 
		'\x3', 'x', '\x3', 'x', '\x5', 'x', '\x9CD', '\n', 'x', '\x3', 'x', '\x3', 
		'x', '\x5', 'x', '\x9D1', '\n', 'x', '\x3', 'x', '\x5', 'x', '\x9D4', 
		'\n', 'x', '\x3', 'x', '\x3', 'x', '\x5', 'x', '\x9D8', '\n', 'x', '\x3', 
		'x', '\x3', 'x', '\x5', 'x', '\x9DC', '\n', 'x', '\x3', 'x', '\x5', 'x', 
		'\x9DF', '\n', 'x', '\x3', 'x', '\x3', 'x', '\x3', 'x', '\x5', 'x', '\x9E4', 
		'\n', 'x', '\x3', 'y', '\x3', 'y', '\x3', 'y', '\x3', 'y', '\x3', 'y', 
		'\x5', 'y', '\x9EB', '\n', 'y', '\x3', 'y', '\x3', 'y', '\x3', 'y', '\x3', 
		'y', '\x5', 'y', '\x9F1', '\n', 'y', '\x3', 'y', '\x3', 'y', '\x5', 'y', 
		'\x9F5', '\n', 'y', '\x5', 'y', '\x9F7', '\n', 'y', '\x3', 'z', '\x5', 
		'z', '\x9FA', '\n', 'z', '\x3', 'z', '\x3', 'z', '\x3', '{', '\x3', '{', 
		'\x3', '|', '\x3', '|', '\x5', '|', '\xA02', '\n', '|', '\x3', '|', '\x3', 
		'|', '\x3', '|', '\a', '|', '\xA07', '\n', '|', '\f', '|', '\xE', '|', 
		'\xA0A', '\v', '|', '\x5', '|', '\xA0C', '\n', '|', '\x3', '|', '\x5', 
		'|', '\xA0F', '\n', '|', '\x3', '|', '\x3', '|', '\x5', '|', '\xA13', 
		'\n', '|', '\x3', '|', '\x3', '|', '\x5', '|', '\xA17', '\n', '|', '\x3', 
		'|', '\x3', '|', '\x5', '|', '\xA1B', '\n', '|', '\x3', '|', '\x3', '|', 
		'\x3', '|', '\x5', '|', '\xA20', '\n', '|', '\x3', '|', '\x3', '|', '\x3', 
		'|', '\x3', '|', '\x5', '|', '\xA26', '\n', '|', '\x5', '|', '\xA28', 
		'\n', '|', '\x3', '}', '\x3', '}', '\x3', '}', '\x3', '}', '\x3', '}', 
		'\x3', '}', '\x3', '}', '\x3', '}', '\x3', '}', '\a', '}', '\xA33', '\n', 
		'}', '\f', '}', '\xE', '}', '\xA36', '\v', '}', '\x3', '~', '\x3', '~', 
		'\x3', '\x7F', '\x3', '\x7F', '\x3', '\x80', '\x3', '\x80', '\x3', '\x80', 
		'\x3', '\x80', '\x3', '\x80', '\x3', '\x80', '\x5', '\x80', '\xA42', '\n', 
		'\x80', '\x3', '\x81', '\x3', '\x81', '\x3', '\x81', '\x3', '\x81', '\x5', 
		'\x81', '\xA48', '\n', '\x81', '\x3', '\x82', '\x3', '\x82', '\x5', '\x82', 
		'\xA4C', '\n', '\x82', '\x3', '\x82', '\x3', '\x82', '\x3', '\x82', '\a', 
		'\x82', '\xA51', '\n', '\x82', '\f', '\x82', '\xE', '\x82', '\xA54', '\v', 
		'\x82', '\x3', '\x82', '\x3', '\x82', '\x5', '\x82', '\xA58', '\n', '\x82', 
		'\x3', '\x82', '\x5', '\x82', '\xA5B', '\n', '\x82', '\x3', '\x83', '\x3', 
		'\x83', '\x3', '\x84', '\x3', '\x84', '\x3', '\x84', '\x3', '\x84', '\x3', 
		'\x84', '\x3', '\x84', '\x5', '\x84', '\xA65', '\n', '\x84', '\x3', '\x84', 
		'\x3', '\x84', '\x3', '\x84', '\x3', '\x84', '\x3', '\x84', '\a', '\x84', 
		'\xA6C', '\n', '\x84', '\f', '\x84', '\xE', '\x84', '\xA6F', '\v', '\x84', 
		'\x3', '\x84', '\x3', '\x84', '\x3', '\x84', '\x5', '\x84', '\xA74', '\n', 
		'\x84', '\x3', '\x84', '\x5', '\x84', '\xA77', '\n', '\x84', '\x3', '\x84', 
		'\x3', '\x84', '\x5', '\x84', '\xA7B', '\n', '\x84', '\x3', '\x84', '\x3', 
		'\x84', '\x3', '\x84', '\x3', '\x84', '\x3', '\x84', '\x3', '\x84', '\x3', 
		'\x84', '\x5', '\x84', '\xA84', '\n', '\x84', '\x5', '\x84', '\xA86', 
		'\n', '\x84', '\x3', '\x84', '\x3', '\x84', '\x3', '\x84', '\x3', '\x84', 
		'\x3', '\x84', '\x5', '\x84', '\xA8D', '\n', '\x84', '\x3', '\x84', '\x3', 
		'\x84', '\x5', '\x84', '\xA91', '\n', '\x84', '\x3', '\x84', '\x3', '\x84', 
		'\x3', '\x84', '\x3', '\x84', '\x5', '\x84', '\xA97', '\n', '\x84', '\x3', 
		'\x84', '\x3', '\x84', '\x5', '\x84', '\xA9B', '\n', '\x84', '\x3', '\x84', 
		'\x3', '\x84', '\x3', '\x84', '\x3', '\x84', '\x3', '\x84', '\x5', '\x84', 
		'\xAA2', '\n', '\x84', '\x3', '\x84', '\x3', '\x84', '\x3', '\x84', '\x3', 
		'\x84', '\x3', '\x84', '\x3', '\x84', '\x5', '\x84', '\xAAA', '\n', '\x84', 
		'\x3', '\x84', '\x3', '\x84', '\x3', '\x84', '\x3', '\x84', '\x3', '\x84', 
		'\x5', '\x84', '\xAB1', '\n', '\x84', '\x3', '\x84', '\x3', '\x84', '\x3', 
		'\x84', '\x5', '\x84', '\xAB6', '\n', '\x84', '\x3', '\x84', '\x5', '\x84', 
		'\xAB9', '\n', '\x84', '\x3', '\x84', '\x3', '\x84', '\x3', '\x84', '\x3', 
		'\x84', '\x3', '\x84', '\x3', '\x84', '\a', '\x84', '\xAC1', '\n', '\x84', 
		'\f', '\x84', '\xE', '\x84', '\xAC4', '\v', '\x84', '\x3', '\x84', '\x3', 
		'\x84', '\x5', '\x84', '\xAC8', '\n', '\x84', '\x3', '\x84', '\x3', '\x84', 
		'\x3', '\x84', '\x3', '\x84', '\x3', '\x84', '\x3', '\x84', '\x3', '\x84', 
		'\x3', '\x84', '\x3', '\x84', '\a', '\x84', '\xAD3', '\n', '\x84', '\f', 
		'\x84', '\xE', '\x84', '\xAD6', '\v', '\x84', '\x3', '\x84', '\x3', '\x84', 
		'\x3', '\x84', '\x3', '\x84', '\x3', '\x84', '\x5', '\x84', '\xADD', '\n', 
		'\x84', '\x3', '\x85', '\x3', '\x85', '\x5', '\x85', '\xAE1', '\n', '\x85', 
		'\x3', '\x86', '\x3', '\x86', '\x3', '\x86', '\x3', '\x86', '\x5', '\x86', 
		'\xAE7', '\n', '\x86', '\x3', '\x86', '\x3', '\x86', '\x5', '\x86', '\xAEB', 
		'\n', '\x86', '\x3', '\x86', '\x5', '\x86', '\xAEE', '\n', '\x86', '\x3', 
		'\x86', '\x3', '\x86', '\x3', '\x86', '\x3', '\x86', '\x3', '\x86', '\x5', 
		'\x86', '\xAF5', '\n', '\x86', '\x5', '\x86', '\xAF7', '\n', '\x86', '\x3', 
		'\x86', '\x3', '\x86', '\x5', '\x86', '\xAFB', '\n', '\x86', '\x3', '\x87', 
		'\x3', '\x87', '\x3', '\x87', '\x3', '\x87', '\x3', '\x87', '\x3', '\x87', 
		'\x3', '\x87', '\x5', '\x87', '\xB04', '\n', '\x87', '\x3', '\x87', '\x3', 
		'\x87', '\x5', '\x87', '\xB08', '\n', '\x87', '\x3', '\x87', '\x3', '\x87', 
		'\x5', '\x87', '\xB0C', '\n', '\x87', '\x3', '\x87', '\x3', '\x87', '\x5', 
		'\x87', '\xB10', '\n', '\x87', '\x3', '\x87', '\x5', '\x87', '\xB13', 
		'\n', '\x87', '\x3', '\x87', '\x3', '\x87', '\x3', '\x87', '\x3', '\x87', 
		'\x3', '\x87', '\x5', '\x87', '\xB1A', '\n', '\x87', '\x5', '\x87', '\xB1C', 
		'\n', '\x87', '\x3', '\x88', '\x3', '\x88', '\x3', '\x88', '\x5', '\x88', 
		'\xB21', '\n', '\x88', '\x3', '\x89', '\x3', '\x89', '\x5', '\x89', '\xB25', 
		'\n', '\x89', '\x3', '\x89', '\a', '\x89', '\xB28', '\n', '\x89', '\f', 
		'\x89', '\xE', '\x89', '\xB2B', '\v', '\x89', '\x3', '\x8A', '\x5', '\x8A', 
		'\xB2E', '\n', '\x8A', '\x3', '\x8A', '\x3', '\x8A', '\x3', '\x8A', '\x5', 
		'\x8A', '\xB33', '\n', '\x8A', '\x3', '\x8A', '\x3', '\x8A', '\x5', '\x8A', 
		'\xB37', '\n', '\x8A', '\x3', '\x8A', '\x3', '\x8A', '\x5', '\x8A', '\xB3B', 
		'\n', '\x8A', '\x3', '\x8A', '\x3', '\x8A', '\x3', '\x8A', '\x5', '\x8A', 
		'\xB40', '\n', '\x8A', '\x3', '\x8A', '\x3', '\x8A', '\x3', '\x8A', '\x5', 
		'\x8A', '\xB45', '\n', '\x8A', '\x3', '\x8A', '\x3', '\x8A', '\x3', '\x8A', 
		'\x3', '\x8A', '\x3', '\x8A', '\x3', '\x8A', '\x3', '\x8A', '\x3', '\x8A', 
		'\x5', '\x8A', '\xB4F', '\n', '\x8A', '\x3', '\x8A', '\x3', '\x8A', '\x3', 
		'\x8A', '\x3', '\x8A', '\x3', '\x8A', '\x3', '\x8A', '\x5', '\x8A', '\xB57', 
		'\n', '\x8A', '\x3', '\x8A', '\x3', '\x8A', '\x3', '\x8A', '\x3', '\x8A', 
		'\x3', '\x8A', '\x3', '\x8A', '\x3', '\x8A', '\x3', '\x8A', '\x3', '\x8A', 
		'\x3', '\x8A', '\x3', '\x8A', '\x3', '\x8A', '\x3', '\x8A', '\x3', '\x8A', 
		'\x3', '\x8A', '\x3', '\x8A', '\x5', '\x8A', '\xB69', '\n', '\x8A', '\x3', 
		'\x8B', '\x3', '\x8B', '\x3', '\x8C', '\x3', '\x8C', '\x3', '\x8C', '\a', 
		'\x8C', '\xB70', '\n', '\x8C', '\f', '\x8C', '\xE', '\x8C', '\xB73', '\v', 
		'\x8C', '\x3', '\x8D', '\x3', '\x8D', '\x3', '\x8D', '\x3', '\x8D', '\x3', 
		'\x8D', '\a', '\x8D', '\xB7A', '\n', '\x8D', '\f', '\x8D', '\xE', '\x8D', 
		'\xB7D', '\v', '\x8D', '\x3', '\x8D', '\x3', '\x8D', '\x5', '\x8D', '\xB81', 
		'\n', '\x8D', '\x3', '\x8E', '\x3', '\x8E', '\x3', '\x8E', '\x3', '\x8E', 
		'\x5', '\x8E', '\xB87', '\n', '\x8E', '\x5', '\x8E', '\xB89', '\n', '\x8E', 
		'\x3', '\x8E', '\x3', '\x8E', '\x3', '\x8E', '\x3', '\x8E', '\x3', '\x8E', 
		'\x3', '\x8E', '\x5', '\x8E', '\xB91', '\n', '\x8E', '\x5', '\x8E', '\xB93', 
		'\n', '\x8E', '\x3', '\x8F', '\x3', '\x8F', '\x5', '\x8F', '\xB97', '\n', 
		'\x8F', '\x3', '\x90', '\x3', '\x90', '\x3', '\x90', '\x3', '\x90', '\a', 
		'\x90', '\xB9D', '\n', '\x90', '\f', '\x90', '\xE', '\x90', '\xBA0', '\v', 
		'\x90', '\x3', '\x91', '\x3', '\x91', '\x3', '\x91', '\x3', '\x91', '\x5', 
		'\x91', '\xBA6', '\n', '\x91', '\x3', '\x92', '\x5', '\x92', '\xBA9', 
		'\n', '\x92', '\x3', '\x92', '\x3', '\x92', '\a', '\x92', '\xBAD', '\n', 
		'\x92', '\f', '\x92', '\xE', '\x92', '\xBB0', '\v', '\x92', '\x3', '\x93', 
		'\x3', '\x93', '\x3', '\x93', '\x5', '\x93', '\xBB5', '\n', '\x93', '\x3', 
		'\x93', '\x3', '\x93', '\x3', '\x93', '\x3', '\x93', '\x3', '\x93', '\x5', 
		'\x93', '\xBBC', '\n', '\x93', '\x3', '\x93', '\x5', '\x93', '\xBBF', 
		'\n', '\x93', '\x3', '\x94', '\x3', '\x94', '\x3', '\x94', '\x3', '\x94', 
		'\x3', '\x94', '\x5', '\x94', '\xBC6', '\n', '\x94', '\x3', '\x94', '\x3', 
		'\x94', '\x3', '\x94', '\x3', '\x94', '\x6', '\x94', '\xBCC', '\n', '\x94', 
		'\r', '\x94', '\xE', '\x94', '\xBCD', '\x3', '\x94', '\x3', '\x94', '\x3', 
		'\x94', '\x3', '\x94', '\x3', '\x94', '\x3', '\x94', '\x3', '\x94', '\x3', 
		'\x94', '\x5', '\x94', '\xBD8', '\n', '\x94', '\x3', '\x94', '\x3', '\x94', 
		'\x3', '\x94', '\x3', '\x94', '\x3', '\x94', '\x3', '\x94', '\x3', '\x94', 
		'\x3', '\x94', '\x3', '\x94', '\x3', '\x94', '\x3', '\x94', '\x3', '\x94', 
		'\x3', '\x94', '\x3', '\x94', '\x3', '\x94', '\x3', '\x94', '\x3', '\x94', 
		'\x3', '\x94', '\x3', '\x94', '\x5', '\x94', '\xBED', '\n', '\x94', '\x3', 
		'\x94', '\x3', '\x94', '\x3', '\x94', '\x3', '\x94', '\x3', '\x94', '\x3', 
		'\x94', '\x3', '\x94', '\x3', '\x94', '\x3', '\x94', '\x3', '\x94', '\x3', 
		'\x94', '\x5', '\x94', '\xBFA', '\n', '\x94', '\x3', '\x94', '\x3', '\x94', 
		'\x3', '\x94', '\x3', '\x94', '\x5', '\x94', '\xC00', '\n', '\x94', '\x3', 
		'\x94', '\x3', '\x94', '\x3', '\x94', '\x3', '\x94', '\x5', '\x94', '\xC06', 
		'\n', '\x94', '\x3', '\x94', '\x3', '\x94', '\x3', '\x94', '\x3', '\x94', 
		'\x3', '\x94', '\a', '\x94', '\xC0D', '\n', '\x94', '\f', '\x94', '\xE', 
		'\x94', '\xC10', '\v', '\x94', '\x3', '\x95', '\x3', '\x95', '\x3', '\x95', 
		'\x3', '\x95', '\x3', '\x95', '\x3', '\x95', '\x3', '\x95', '\x3', '\x95', 
		'\x5', '\x95', '\xC1A', '\n', '\x95', '\x3', '\x96', '\x3', '\x96', '\x3', 
		'\x96', '\x3', '\x96', '\x3', '\x96', '\x5', '\x96', '\xC21', '\n', '\x96', 
		'\x3', '\x96', '\x3', '\x96', '\x3', '\x96', '\x3', '\x96', '\x3', '\x96', 
		'\x3', '\x96', '\x3', '\x96', '\x3', '\x96', '\x3', '\x96', '\x3', '\x96', 
		'\x3', '\x96', '\x5', '\x96', '\xC2E', '\n', '\x96', '\x3', '\x97', '\x3', 
		'\x97', '\x3', '\x97', '\x3', '\x97', '\x3', '\x97', '\x3', '\x97', '\x3', 
		'\x97', '\x3', '\x97', '\x3', '\x97', '\x3', '\x97', '\x3', '\x97', '\x3', 
		'\x97', '\x3', '\x98', '\x3', '\x98', '\x3', '\x98', '\x3', '\x98', '\x3', 
		'\x98', '\x3', '\x98', '\x3', '\x98', '\x5', '\x98', '\xC43', '\n', '\x98', 
		'\x5', '\x98', '\xC45', '\n', '\x98', '\x3', '\x99', '\x3', '\x99', '\x3', 
		'\x99', '\x5', '\x99', '\xC4A', '\n', '\x99', '\x3', '\x9A', '\x3', '\x9A', 
		'\x3', '\x9A', '\x5', '\x9A', '\xC4F', '\n', '\x9A', '\x3', '\x9A', '\x3', 
		'\x9A', '\x3', '\x9A', '\x5', '\x9A', '\xC54', '\n', '\x9A', '\a', '\x9A', 
		'\xC56', '\n', '\x9A', '\f', '\x9A', '\xE', '\x9A', '\xC59', '\v', '\x9A', 
		'\x5', '\x9A', '\xC5B', '\n', '\x9A', '\x3', '\x9A', '\x3', '\x9A', '\x3', 
		'\x9B', '\x3', '\x9B', '\x5', '\x9B', '\xC61', '\n', '\x9B', '\x3', '\x9B', 
		'\x5', '\x9B', '\xC64', '\n', '\x9B', '\x3', '\x9C', '\x3', '\x9C', '\x3', 
		'\x9D', '\x3', '\x9D', '\x3', '\x9D', '\x3', '\x9D', '\x5', '\x9D', '\xC6C', 
		'\n', '\x9D', '\x3', '\x9D', '\x3', '\x9D', '\x3', '\x9E', '\x3', '\x9E', 
		'\x5', '\x9E', '\xC72', '\n', '\x9E', '\x3', '\x9E', '\x3', '\x9E', '\x3', 
		'\x9E', '\x3', '\x9E', '\x3', '\x9E', '\x6', '\x9E', '\xC79', '\n', '\x9E', 
		'\r', '\x9E', '\xE', '\x9E', '\xC7A', '\x3', '\x9E', '\x3', '\x9E', '\x5', 
		'\x9E', '\xC7F', '\n', '\x9E', '\x3', '\x9E', '\x3', '\x9E', '\x3', '\x9F', 
		'\x3', '\x9F', '\x3', '\x9F', '\x5', '\x9F', '\xC86', '\n', '\x9F', '\x3', 
		'\xA0', '\x3', '\xA0', '\x3', '\xA1', '\x3', '\xA1', '\x3', '\xA1', '\a', 
		'\xA1', '\xC8D', '\n', '\xA1', '\f', '\xA1', '\xE', '\xA1', '\xC90', '\v', 
		'\xA1', '\x3', '\xA2', '\x3', '\xA2', '\x3', '\xA2', '\x3', '\xA2', '\x3', 
		'\xA2', '\x5', '\xA2', '\xC97', '\n', '\xA2', '\x3', '\xA2', '\x3', '\xA2', 
		'\x3', '\xA2', '\x3', '\xA2', '\x6', '\xA2', '\xC9D', '\n', '\xA2', '\r', 
		'\xA2', '\xE', '\xA2', '\xC9E', '\x3', '\xA2', '\x3', '\xA2', '\x3', '\xA2', 
		'\x3', '\xA2', '\x3', '\xA2', '\x3', '\xA2', '\x3', '\xA2', '\x3', '\xA2', 
		'\x3', '\xA2', '\x3', '\xA2', '\x5', '\xA2', '\xCAB', '\n', '\xA2', '\x3', 
		'\xA2', '\x3', '\xA2', '\x3', '\xA2', '\x3', '\xA2', '\x3', '\xA2', '\x3', 
		'\xA2', '\x3', '\xA2', '\x3', '\xA2', '\x3', '\xA2', '\x3', '\xA2', '\x3', 
		'\xA2', '\x3', '\xA2', '\x3', '\xA2', '\x3', '\xA2', '\x3', '\xA2', '\x3', 
		'\xA2', '\x3', '\xA2', '\x3', '\xA2', '\x3', '\xA2', '\x3', '\xA2', '\x5', 
		'\xA2', '\xCC1', '\n', '\xA2', '\x3', '\xA2', '\x3', '\xA2', '\x5', '\xA2', 
		'\xCC5', '\n', '\xA2', '\x3', '\xA2', '\x3', '\xA2', '\x3', '\xA2', '\x3', 
		'\xA2', '\x3', '\xA2', '\x3', '\xA2', '\x5', '\xA2', '\xCCD', '\n', '\xA2', 
		'\x3', '\xA2', '\x3', '\xA2', '\x3', '\xA2', '\x3', '\xA2', '\x5', '\xA2', 
		'\xCD3', '\n', '\xA2', '\x3', '\xA2', '\x3', '\xA2', '\x3', '\xA2', '\x5', 
		'\xA2', '\xCD8', '\n', '\xA2', '\x3', '\xA2', '\x3', '\xA2', '\x3', '\xA2', 
		'\x3', '\xA2', '\x5', '\xA2', '\xCDE', '\n', '\xA2', '\x3', '\xA2', '\x3', 
		'\xA2', '\x3', '\xA2', '\x3', '\xA2', '\x3', '\xA2', '\x3', '\xA2', '\x3', 
		'\xA2', '\x3', '\xA2', '\x3', '\xA2', '\x3', '\xA2', '\x5', '\xA2', '\xCEA', 
		'\n', '\xA2', '\x3', '\xA2', '\x3', '\xA2', '\x3', '\xA2', '\x3', '\xA2', 
		'\x3', '\xA2', '\x3', '\xA2', '\x3', '\xA2', '\x3', '\xA2', '\x3', '\xA2', 
		'\x3', '\xA2', '\x3', '\xA2', '\x3', '\xA2', '\x3', '\xA2', '\x3', '\xA2', 
		'\x3', '\xA2', '\x3', '\xA2', '\x3', '\xA2', '\x3', '\xA2', '\x5', '\xA2', 
		'\xCFE', '\n', '\xA2', '\x3', '\xA2', '\x3', '\xA2', '\x3', '\xA2', '\x3', 
		'\xA2', '\x3', '\xA2', '\x3', '\xA2', '\a', '\xA2', '\xD06', '\n', '\xA2', 
		'\f', '\xA2', '\xE', '\xA2', '\xD09', '\v', '\xA2', '\x5', '\xA2', '\xD0B', 
		'\n', '\xA2', '\x3', '\xA2', '\x3', '\xA2', '\x3', '\xA2', '\x3', '\xA2', 
		'\x3', '\xA2', '\x5', '\xA2', '\xD12', '\n', '\xA2', '\x3', '\xA2', '\x3', 
		'\xA2', '\x5', '\xA2', '\xD16', '\n', '\xA2', '\x3', '\xA2', '\x3', '\xA2', 
		'\x3', '\xA2', '\x5', '\xA2', '\xD1B', '\n', '\xA2', '\x3', '\xA2', '\x3', 
		'\xA2', '\x3', '\xA2', '\x3', '\xA2', '\x5', '\xA2', '\xD21', '\n', '\xA2', 
		'\x3', '\xA2', '\x3', '\xA2', '\x3', '\xA2', '\x3', '\xA2', '\x5', '\xA2', 
		'\xD27', '\n', '\xA2', '\x3', '\xA2', '\x3', '\xA2', '\x3', '\xA2', '\x3', 
		'\xA2', '\x3', '\xA2', '\x3', '\xA2', '\x3', '\xA2', '\x3', '\xA2', '\x3', 
		'\xA2', '\a', '\xA2', '\xD32', '\n', '\xA2', '\f', '\xA2', '\xE', '\xA2', 
		'\xD35', '\v', '\xA2', '\x3', '\xA3', '\x3', '\xA3', '\x3', '\xA4', '\x3', 
		'\xA4', '\x3', '\xA5', '\x3', '\xA5', '\x3', '\xA6', '\x3', '\xA6', '\x3', 
		'\xA7', '\x3', '\xA7', '\x3', '\xA7', '\x2', '\x6', '\x14', '\x42', '\x126', 
		'\x142', '\xA8', '\x2', '\x4', '\x6', '\b', '\n', '\f', '\xE', '\x10', 
		'\x12', '\x14', '\x16', '\x18', '\x1A', '\x1C', '\x1E', ' ', '\"', '$', 
		'&', '(', '*', ',', '.', '\x30', '\x32', '\x34', '\x36', '\x38', ':', 
		'<', '>', '@', '\x42', '\x44', '\x46', 'H', 'J', 'L', 'N', 'P', 'R', 'T', 
		'V', 'X', 'Z', '\\', '^', '`', '\x62', '\x64', '\x66', 'h', 'j', 'l', 
		'n', 'p', 'r', 't', 'v', 'x', 'z', '|', '~', '\x80', '\x82', '\x84', '\x86', 
		'\x88', '\x8A', '\x8C', '\x8E', '\x90', '\x92', '\x94', '\x96', '\x98', 
		'\x9A', '\x9C', '\x9E', '\xA0', '\xA2', '\xA4', '\xA6', '\xA8', '\xAA', 
		'\xAC', '\xAE', '\xB0', '\xB2', '\xB4', '\xB6', '\xB8', '\xBA', '\xBC', 
		'\xBE', '\xC0', '\xC2', '\xC4', '\xC6', '\xC8', '\xCA', '\xCC', '\xCE', 
		'\xD0', '\xD2', '\xD4', '\xD6', '\xD8', '\xDA', '\xDC', '\xDE', '\xE0', 
		'\xE2', '\xE4', '\xE6', '\xE8', '\xEA', '\xEC', '\xEE', '\xF0', '\xF2', 
		'\xF4', '\xF6', '\xF8', '\xFA', '\xFC', '\xFE', '\x100', '\x102', '\x104', 
		'\x106', '\x108', '\x10A', '\x10C', '\x10E', '\x110', '\x112', '\x114', 
		'\x116', '\x118', '\x11A', '\x11C', '\x11E', '\x120', '\x122', '\x124', 
		'\x126', '\x128', '\x12A', '\x12C', '\x12E', '\x130', '\x132', '\x134', 
		'\x136', '\x138', '\x13A', '\x13C', '\x13E', '\x140', '\x142', '\x144', 
		'\x146', '\x148', '\x14A', '\x14C', '\x2', '\x39', '\x5', '\x2', '\x187', 
		'\x187', '\x242', '\x242', '\x25A', '\x25A', '\x4', '\x2', '\x163', '\x163', 
		'\x191', '\x191', '\x5', '\x2', '\x18E', '\x18E', '\x199', '\x199', '\x1B4', 
		'\x1B4', '\x5', '\x2', '\x63', '\x63', '\xBF', '\xBF', '\xD8', '\xD8', 
		'\x4', '\x2', '[', '[', '\xB3', '\xB3', '\x4', '\x2', 'Z', 'Z', '\x80', 
		'\x80', '\x5', '\x2', '\x25B', '\x25C', '\x25E', '\x25E', '\x261', '\x261', 
		'\x5', '\x2', '\x160', '\x160', '\x166', '\x166', '\x16C', '\x16C', '\x3', 
		'\x2', '\x12B', '\x12C', '\x4', '\x2', '\x11F', '\x11F', '\x1BC', '\x1BC', 
		'\x4', '\x2', ',', ',', '\x46', '\x46', '\x5', '\x2', '\x179', '\x179', 
		'\x19C', '\x19C', '\x1B2', '\x1B2', '\x4', '\x2', '\x14A', '\x14A', '\x17B', 
		'\x17B', '\a', '\x2', '\x12D', '\x12D', '\x133', '\x134', '\x139', '\x139', 
		'\x13D', '\x13D', '\x14F', '\x14F', '\x3', '\x2', '\x259', '\x25A', '\x5', 
		'\x2', '\xFF', '\xFF', '\x101', '\x101', '\x110', '\x110', '\x4', '\x2', 
		'\x170', '\x170', '\x18A', '\x18A', '\x4', '\x2', '\xFC', '\xFC', '\x1B6', 
		'\x1B6', '\x4', '\x2', '\xD8', '\xD8', '\x144', '\x144', '\x4', '\x2', 
		'Z', 'Z', '\x97', '\x97', '\x4', '\x2', '\x33', '\x33', '\x23E', '\x23E', 
		'\x4', '\x2', '\x242', '\x242', '\x25A', '\x25A', '\x4', '\x2', '\x61', 
		'\x61', '\x85', '\x85', '\x4', '\x2', '\xFF', '\xFF', '\x101', '\x101', 
		'\x4', '\x2', '\x1B', '\x1B', '\x85', '\x85', '\t', '\x2', '\x16F', '\x16F', 
		'\x172', '\x172', '\x1BF', '\x1BF', '\x1C7', '\x1C7', '\x20D', '\x20D', 
		'\x217', '\x217', '\x219', '\x219', '\x6', '\x2', '\x102', '\x102', '\x123', 
		'\x123', '\x1DF', '\x1DF', '\x21F', '\x21F', '\a', '\x2', '\x9F', '\x9F', 
		'\x18F', '\x18F', '\x1A3', '\x1A3', '\x1B3', '\x1B3', '\x262', '\x262', 
		'\x3', '\x2', '\x227', '\x228', '\x4', '\x2', '-', '-', '\x22A', '\x22A', 
		'\x4', '\x2', '&', '&', '\xD4', '\xD4', '\x4', '\x2', '\x5', '\x5', '\x144', 
		'\x144', '\x4', '\x2', '\x112', '\x112', '\x144', '\x144', '\x4', '\x2', 
		'\x193', '\x193', '\x197', '\x197', '\x4', '\x2', '\x4', '\x4', '\xC8', 
		'\xC8', '\x4', '\x2', '\x170', '\x170', '\x262', '\x262', '\x3', '\x2', 
		'\x24D', '\x24E', '\n', '\x2', '\xDB', '\xDB', '\x17E', '\x17F', '\x1AF', 
		'\x1AF', '\x223', '\x223', '\x225', '\x225', '\x229', '\x229', '\x22E', 
		'\x22E', '\x232', '\x232', '\a', '\x2', '\x224', '\x224', '\x22B', '\x22B', 
		'\x22F', '\x230', '\x233', '\x233', '\x23F', '\x23F', '\x4', '\x2', '-', 
		'-', '\xCF', '\xCF', '\x4', '\x2', '\x1A', '\x1A', '\xD0', '\xD0', '\a', 
		'\x2', '\x37', '\x37', 'q', 'q', '\xDB', '\xDB', '\xFC', '\xFC', '\x1AF', 
		'\x1AF', '\x5', '\x2', '\x31', '\x31', '\x102', '\x102', '\x15A', '\x15A', 
		'\x5', '\x2', '\x18F', '\x18F', '\x1A3', '\x1A3', '\x1B3', '\x1B3', '\x4', 
		'\x2', '\x16F', '\x16F', '\x210', '\x210', '\x3', '\x2', '\x24F', '\x251', 
		'\x4', '\x2', '\x242', '\x242', '\x246', '\x24A', '\x5', '\x2', '\x170', 
		'\x170', '\x174', '\x174', '\x1AD', '\x1AD', '\x3', '\x2', '\x262', '\x263', 
		'\x4', '\x2', '\x178', '\x178', '\x1AE', '\x1AE', '\x3', '\x2', '\x3', 
		'\x126', '\x3', '\x2', '\x127', '\x158', '\x3', '\x2', '\x159', '\x16F', 
		'\x3', '\x2', '\x170', '\x1BC', '\x3', '\x2', '\x1BD', '\x240', '\x2', 
		'\xF76', '\x2', '\x14E', '\x3', '\x2', '\x2', '\x2', '\x4', '\x155', '\x3', 
		'\x2', '\x2', '\x2', '\x6', '\x168', '\x3', '\x2', '\x2', '\x2', '\b', 
		'\x16D', '\x3', '\x2', '\x2', '\x2', '\n', '\x16F', '\x3', '\x2', '\x2', 
		'\x2', '\f', '\x173', '\x3', '\x2', '\x2', '\x2', '\xE', '\x17D', '\x3', 
		'\x2', '\x2', '\x2', '\x10', '\x1A8', '\x3', '\x2', '\x2', '\x2', '\x12', 
		'\x1AB', '\x3', '\x2', '\x2', '\x2', '\x14', '\x1BA', '\x3', '\x2', '\x2', 
		'\x2', '\x16', '\x20E', '\x3', '\x2', '\x2', '\x2', '\x18', '\x210', '\x3', 
		'\x2', '\x2', '\x2', '\x1A', '\x21F', '\x3', '\x2', '\x2', '\x2', '\x1C', 
		'\x238', '\x3', '\x2', '\x2', '\x2', '\x1E', '\x23A', '\x3', '\x2', '\x2', 
		'\x2', ' ', '\x23E', '\x3', '\x2', '\x2', '\x2', '\"', '\x246', '\x3', 
		'\x2', '\x2', '\x2', '$', '\x250', '\x3', '\x2', '\x2', '\x2', '&', '\x257', 
		'\x3', '\x2', '\x2', '\x2', '(', '\x261', '\x3', '\x2', '\x2', '\x2', 
		'*', '\x270', '\x3', '\x2', '\x2', '\x2', ',', '\x272', '\x3', '\x2', 
		'\x2', '\x2', '.', '\x274', '\x3', '\x2', '\x2', '\x2', '\x30', '\x27D', 
		'\x3', '\x2', '\x2', '\x2', '\x32', '\x28E', '\x3', '\x2', '\x2', '\x2', 
		'\x34', '\x298', '\x3', '\x2', '\x2', '\x2', '\x36', '\x2A1', '\x3', '\x2', 
		'\x2', '\x2', '\x38', '\x2A9', '\x3', '\x2', '\x2', '\x2', ':', '\x2B3', 
		'\x3', '\x2', '\x2', '\x2', '<', '\x2B5', '\x3', '\x2', '\x2', '\x2', 
		'>', '\x2B9', '\x3', '\x2', '\x2', '\x2', '@', '\x2CE', '\x3', '\x2', 
		'\x2', '\x2', '\x42', '\x2D8', '\x3', '\x2', '\x2', '\x2', '\x44', '\x376', 
		'\x3', '\x2', '\x2', '\x2', '\x46', '\x378', '\x3', '\x2', '\x2', '\x2', 
		'H', '\x387', '\x3', '\x2', '\x2', '\x2', 'J', '\x395', '\x3', '\x2', 
		'\x2', '\x2', 'L', '\x3F6', '\x3', '\x2', '\x2', '\x2', 'N', '\x3FD', 
		'\x3', '\x2', '\x2', '\x2', 'P', '\x402', '\x3', '\x2', '\x2', '\x2', 
		'R', '\x41F', '\x3', '\x2', '\x2', '\x2', 'T', '\x421', '\x3', '\x2', 
		'\x2', '\x2', 'V', '\x425', '\x3', '\x2', '\x2', '\x2', 'X', '\x458', 
		'\x3', '\x2', '\x2', '\x2', 'Z', '\x4FB', '\x3', '\x2', '\x2', '\x2', 
		'\\', '\x4FD', '\x3', '\x2', '\x2', '\x2', '^', '\x554', '\x3', '\x2', 
		'\x2', '\x2', '`', '\x567', '\x3', '\x2', '\x2', '\x2', '\x62', '\x56F', 
		'\x3', '\x2', '\x2', '\x2', '\x64', '\x571', '\x3', '\x2', '\x2', '\x2', 
		'\x66', '\x578', '\x3', '\x2', '\x2', '\x2', 'h', '\x58B', '\x3', '\x2', 
		'\x2', '\x2', 'j', '\x5A6', '\x3', '\x2', '\x2', '\x2', 'l', '\x5A8', 
		'\x3', '\x2', '\x2', '\x2', 'n', '\x5AF', '\x3', '\x2', '\x2', '\x2', 
		'p', '\x5B8', '\x3', '\x2', '\x2', '\x2', 'r', '\x5BA', '\x3', '\x2', 
		'\x2', '\x2', 't', '\x5BE', '\x3', '\x2', '\x2', '\x2', 'v', '\x5C2', 
		'\x3', '\x2', '\x2', '\x2', 'x', '\x5CB', '\x3', '\x2', '\x2', '\x2', 
		'z', '\x5DB', '\x3', '\x2', '\x2', '\x2', '|', '\x5EA', '\x3', '\x2', 
		'\x2', '\x2', '~', '\x5EC', '\x3', '\x2', '\x2', '\x2', '\x80', '\x5F8', 
		'\x3', '\x2', '\x2', '\x2', '\x82', '\x617', '\x3', '\x2', '\x2', '\x2', 
		'\x84', '\x641', '\x3', '\x2', '\x2', '\x2', '\x86', '\x699', '\x3', '\x2', 
		'\x2', '\x2', '\x88', '\x69B', '\x3', '\x2', '\x2', '\x2', '\x8A', '\x6AC', 
		'\x3', '\x2', '\x2', '\x2', '\x8C', '\x6BD', '\x3', '\x2', '\x2', '\x2', 
		'\x8E', '\x6C0', '\x3', '\x2', '\x2', '\x2', '\x90', '\x6F3', '\x3', '\x2', 
		'\x2', '\x2', '\x92', '\x6FC', '\x3', '\x2', '\x2', '\x2', '\x94', '\x6FE', 
		'\x3', '\x2', '\x2', '\x2', '\x96', '\x701', '\x3', '\x2', '\x2', '\x2', 
		'\x98', '\x705', '\x3', '\x2', '\x2', '\x2', '\x9A', '\x73E', '\x3', '\x2', 
		'\x2', '\x2', '\x9C', '\x740', '\x3', '\x2', '\x2', '\x2', '\x9E', '\x74B', 
		'\x3', '\x2', '\x2', '\x2', '\xA0', '\x757', '\x3', '\x2', '\x2', '\x2', 
		'\xA2', '\x759', '\x3', '\x2', '\x2', '\x2', '\xA4', '\x769', '\x3', '\x2', 
		'\x2', '\x2', '\xA6', '\x774', '\x3', '\x2', '\x2', '\x2', '\xA8', '\x78C', 
		'\x3', '\x2', '\x2', '\x2', '\xAA', '\x78E', '\x3', '\x2', '\x2', '\x2', 
		'\xAC', '\x794', '\x3', '\x2', '\x2', '\x2', '\xAE', '\x7AE', '\x3', '\x2', 
		'\x2', '\x2', '\xB0', '\x7EA', '\x3', '\x2', '\x2', '\x2', '\xB2', '\x7FB', 
		'\x3', '\x2', '\x2', '\x2', '\xB4', '\x7FD', '\x3', '\x2', '\x2', '\x2', 
		'\xB6', '\x81C', '\x3', '\x2', '\x2', '\x2', '\xB8', '\x823', '\x3', '\x2', 
		'\x2', '\x2', '\xBA', '\x84C', '\x3', '\x2', '\x2', '\x2', '\xBC', '\x84E', 
		'\x3', '\x2', '\x2', '\x2', '\xBE', '\x851', '\x3', '\x2', '\x2', '\x2', 
		'\xC0', '\x85C', '\x3', '\x2', '\x2', '\x2', '\xC2', '\x861', '\x3', '\x2', 
		'\x2', '\x2', '\xC4', '\x86A', '\x3', '\x2', '\x2', '\x2', '\xC6', '\x86D', 
		'\x3', '\x2', '\x2', '\x2', '\xC8', '\x873', '\x3', '\x2', '\x2', '\x2', 
		'\xCA', '\x89D', '\x3', '\x2', '\x2', '\x2', '\xCC', '\x8A8', '\x3', '\x2', 
		'\x2', '\x2', '\xCE', '\x8AF', '\x3', '\x2', '\x2', '\x2', '\xD0', '\x8BE', 
		'\x3', '\x2', '\x2', '\x2', '\xD2', '\x8DA', '\x3', '\x2', '\x2', '\x2', 
		'\xD4', '\x8DC', '\x3', '\x2', '\x2', '\x2', '\xD6', '\x8DE', '\x3', '\x2', 
		'\x2', '\x2', '\xD8', '\x8EF', '\x3', '\x2', '\x2', '\x2', '\xDA', '\x8F4', 
		'\x3', '\x2', '\x2', '\x2', '\xDC', '\x909', '\x3', '\x2', '\x2', '\x2', 
		'\xDE', '\x939', '\x3', '\x2', '\x2', '\x2', '\xE0', '\x96C', '\x3', '\x2', 
		'\x2', '\x2', '\xE2', '\x971', '\x3', '\x2', '\x2', '\x2', '\xE4', '\x975', 
		'\x3', '\x2', '\x2', '\x2', '\xE6', '\x986', '\x3', '\x2', '\x2', '\x2', 
		'\xE8', '\x988', '\x3', '\x2', '\x2', '\x2', '\xEA', '\x9A9', '\x3', '\x2', 
		'\x2', '\x2', '\xEC', '\x9AC', '\x3', '\x2', '\x2', '\x2', '\xEE', '\x9E3', 
		'\x3', '\x2', '\x2', '\x2', '\xF0', '\x9F6', '\x3', '\x2', '\x2', '\x2', 
		'\xF2', '\x9F9', '\x3', '\x2', '\x2', '\x2', '\xF4', '\x9FD', '\x3', '\x2', 
		'\x2', '\x2', '\xF6', '\xA27', '\x3', '\x2', '\x2', '\x2', '\xF8', '\xA29', 
		'\x3', '\x2', '\x2', '\x2', '\xFA', '\xA37', '\x3', '\x2', '\x2', '\x2', 
		'\xFC', '\xA39', '\x3', '\x2', '\x2', '\x2', '\xFE', '\xA41', '\x3', '\x2', 
		'\x2', '\x2', '\x100', '\xA43', '\x3', '\x2', '\x2', '\x2', '\x102', '\xA49', 
		'\x3', '\x2', '\x2', '\x2', '\x104', '\xA5C', '\x3', '\x2', '\x2', '\x2', 
		'\x106', '\xADC', '\x3', '\x2', '\x2', '\x2', '\x108', '\xAE0', '\x3', 
		'\x2', '\x2', '\x2', '\x10A', '\xAE2', '\x3', '\x2', '\x2', '\x2', '\x10C', 
		'\xAFC', '\x3', '\x2', '\x2', '\x2', '\x10E', '\xB20', '\x3', '\x2', '\x2', 
		'\x2', '\x110', '\xB22', '\x3', '\x2', '\x2', '\x2', '\x112', '\xB68', 
		'\x3', '\x2', '\x2', '\x2', '\x114', '\xB6A', '\x3', '\x2', '\x2', '\x2', 
		'\x116', '\xB6C', '\x3', '\x2', '\x2', '\x2', '\x118', '\xB74', '\x3', 
		'\x2', '\x2', '\x2', '\x11A', '\xB92', '\x3', '\x2', '\x2', '\x2', '\x11C', 
		'\xB94', '\x3', '\x2', '\x2', '\x2', '\x11E', '\xB98', '\x3', '\x2', '\x2', 
		'\x2', '\x120', '\xBA1', '\x3', '\x2', '\x2', '\x2', '\x122', '\xBA8', 
		'\x3', '\x2', '\x2', '\x2', '\x124', '\xBBE', '\x3', '\x2', '\x2', '\x2', 
		'\x126', '\xBD7', '\x3', '\x2', '\x2', '\x2', '\x128', '\xC19', '\x3', 
		'\x2', '\x2', '\x2', '\x12A', '\xC2D', '\x3', '\x2', '\x2', '\x2', '\x12C', 
		'\xC2F', '\x3', '\x2', '\x2', '\x2', '\x12E', '\xC44', '\x3', '\x2', '\x2', 
		'\x2', '\x130', '\xC46', '\x3', '\x2', '\x2', '\x2', '\x132', '\xC4B', 
		'\x3', '\x2', '\x2', '\x2', '\x134', '\xC60', '\x3', '\x2', '\x2', '\x2', 
		'\x136', '\xC65', '\x3', '\x2', '\x2', '\x2', '\x138', '\xC67', '\x3', 
		'\x2', '\x2', '\x2', '\x13A', '\xC6F', '\x3', '\x2', '\x2', '\x2', '\x13C', 
		'\xC85', '\x3', '\x2', '\x2', '\x2', '\x13E', '\xC87', '\x3', '\x2', '\x2', 
		'\x2', '\x140', '\xC89', '\x3', '\x2', '\x2', '\x2', '\x142', '\xCAA', 
		'\x3', '\x2', '\x2', '\x2', '\x144', '\xD36', '\x3', '\x2', '\x2', '\x2', 
		'\x146', '\xD38', '\x3', '\x2', '\x2', '\x2', '\x148', '\xD3A', '\x3', 
		'\x2', '\x2', '\x2', '\x14A', '\xD3C', '\x3', '\x2', '\x2', '\x2', '\x14C', 
		'\xD3E', '\x3', '\x2', '\x2', '\x2', '\x14E', '\x150', '\x5', '\x4', '\x3', 
		'\x2', '\x14F', '\x151', '\a', '\x244', '\x2', '\x2', '\x150', '\x14F', 
		'\x3', '\x2', '\x2', '\x2', '\x150', '\x151', '\x3', '\x2', '\x2', '\x2', 
		'\x151', '\x152', '\x3', '\x2', '\x2', '\x2', '\x152', '\x153', '\a', 
		'\x2', '\x2', '\x3', '\x153', '\x3', '\x3', '\x2', '\x2', '\x2', '\x154', 
		'\x156', '\x5', '\n', '\x6', '\x2', '\x155', '\x154', '\x3', '\x2', '\x2', 
		'\x2', '\x155', '\x156', '\x3', '\x2', '\x2', '\x2', '\x156', '\x158', 
		'\x3', '\x2', '\x2', '\x2', '\x157', '\x159', '\x5', '\f', '\a', '\x2', 
		'\x158', '\x157', '\x3', '\x2', '\x2', '\x2', '\x158', '\x159', '\x3', 
		'\x2', '\x2', '\x2', '\x159', '\x15A', '\x3', '\x2', '\x2', '\x2', '\x15A', 
		'\x15B', '\a', '\x15', '\x2', '\x2', '\x15B', '\x15D', '\x5', '\xA4', 
		'S', '\x2', '\x15C', '\x15E', '\x5', '\xA2', 'R', '\x2', '\x15D', '\x15C', 
		'\x3', '\x2', '\x2', '\x2', '\x15D', '\x15E', '\x3', '\x2', '\x2', '\x2', 
		'\x15E', '\x160', '\x3', '\x2', '\x2', '\x2', '\x15F', '\x161', '\a', 
		'\x18D', '\x2', '\x2', '\x160', '\x15F', '\x3', '\x2', '\x2', '\x2', '\x160', 
		'\x161', '\x3', '\x2', '\x2', '\x2', '\x161', '\x163', '\x3', '\x2', '\x2', 
		'\x2', '\x162', '\x164', '\x5', '\b', '\x5', '\x2', '\x163', '\x162', 
		'\x3', '\x2', '\x2', '\x2', '\x163', '\x164', '\x3', '\x2', '\x2', '\x2', 
		'\x164', '\x5', '\x3', '\x2', '\x2', '\x2', '\x165', '\x169', '\a', '\x265', 
		'\x2', '\x2', '\x166', '\x169', '\a', '\x266', '\x2', '\x2', '\x167', 
		'\x169', '\x5', '\x14C', '\xA7', '\x2', '\x168', '\x165', '\x3', '\x2', 
		'\x2', '\x2', '\x168', '\x166', '\x3', '\x2', '\x2', '\x2', '\x168', '\x167', 
		'\x3', '\x2', '\x2', '\x2', '\x169', '\a', '\x3', '\x2', '\x2', '\x2', 
		'\x16A', '\x16E', '\x5', '\x6', '\x4', '\x2', '\x16B', '\x16E', '\x5', 
		'\x144', '\xA3', '\x2', '\x16C', '\x16E', '\x5', '\x146', '\xA4', '\x2', 
		'\x16D', '\x16A', '\x3', '\x2', '\x2', '\x2', '\x16D', '\x16B', '\x3', 
		'\x2', '\x2', '\x2', '\x16D', '\x16C', '\x3', '\x2', '\x2', '\x2', '\x16E', 
		'\t', '\x3', '\x2', '\x2', '\x2', '\x16F', '\x170', '\a', '\x25B', '\x2', 
		'\x2', '\x170', '\x171', '\x5', '\b', '\x5', '\x2', '\x171', '\x172', 
		'\a', '\x25C', '\x2', '\x2', '\x172', '\v', '\x3', '\x2', '\x2', '\x2', 
		'\x173', '\x177', '\a', ':', '\x2', '\x2', '\x174', '\x176', '\x5', '\xE', 
		'\b', '\x2', '\x175', '\x174', '\x3', '\x2', '\x2', '\x2', '\x176', '\x179', 
		'\x3', '\x2', '\x2', '\x2', '\x177', '\x175', '\x3', '\x2', '\x2', '\x2', 
		'\x177', '\x178', '\x3', '\x2', '\x2', '\x2', '\x178', '\r', '\x3', '\x2', 
		'\x2', '\x2', '\x179', '\x177', '\x3', '\x2', '\x2', '\x2', '\x17A', '\x17C', 
		'\a', ':', '\x2', '\x2', '\x17B', '\x17A', '\x3', '\x2', '\x2', '\x2', 
		'\x17C', '\x17F', '\x3', '\x2', '\x2', '\x2', '\x17D', '\x17B', '\x3', 
		'\x2', '\x2', '\x2', '\x17D', '\x17E', '\x3', '\x2', '\x2', '\x2', '\x17E', 
		'\x180', '\x3', '\x2', '\x2', '\x2', '\x17F', '\x17D', '\x3', '\x2', '\x2', 
		'\x2', '\x180', '\x181', '\x5', '\b', '\x5', '\x2', '\x181', '\x182', 
		'\x5', '\x10', '\t', '\x2', '\x182', '\x183', '\a', '\x244', '\x2', '\x2', 
		'\x183', '\xF', '\x3', '\x2', '\x2', '\x2', '\x184', '\x186', '\a', '\x222', 
		'\x2', '\x2', '\x185', '\x184', '\x3', '\x2', '\x2', '\x2', '\x185', '\x186', 
		'\x3', '\x2', '\x2', '\x2', '\x186', '\x187', '\x3', '\x2', '\x2', '\x2', 
		'\x187', '\x189', '\x5', '\xA0', 'Q', '\x2', '\x188', '\x18A', '\x5', 
		'\x9E', 'P', '\x2', '\x189', '\x188', '\x3', '\x2', '\x2', '\x2', '\x189', 
		'\x18A', '\x3', '\x2', '\x2', '\x2', '\x18A', '\x18D', '\x3', '\x2', '\x2', 
		'\x2', '\x18B', '\x18C', '\a', '\x1A0', '\x2', '\x2', '\x18C', '\x18E', 
		'\a', '\x1A1', '\x2', '\x2', '\x18D', '\x18B', '\x3', '\x2', '\x2', '\x2', 
		'\x18D', '\x18E', '\x3', '\x2', '\x2', '\x2', '\x18E', '\x191', '\x3', 
		'\x2', '\x2', '\x2', '\x18F', '\x190', '\t', '\x2', '\x2', '\x2', '\x190', 
		'\x192', '\x5', '\x142', '\xA2', '\x2', '\x191', '\x18F', '\x3', '\x2', 
		'\x2', '\x2', '\x191', '\x192', '\x3', '\x2', '\x2', '\x2', '\x192', '\x1A9', 
		'\x3', '\x2', '\x2', '\x2', '\x193', '\x194', '\a', '\x220', '\x2', '\x2', 
		'\x194', '\x197', '\a', '\x191', '\x2', '\x2', '\x195', '\x198', '\x5', 
		'\b', '\x5', '\x2', '\x196', '\x198', '\a', '\x264', '\x2', '\x2', '\x197', 
		'\x195', '\x3', '\x2', '\x2', '\x2', '\x197', '\x196', '\x3', '\x2', '\x2', 
		'\x2', '\x198', '\x1A9', '\x3', '\x2', '\x2', '\x2', '\x199', '\x19B', 
		'\a', '\x98', '\x2', '\x2', '\x19A', '\x199', '\x3', '\x2', '\x2', '\x2', 
		'\x19A', '\x19B', '\x3', '\x2', '\x2', '\x2', '\x19B', '\x19C', '\x3', 
		'\x2', '\x2', '\x2', '\x19C', '\x19E', '\a', '\xDD', '\x2', '\x2', '\x19D', 
		'\x19A', '\x3', '\x2', '\x2', '\x2', '\x19D', '\x19E', '\x3', '\x2', '\x2', 
		'\x2', '\x19E', '\x19F', '\x3', '\x2', '\x2', '\x2', '\x19F', '\x1A4', 
		'\a', '\x34', '\x2', '\x2', '\x1A0', '\x1A1', '\a', '\x24B', '\x2', '\x2', 
		'\x1A1', '\x1A2', '\x5', '\x9C', 'O', '\x2', '\x1A2', '\x1A3', '\a', '\x24C', 
		'\x2', '\x2', '\x1A3', '\x1A5', '\x3', '\x2', '\x2', '\x2', '\x1A4', '\x1A0', 
		'\x3', '\x2', '\x2', '\x2', '\x1A4', '\x1A5', '\x3', '\x2', '\x2', '\x2', 
		'\x1A5', '\x1A6', '\x3', '\x2', '\x2', '\x2', '\x1A6', '\x1A7', '\t', 
		'\x3', '\x2', '\x2', '\x1A7', '\x1A9', '\x5', '\x12', '\n', '\x2', '\x1A8', 
		'\x185', '\x3', '\x2', '\x2', '\x2', '\x1A8', '\x193', '\x3', '\x2', '\x2', 
		'\x2', '\x1A8', '\x19D', '\x3', '\x2', '\x2', '\x2', '\x1A9', '\x11', 
		'\x3', '\x2', '\x2', '\x2', '\x1AA', '\x1AC', '\x5', '~', '@', '\x2', 
		'\x1AB', '\x1AA', '\x3', '\x2', '\x2', '\x2', '\x1AB', '\x1AC', '\x3', 
		'\x2', '\x2', '\x2', '\x1AC', '\x1AD', '\x3', '\x2', '\x2', '\x2', '\x1AD', 
		'\x1B1', '\x5', '\x14', '\v', '\x2', '\x1AE', '\x1B0', '\x5', '\x9A', 
		'N', '\x2', '\x1AF', '\x1AE', '\x3', '\x2', '\x2', '\x2', '\x1B0', '\x1B3', 
		'\x3', '\x2', '\x2', '\x2', '\x1B1', '\x1AF', '\x3', '\x2', '\x2', '\x2', 
		'\x1B1', '\x1B2', '\x3', '\x2', '\x2', '\x2', '\x1B2', '\x13', '\x3', 
		'\x2', '\x2', '\x2', '\x1B3', '\x1B1', '\x3', '\x2', '\x2', '\x2', '\x1B4', 
		'\x1B5', '\b', '\v', '\x1', '\x2', '\x1B5', '\x1B6', '\a', '\x24B', '\x2', 
		'\x2', '\x1B6', '\x1B7', '\x5', '\x12', '\n', '\x2', '\x1B7', '\x1B8', 
		'\a', '\x24C', '\x2', '\x2', '\x1B8', '\x1BB', '\x3', '\x2', '\x2', '\x2', 
		'\x1B9', '\x1BB', '\x5', '\x16', '\f', '\x2', '\x1BA', '\x1B4', '\x3', 
		'\x2', '\x2', '\x2', '\x1BA', '\x1B9', '\x3', '\x2', '\x2', '\x2', '\x1BB', 
		'\x1C4', '\x3', '\x2', '\x2', '\x2', '\x1BC', '\x1BD', '\f', '\x4', '\x2', 
		'\x2', '\x1BD', '\x1BF', '\t', '\x4', '\x2', '\x2', '\x1BE', '\x1C0', 
		'\x5', '|', '?', '\x2', '\x1BF', '\x1BE', '\x3', '\x2', '\x2', '\x2', 
		'\x1BF', '\x1C0', '\x3', '\x2', '\x2', '\x2', '\x1C0', '\x1C1', '\x3', 
		'\x2', '\x2', '\x2', '\x1C1', '\x1C3', '\x5', '\x14', '\v', '\x5', '\x1C2', 
		'\x1BC', '\x3', '\x2', '\x2', '\x2', '\x1C3', '\x1C6', '\x3', '\x2', '\x2', 
		'\x2', '\x1C4', '\x1C2', '\x3', '\x2', '\x2', '\x2', '\x1C4', '\x1C5', 
		'\x3', '\x2', '\x2', '\x2', '\x1C5', '\x15', '\x3', '\x2', '\x2', '\x2', 
		'\x1C6', '\x1C4', '\x3', '\x2', '\x2', '\x2', '\x1C7', '\x1D7', '\a', 
		'\x1AB', '\x2', '\x2', '\x1C8', '\x1D5', '\x5', '|', '?', '\x2', '\x1C9', 
		'\x1CA', '\a', '\x1A3', '\x2', '\x2', '\x1CA', '\x1CB', '\a', '\x24B', 
		'\x2', '\x2', '\x1CB', '\x1D0', '\x5', '\x142', '\xA2', '\x2', '\x1CC', 
		'\x1CD', '\a', '\x245', '\x2', '\x2', '\x1CD', '\x1CF', '\x5', '\x142', 
		'\xA2', '\x2', '\x1CE', '\x1CC', '\x3', '\x2', '\x2', '\x2', '\x1CF', 
		'\x1D2', '\x3', '\x2', '\x2', '\x2', '\x1D0', '\x1CE', '\x3', '\x2', '\x2', 
		'\x2', '\x1D0', '\x1D1', '\x3', '\x2', '\x2', '\x2', '\x1D1', '\x1D3', 
		'\x3', '\x2', '\x2', '\x2', '\x1D2', '\x1D0', '\x3', '\x2', '\x2', '\x2', 
		'\x1D3', '\x1D4', '\a', '\x24C', '\x2', '\x2', '\x1D4', '\x1D6', '\x3', 
		'\x2', '\x2', '\x2', '\x1D5', '\x1C9', '\x3', '\x2', '\x2', '\x2', '\x1D5', 
		'\x1D6', '\x3', '\x2', '\x2', '\x2', '\x1D6', '\x1D8', '\x3', '\x2', '\x2', 
		'\x2', '\x1D7', '\x1C8', '\x3', '\x2', '\x2', '\x2', '\x1D7', '\x1D8', 
		'\x3', '\x2', '\x2', '\x2', '\x1D8', '\x1DA', '\x3', '\x2', '\x2', '\x2', 
		'\x1D9', '\x1DB', '\x5', '\x36', '\x1C', '\x2', '\x1DA', '\x1D9', '\x3', 
		'\x2', '\x2', '\x2', '\x1DA', '\x1DB', '\x3', '\x2', '\x2', '\x2', '\x1DB', 
		'\x1DD', '\x3', '\x2', '\x2', '\x2', '\x1DC', '\x1DE', '\x5', 'z', '>', 
		'\x2', '\x1DD', '\x1DC', '\x3', '\x2', '\x2', '\x2', '\x1DD', '\x1DE', 
		'\x3', '\x2', '\x2', '\x2', '\x1DE', '\x1E8', '\x3', '\x2', '\x2', '\x2', 
		'\x1DF', '\x1E0', '\a', '\x193', '\x2', '\x2', '\x1E0', '\x1E5', '\x5', 
		'\x42', '\"', '\x2', '\x1E1', '\x1E2', '\a', '\x245', '\x2', '\x2', '\x1E2', 
		'\x1E4', '\x5', '\x42', '\"', '\x2', '\x1E3', '\x1E1', '\x3', '\x2', '\x2', 
		'\x2', '\x1E4', '\x1E7', '\x3', '\x2', '\x2', '\x2', '\x1E5', '\x1E3', 
		'\x3', '\x2', '\x2', '\x2', '\x1E5', '\x1E6', '\x3', '\x2', '\x2', '\x2', 
		'\x1E6', '\x1E9', '\x3', '\x2', '\x2', '\x2', '\x1E7', '\x1E5', '\x3', 
		'\x2', '\x2', '\x2', '\x1E8', '\x1DF', '\x3', '\x2', '\x2', '\x2', '\x1E8', 
		'\x1E9', '\x3', '\x2', '\x2', '\x2', '\x1E9', '\x1EC', '\x3', '\x2', '\x2', 
		'\x2', '\x1EA', '\x1EB', '\a', '\x1BA', '\x2', '\x2', '\x1EB', '\x1ED', 
		'\x5', '\x142', '\xA2', '\x2', '\x1EC', '\x1EA', '\x3', '\x2', '\x2', 
		'\x2', '\x1EC', '\x1ED', '\x3', '\x2', '\x2', '\x2', '\x1ED', '\x1EF', 
		'\x3', '\x2', '\x2', '\x2', '\x1EE', '\x1F0', '\x5', '<', '\x1F', '\x2', 
		'\x1EF', '\x1EE', '\x3', '\x2', '\x2', '\x2', '\x1EF', '\x1F0', '\x3', 
		'\x2', '\x2', '\x2', '\x1F0', '\x1F3', '\x3', '\x2', '\x2', '\x2', '\x1F1', 
		'\x1F2', '\a', '\x196', '\x2', '\x2', '\x1F2', '\x1F4', '\x5', '\x142', 
		'\xA2', '\x2', '\x1F3', '\x1F1', '\x3', '\x2', '\x2', '\x2', '\x1F3', 
		'\x1F4', '\x3', '\x2', '\x2', '\x2', '\x1F4', '\x203', '\x3', '\x2', '\x2', 
		'\x2', '\x1F5', '\x1F6', '\a', '\x1BB', '\x2', '\x2', '\x1F6', '\x1F7', 
		'\x5', '\b', '\x5', '\x2', '\x1F7', '\x1F8', '\a', '\x176', '\x2', '\x2', 
		'\x1F8', '\x200', '\x5', '\x18', '\r', '\x2', '\x1F9', '\x1FA', '\a', 
		'\x245', '\x2', '\x2', '\x1FA', '\x1FB', '\x5', '\b', '\x5', '\x2', '\x1FB', 
		'\x1FC', '\a', '\x176', '\x2', '\x2', '\x1FC', '\x1FD', '\x5', '\x18', 
		'\r', '\x2', '\x1FD', '\x1FF', '\x3', '\x2', '\x2', '\x2', '\x1FE', '\x1F9', 
		'\x3', '\x2', '\x2', '\x2', '\x1FF', '\x202', '\x3', '\x2', '\x2', '\x2', 
		'\x200', '\x1FE', '\x3', '\x2', '\x2', '\x2', '\x200', '\x201', '\x3', 
		'\x2', '\x2', '\x2', '\x201', '\x204', '\x3', '\x2', '\x2', '\x2', '\x202', 
		'\x200', '\x3', '\x2', '\x2', '\x2', '\x203', '\x1F5', '\x3', '\x2', '\x2', 
		'\x2', '\x203', '\x204', '\x3', '\x2', '\x2', '\x2', '\x204', '\x20F', 
		'\x3', '\x2', '\x2', '\x2', '\x205', '\x207', '\a', '\x1AF', '\x2', '\x2', 
		'\x206', '\x208', '\a', '\x1A4', '\x2', '\x2', '\x207', '\x206', '\x3', 
		'\x2', '\x2', '\x2', '\x207', '\x208', '\x3', '\x2', '\x2', '\x2', '\x208', 
		'\x209', '\x3', '\x2', '\x2', '\x2', '\x209', '\x20B', '\x5', '\x34', 
		'\x1B', '\x2', '\x20A', '\x20C', '\a', '\x24F', '\x2', '\x2', '\x20B', 
		'\x20A', '\x3', '\x2', '\x2', '\x2', '\x20B', '\x20C', '\x3', '\x2', '\x2', 
		'\x2', '\x20C', '\x20F', '\x3', '\x2', '\x2', '\x2', '\x20D', '\x20F', 
		'\x5', '.', '\x18', '\x2', '\x20E', '\x1C7', '\x3', '\x2', '\x2', '\x2', 
		'\x20E', '\x205', '\x3', '\x2', '\x2', '\x2', '\x20E', '\x20D', '\x3', 
		'\x2', '\x2', '\x2', '\x20F', '\x17', '\x3', '\x2', '\x2', '\x2', '\x210', 
		'\x212', '\a', '\x24B', '\x2', '\x2', '\x211', '\x213', '\x5', '\b', '\x5', 
		'\x2', '\x212', '\x211', '\x3', '\x2', '\x2', '\x2', '\x212', '\x213', 
		'\x3', '\x2', '\x2', '\x2', '\x213', '\x215', '\x3', '\x2', '\x2', '\x2', 
		'\x214', '\x216', '\x5', '\x32', '\x1A', '\x2', '\x215', '\x214', '\x3', 
		'\x2', '\x2', '\x2', '\x215', '\x216', '\x3', '\x2', '\x2', '\x2', '\x216', 
		'\x218', '\x3', '\x2', '\x2', '\x2', '\x217', '\x219', '\x5', '\x1E', 
		'\x10', '\x2', '\x218', '\x217', '\x3', '\x2', '\x2', '\x2', '\x218', 
		'\x219', '\x3', '\x2', '\x2', '\x2', '\x219', '\x21B', '\x3', '\x2', '\x2', 
		'\x2', '\x21A', '\x21C', '\x5', '\x1A', '\xE', '\x2', '\x21B', '\x21A', 
		'\x3', '\x2', '\x2', '\x2', '\x21B', '\x21C', '\x3', '\x2', '\x2', '\x2', 
		'\x21C', '\x21D', '\x3', '\x2', '\x2', '\x2', '\x21D', '\x21E', '\a', 
		'\x24C', '\x2', '\x2', '\x21E', '\x19', '\x3', '\x2', '\x2', '\x2', '\x21F', 
		'\x226', '\t', '\x5', '\x2', '\x2', '\x220', '\x227', '\x5', '\x1C', '\xF', 
		'\x2', '\x221', '\x222', '\a', '\x127', '\x2', '\x2', '\x222', '\x223', 
		'\x5', '\x1C', '\xF', '\x2', '\x223', '\x224', '\a', '\x173', '\x2', '\x2', 
		'\x224', '\x225', '\x5', '\x1C', '\xF', '\x2', '\x225', '\x227', '\x3', 
		'\x2', '\x2', '\x2', '\x226', '\x220', '\x3', '\x2', '\x2', '\x2', '\x226', 
		'\x221', '\x3', '\x2', '\x2', '\x2', '\x227', '\x231', '\x3', '\x2', '\x2', 
		'\x2', '\x228', '\x22F', '\a', 'Q', '\x2', '\x2', '\x229', '\x22A', '\a', 
		'\x33', '\x2', '\x2', '\x22A', '\x230', '\a', '\x144', '\x2', '\x2', '\x22B', 
		'\x230', '\a', '\x195', '\x2', '\x2', '\x22C', '\x230', '\a', '\x103', 
		'\x2', '\x2', '\x22D', '\x22E', '\a', '\x98', '\x2', '\x2', '\x22E', '\x230', 
		'\a', '\xA6', '\x2', '\x2', '\x22F', '\x229', '\x3', '\x2', '\x2', '\x2', 
		'\x22F', '\x22B', '\x3', '\x2', '\x2', '\x2', '\x22F', '\x22C', '\x3', 
		'\x2', '\x2', '\x2', '\x22F', '\x22D', '\x3', '\x2', '\x2', '\x2', '\x230', 
		'\x232', '\x3', '\x2', '\x2', '\x2', '\x231', '\x228', '\x3', '\x2', '\x2', 
		'\x2', '\x231', '\x232', '\x3', '\x2', '\x2', '\x2', '\x232', '\x1B', 
		'\x3', '\x2', '\x2', '\x2', '\x233', '\x234', '\x5', '\x142', '\xA2', 
		'\x2', '\x234', '\x235', '\t', '\x6', '\x2', '\x2', '\x235', '\x239', 
		'\x3', '\x2', '\x2', '\x2', '\x236', '\x237', '\a', '\x33', '\x2', '\x2', 
		'\x237', '\x239', '\a', '\x144', '\x2', '\x2', '\x238', '\x233', '\x3', 
		'\x2', '\x2', '\x2', '\x238', '\x236', '\x3', '\x2', '\x2', '\x2', '\x239', 
		'\x1D', '\x3', '\x2', '\x2', '\x2', '\x23A', '\x23B', '\a', '\x1A6', '\x2', 
		'\x2', '\x23B', '\x23C', '\a', '\x16', '\x2', '\x2', '\x23C', '\x23D', 
		'\x5', ' ', '\x11', '\x2', '\x23D', '\x1F', '\x3', '\x2', '\x2', '\x2', 
		'\x23E', '\x243', '\x5', '\"', '\x12', '\x2', '\x23F', '\x240', '\a', 
		'\x245', '\x2', '\x2', '\x240', '\x242', '\x5', '\"', '\x12', '\x2', '\x241', 
		'\x23F', '\x3', '\x2', '\x2', '\x2', '\x242', '\x245', '\x3', '\x2', '\x2', 
		'\x2', '\x243', '\x241', '\x3', '\x2', '\x2', '\x2', '\x243', '\x244', 
		'\x3', '\x2', '\x2', '\x2', '\x244', '!', '\x3', '\x2', '\x2', '\x2', 
		'\x245', '\x243', '\x3', '\x2', '\x2', '\x2', '\x246', '\x248', '\x5', 
		'\x142', '\xA2', '\x2', '\x247', '\x249', '\x5', '\x34', '\x1B', '\x2', 
		'\x248', '\x247', '\x3', '\x2', '\x2', '\x2', '\x248', '\x249', '\x3', 
		'\x2', '\x2', '\x2', '\x249', '\x24B', '\x3', '\x2', '\x2', '\x2', '\x24A', 
		'\x24C', '\x5', '&', '\x14', '\x2', '\x24B', '\x24A', '\x3', '\x2', '\x2', 
		'\x2', '\x24B', '\x24C', '\x3', '\x2', '\x2', '\x2', '\x24C', '\x24E', 
		'\x3', '\x2', '\x2', '\x2', '\x24D', '\x24F', '\x5', '$', '\x13', '\x2', 
		'\x24E', '\x24D', '\x3', '\x2', '\x2', '\x2', '\x24E', '\x24F', '\x3', 
		'\x2', '\x2', '\x2', '\x24F', '#', '\x3', '\x2', '\x2', '\x2', '\x250', 
		'\x251', '\a', '\x9C', '\x2', '\x2', '\x251', '\x252', '\t', '\a', '\x2', 
		'\x2', '\x252', '%', '\x3', '\x2', '\x2', '\x2', '\x253', '\x258', '\a', 
		'\x177', '\x2', '\x2', '\x254', '\x258', '\a', '\x189', '\x2', '\x2', 
		'\x255', '\x256', '\a', '\x1B7', '\x2', '\x2', '\x256', '\x258', '\x5', 
		'(', '\x15', '\x2', '\x257', '\x253', '\x3', '\x2', '\x2', '\x2', '\x257', 
		'\x254', '\x3', '\x2', '\x2', '\x2', '\x257', '\x255', '\x3', '\x2', '\x2', 
		'\x2', '\x258', '\'', '\x3', '\x2', '\x2', '\x2', '\x259', '\x262', '\x5', 
		'*', '\x16', '\x2', '\x25A', '\x25B', '\a', '\xA2', '\x2', '\x2', '\x25B', 
		'\x25C', '\a', '\x24B', '\x2', '\x2', '\x25C', '\x25D', '\x5', '\b', '\x5', 
		'\x2', '\x25D', '\x25E', '\a', '\x253', '\x2', '\x2', '\x25E', '\x25F', 
		'\x5', '*', '\x16', '\x2', '\x25F', '\x260', '\a', '\x24C', '\x2', '\x2', 
		'\x260', '\x262', '\x3', '\x2', '\x2', '\x2', '\x261', '\x259', '\x3', 
		'\x2', '\x2', '\x2', '\x261', '\x25A', '\x3', '\x2', '\x2', '\x2', '\x262', 
		')', '\x3', '\x2', '\x2', '\x2', '\x263', '\x271', '\x5', ',', '\x17', 
		'\x2', '\x264', '\x271', '\a', '\x242', '\x2', '\x2', '\x265', '\x271', 
		'\a', '\x246', '\x2', '\x2', '\x266', '\x271', '\a', '\x247', '\x2', '\x2', 
		'\x267', '\x271', '\a', '\x248', '\x2', '\x2', '\x268', '\x271', '\a', 
		'\x249', '\x2', '\x2', '\x269', '\x271', '\a', '\x24A', '\x2', '\x2', 
		'\x26A', '\x271', '\a', '\x24D', '\x2', '\x2', '\x26B', '\x271', '\a', 
		'\x24E', '\x2', '\x2', '\x26C', '\x271', '\a', '\x24F', '\x2', '\x2', 
		'\x26D', '\x271', '\a', '\x250', '\x2', '\x2', '\x26E', '\x271', '\a', 
		'\x251', '\x2', '\x2', '\x26F', '\x271', '\a', '\x252', '\x2', '\x2', 
		'\x270', '\x263', '\x3', '\x2', '\x2', '\x2', '\x270', '\x264', '\x3', 
		'\x2', '\x2', '\x2', '\x270', '\x265', '\x3', '\x2', '\x2', '\x2', '\x270', 
		'\x266', '\x3', '\x2', '\x2', '\x2', '\x270', '\x267', '\x3', '\x2', '\x2', 
		'\x2', '\x270', '\x268', '\x3', '\x2', '\x2', '\x2', '\x270', '\x269', 
		'\x3', '\x2', '\x2', '\x2', '\x270', '\x26A', '\x3', '\x2', '\x2', '\x2', 
		'\x270', '\x26B', '\x3', '\x2', '\x2', '\x2', '\x270', '\x26C', '\x3', 
		'\x2', '\x2', '\x2', '\x270', '\x26D', '\x3', '\x2', '\x2', '\x2', '\x270', 
		'\x26E', '\x3', '\x2', '\x2', '\x2', '\x270', '\x26F', '\x3', '\x2', '\x2', 
		'\x2', '\x271', '+', '\x3', '\x2', '\x2', '\x2', '\x272', '\x273', '\t', 
		'\b', '\x2', '\x2', '\x273', '-', '\x3', '\x2', '\x2', '\x2', '\x274', 
		'\x275', '\a', '\x14C', '\x2', '\x2', '\x275', '\x27A', '\x5', '\x30', 
		'\x19', '\x2', '\x276', '\x277', '\a', '\x245', '\x2', '\x2', '\x277', 
		'\x279', '\x5', '\x30', '\x19', '\x2', '\x278', '\x276', '\x3', '\x2', 
		'\x2', '\x2', '\x279', '\x27C', '\x3', '\x2', '\x2', '\x2', '\x27A', '\x278', 
		'\x3', '\x2', '\x2', '\x2', '\x27A', '\x27B', '\x3', '\x2', '\x2', '\x2', 
		'\x27B', '/', '\x3', '\x2', '\x2', '\x2', '\x27C', '\x27A', '\x3', '\x2', 
		'\x2', '\x2', '\x27D', '\x280', '\a', '\x24B', '\x2', '\x2', '\x27E', 
		'\x281', '\x5', '\x142', '\xA2', '\x2', '\x27F', '\x281', '\a', '\x187', 
		'\x2', '\x2', '\x280', '\x27E', '\x3', '\x2', '\x2', '\x2', '\x280', '\x27F', 
		'\x3', '\x2', '\x2', '\x2', '\x281', '\x289', '\x3', '\x2', '\x2', '\x2', 
		'\x282', '\x285', '\a', '\x245', '\x2', '\x2', '\x283', '\x286', '\x5', 
		'\x142', '\xA2', '\x2', '\x284', '\x286', '\a', '\x187', '\x2', '\x2', 
		'\x285', '\x283', '\x3', '\x2', '\x2', '\x2', '\x285', '\x284', '\x3', 
		'\x2', '\x2', '\x2', '\x286', '\x288', '\x3', '\x2', '\x2', '\x2', '\x287', 
		'\x282', '\x3', '\x2', '\x2', '\x2', '\x288', '\x28B', '\x3', '\x2', '\x2', 
		'\x2', '\x289', '\x287', '\x3', '\x2', '\x2', '\x2', '\x289', '\x28A', 
		'\x3', '\x2', '\x2', '\x2', '\x28A', '\x28C', '\x3', '\x2', '\x2', '\x2', 
		'\x28B', '\x289', '\x3', '\x2', '\x2', '\x2', '\x28C', '\x28D', '\a', 
		'\x24C', '\x2', '\x2', '\x28D', '\x31', '\x3', '\x2', '\x2', '\x2', '\x28E', 
		'\x28F', '\a', '\xAE', '\x2', '\x2', '\x28F', '\x290', '\a', '\x16', '\x2', 
		'\x2', '\x290', '\x295', '\x5', '\x142', '\xA2', '\x2', '\x291', '\x292', 
		'\a', '\x245', '\x2', '\x2', '\x292', '\x294', '\x5', '\x142', '\xA2', 
		'\x2', '\x293', '\x291', '\x3', '\x2', '\x2', '\x2', '\x294', '\x297', 
		'\x3', '\x2', '\x2', '\x2', '\x295', '\x293', '\x3', '\x2', '\x2', '\x2', 
		'\x295', '\x296', '\x3', '\x2', '\x2', '\x2', '\x296', '\x33', '\x3', 
		'\x2', '\x2', '\x2', '\x297', '\x295', '\x3', '\x2', '\x2', '\x2', '\x298', 
		'\x29F', '\x5', '\b', '\x5', '\x2', '\x299', '\x29A', '\a', '\x253', '\x2', 
		'\x2', '\x29A', '\x29D', '\x5', '\b', '\x5', '\x2', '\x29B', '\x29C', 
		'\a', '\x253', '\x2', '\x2', '\x29C', '\x29E', '\x5', '\b', '\x5', '\x2', 
		'\x29D', '\x29B', '\x3', '\x2', '\x2', '\x2', '\x29D', '\x29E', '\x3', 
		'\x2', '\x2', '\x2', '\x29E', '\x2A0', '\x3', '\x2', '\x2', '\x2', '\x29F', 
		'\x299', '\x3', '\x2', '\x2', '\x2', '\x29F', '\x2A0', '\x3', '\x2', '\x2', 
		'\x2', '\x2A0', '\x35', '\x3', '\x2', '\x2', '\x2', '\x2A1', '\x2A6', 
		'\x5', '\x38', '\x1D', '\x2', '\x2A2', '\x2A3', '\a', '\x245', '\x2', 
		'\x2', '\x2A3', '\x2A5', '\x5', '\x38', '\x1D', '\x2', '\x2A4', '\x2A2', 
		'\x3', '\x2', '\x2', '\x2', '\x2A5', '\x2A8', '\x3', '\x2', '\x2', '\x2', 
		'\x2A6', '\x2A4', '\x3', '\x2', '\x2', '\x2', '\x2A6', '\x2A7', '\x3', 
		'\x2', '\x2', '\x2', '\x2A7', '\x37', '\x3', '\x2', '\x2', '\x2', '\x2A8', 
		'\x2A6', '\x3', '\x2', '\x2', '\x2', '\x2A9', '\x2AD', '\x5', '\x142', 
		'\xA2', '\x2', '\x2AA', '\x2AB', '\a', '\x176', '\x2', '\x2', '\x2AB', 
		'\x2AE', '\x5', ':', '\x1E', '\x2', '\x2AC', '\x2AE', '\x5', '\x6', '\x4', 
		'\x2', '\x2AD', '\x2AA', '\x3', '\x2', '\x2', '\x2', '\x2AD', '\x2AC', 
		'\x3', '\x2', '\x2', '\x2', '\x2AD', '\x2AE', '\x3', '\x2', '\x2', '\x2', 
		'\x2AE', '\x39', '\x3', '\x2', '\x2', '\x2', '\x2AF', '\x2B4', '\x5', 
		'\x6', '\x4', '\x2', '\x2B0', '\x2B4', '\x5', '\x14A', '\xA6', '\x2', 
		'\x2B1', '\x2B4', '\x5', '\x144', '\xA3', '\x2', '\x2B2', '\x2B4', '\x5', 
		'\x146', '\xA4', '\x2', '\x2B3', '\x2AF', '\x3', '\x2', '\x2', '\x2', 
		'\x2B3', '\x2B0', '\x3', '\x2', '\x2', '\x2', '\x2B3', '\x2B1', '\x3', 
		'\x2', '\x2', '\x2', '\x2B3', '\x2B2', '\x3', '\x2', '\x2', '\x2', '\x2B4', 
		';', '\x3', '\x2', '\x2', '\x2', '\x2B5', '\x2B6', '\a', '\x195', '\x2', 
		'\x2', '\x2B6', '\x2B7', '\a', '\x16', '\x2', '\x2', '\x2B7', '\x2B8', 
		'\x5', '>', ' ', '\x2', '\x2B8', '=', '\x3', '\x2', '\x2', '\x2', '\x2B9', 
		'\x2BE', '\x5', '@', '!', '\x2', '\x2BA', '\x2BB', '\a', '\x245', '\x2', 
		'\x2', '\x2BB', '\x2BD', '\x5', '@', '!', '\x2', '\x2BC', '\x2BA', '\x3', 
		'\x2', '\x2', '\x2', '\x2BD', '\x2C0', '\x3', '\x2', '\x2', '\x2', '\x2BE', 
		'\x2BC', '\x3', '\x2', '\x2', '\x2', '\x2BE', '\x2BF', '\x3', '\x2', '\x2', 
		'\x2', '\x2BF', '?', '\x3', '\x2', '\x2', '\x2', '\x2C0', '\x2BE', '\x3', 
		'\x2', '\x2', '\x2', '\x2C1', '\x2CF', '\x5', '\x142', '\xA2', '\x2', 
		'\x2C2', '\x2C3', '\a', '\x24B', '\x2', '\x2', '\x2C3', '\x2CF', '\a', 
		'\x24C', '\x2', '\x2', '\x2C4', '\x2C9', '\a', '\xD5', '\x2', '\x2', '\x2C5', 
		'\x2C9', '\a', '\x32', '\x2', '\x2', '\x2C6', '\x2C7', '\a', '\x134', 
		'\x2', '\x2', '\x2C7', '\x2C9', '\a', '\xE7', '\x2', '\x2', '\x2C8', '\x2C4', 
		'\x3', '\x2', '\x2', '\x2', '\x2C8', '\x2C5', '\x3', '\x2', '\x2', '\x2', 
		'\x2C8', '\x2C6', '\x3', '\x2', '\x2', '\x2', '\x2C9', '\x2CA', '\x3', 
		'\x2', '\x2', '\x2', '\x2CA', '\x2CB', '\a', '\x24B', '\x2', '\x2', '\x2CB', 
		'\x2CC', '\x5', '>', ' ', '\x2', '\x2CC', '\x2CD', '\a', '\x24C', '\x2', 
		'\x2', '\x2CD', '\x2CF', '\x3', '\x2', '\x2', '\x2', '\x2CE', '\x2C1', 
		'\x3', '\x2', '\x2', '\x2', '\x2CE', '\x2C2', '\x3', '\x2', '\x2', '\x2', 
		'\x2CE', '\x2C8', '\x3', '\x2', '\x2', '\x2', '\x2CF', '\x41', '\x3', 
		'\x2', '\x2', '\x2', '\x2D0', '\x2D1', '\b', '\"', '\x1', '\x2', '\x2D1', 
		'\x2D2', '\a', '\x24B', '\x2', '\x2', '\x2D2', '\x2D3', '\x5', '\x42', 
		'\"', '\x2', '\x2D3', '\x2D5', '\a', '\x24C', '\x2', '\x2', '\x2D4', '\x2D6', 
		'\x5', 'x', '=', '\x2', '\x2D5', '\x2D4', '\x3', '\x2', '\x2', '\x2', 
		'\x2D5', '\x2D6', '\x3', '\x2', '\x2', '\x2', '\x2D6', '\x2D9', '\x3', 
		'\x2', '\x2', '\x2', '\x2D7', '\x2D9', '\x5', '\x44', '#', '\x2', '\x2D8', 
		'\x2D0', '\x3', '\x2', '\x2', '\x2', '\x2D8', '\x2D7', '\x3', '\x2', '\x2', 
		'\x2', '\x2D9', '\x305', '\x3', '\x2', '\x2', '\x2', '\x2DA', '\x2DB', 
		'\f', '\a', '\x2', '\x2', '\x2DB', '\x2DC', '\a', '\x15D', '\x2', '\x2', 
		'\x2DC', '\x2DD', '\a', '\x165', '\x2', '\x2', '\x2DD', '\x304', '\x5', 
		'\x42', '\"', '\b', '\x2DE', '\x2DF', '\f', '\x4', '\x2', '\x2', '\x2DF', 
		'\x2E5', '\a', '\x168', '\x2', '\x2', '\x2E0', '\x2E6', '\a', '\x162', 
		'\x2', '\x2', '\x2E1', '\x2E3', '\t', '\t', '\x2', '\x2', '\x2E2', '\x2E4', 
		'\a', '\x16A', '\x2', '\x2', '\x2E3', '\x2E2', '\x3', '\x2', '\x2', '\x2', 
		'\x2E3', '\x2E4', '\x3', '\x2', '\x2', '\x2', '\x2E4', '\x2E6', '\x3', 
		'\x2', '\x2', '\x2', '\x2E5', '\x2E0', '\x3', '\x2', '\x2', '\x2', '\x2E5', 
		'\x2E1', '\x3', '\x2', '\x2', '\x2', '\x2E5', '\x2E6', '\x3', '\x2', '\x2', 
		'\x2', '\x2E6', '\x2E7', '\x3', '\x2', '\x2', '\x2', '\x2E7', '\x2E8', 
		'\a', '\x165', '\x2', '\x2', '\x2E8', '\x304', '\x5', '\x42', '\"', '\x5', 
		'\x2E9', '\x2EF', '\f', '\x6', '\x2', '\x2', '\x2EA', '\x2F0', '\a', '\x162', 
		'\x2', '\x2', '\x2EB', '\x2ED', '\t', '\t', '\x2', '\x2', '\x2EC', '\x2EE', 
		'\a', '\x16A', '\x2', '\x2', '\x2ED', '\x2EC', '\x3', '\x2', '\x2', '\x2', 
		'\x2ED', '\x2EE', '\x3', '\x2', '\x2', '\x2', '\x2EE', '\x2F0', '\x3', 
		'\x2', '\x2', '\x2', '\x2EF', '\x2EA', '\x3', '\x2', '\x2', '\x2', '\x2EF', 
		'\x2EB', '\x3', '\x2', '\x2', '\x2', '\x2EF', '\x2F0', '\x3', '\x2', '\x2', 
		'\x2', '\x2F0', '\x2F1', '\x3', '\x2', '\x2', '\x2', '\x2F1', '\x2F2', 
		'\a', '\x165', '\x2', '\x2', '\x2F2', '\x2F3', '\x5', '\x42', '\"', '\x2', 
		'\x2F3', '\x2F4', '\a', '\x1A3', '\x2', '\x2', '\x2F4', '\x2F5', '\x5', 
		'\x142', '\xA2', '\x2', '\x2F5', '\x304', '\x3', '\x2', '\x2', '\x2', 
		'\x2F6', '\x2FC', '\f', '\x5', '\x2', '\x2', '\x2F7', '\x2FD', '\a', '\x162', 
		'\x2', '\x2', '\x2F8', '\x2FA', '\t', '\t', '\x2', '\x2', '\x2F9', '\x2FB', 
		'\a', '\x16A', '\x2', '\x2', '\x2FA', '\x2F9', '\x3', '\x2', '\x2', '\x2', 
		'\x2FA', '\x2FB', '\x3', '\x2', '\x2', '\x2', '\x2FB', '\x2FD', '\x3', 
		'\x2', '\x2', '\x2', '\x2FC', '\x2F7', '\x3', '\x2', '\x2', '\x2', '\x2FC', 
		'\x2F8', '\x3', '\x2', '\x2', '\x2', '\x2FC', '\x2FD', '\x3', '\x2', '\x2', 
		'\x2', '\x2FD', '\x2FE', '\x3', '\x2', '\x2', '\x2', '\x2FE', '\x2FF', 
		'\a', '\x165', '\x2', '\x2', '\x2FF', '\x300', '\x5', '\x42', '\"', '\x2', 
		'\x300', '\x301', '\a', '\x1B7', '\x2', '\x2', '\x301', '\x302', '\x5', 
		't', ';', '\x2', '\x302', '\x304', '\x3', '\x2', '\x2', '\x2', '\x303', 
		'\x2DA', '\x3', '\x2', '\x2', '\x2', '\x303', '\x2DE', '\x3', '\x2', '\x2', 
		'\x2', '\x303', '\x2E9', '\x3', '\x2', '\x2', '\x2', '\x303', '\x2F6', 
		'\x3', '\x2', '\x2', '\x2', '\x304', '\x307', '\x3', '\x2', '\x2', '\x2', 
		'\x305', '\x303', '\x3', '\x2', '\x2', '\x2', '\x305', '\x306', '\x3', 
		'\x2', '\x2', '\x2', '\x306', '\x43', '\x3', '\x2', '\x2', '\x2', '\x307', 
		'\x305', '\x3', '\x2', '\x2', '\x2', '\x308', '\x30A', '\a', '\x1A4', 
		'\x2', '\x2', '\x309', '\x308', '\x3', '\x2', '\x2', '\x2', '\x309', '\x30A', 
		'\x3', '\x2', '\x2', '\x2', '\x30A', '\x30B', '\x3', '\x2', '\x2', '\x2', 
		'\x30B', '\x30D', '\x5', '\x34', '\x1B', '\x2', '\x30C', '\x30E', '\a', 
		'\x24F', '\x2', '\x2', '\x30D', '\x30C', '\x3', '\x2', '\x2', '\x2', '\x30D', 
		'\x30E', '\x3', '\x2', '\x2', '\x2', '\x30E', '\x310', '\x3', '\x2', '\x2', 
		'\x2', '\x30F', '\x311', '\x5', 'x', '=', '\x2', '\x310', '\x30F', '\x3', 
		'\x2', '\x2', '\x2', '\x310', '\x311', '\x3', '\x2', '\x2', '\x2', '\x311', 
		'\x322', '\x3', '\x2', '\x2', '\x2', '\x312', '\x313', '\a', '\x16E', 
		'\x2', '\x2', '\x313', '\x314', '\x5', '\b', '\x5', '\x2', '\x314', '\x315', 
		'\a', '\x24B', '\x2', '\x2', '\x315', '\x31A', '\x5', '\x142', '\xA2', 
		'\x2', '\x316', '\x317', '\a', '\x245', '\x2', '\x2', '\x317', '\x319', 
		'\x5', '\x142', '\xA2', '\x2', '\x318', '\x316', '\x3', '\x2', '\x2', 
		'\x2', '\x319', '\x31C', '\x3', '\x2', '\x2', '\x2', '\x31A', '\x318', 
		'\x3', '\x2', '\x2', '\x2', '\x31A', '\x31B', '\x3', '\x2', '\x2', '\x2', 
		'\x31B', '\x31D', '\x3', '\x2', '\x2', '\x2', '\x31C', '\x31A', '\x3', 
		'\x2', '\x2', '\x2', '\x31D', '\x320', '\a', '\x24C', '\x2', '\x2', '\x31E', 
		'\x31F', '\a', '\xCB', '\x2', '\x2', '\x31F', '\x321', '\x5', '\x142', 
		'\xA2', '\x2', '\x320', '\x31E', '\x3', '\x2', '\x2', '\x2', '\x320', 
		'\x321', '\x3', '\x2', '\x2', '\x2', '\x321', '\x323', '\x3', '\x2', '\x2', 
		'\x2', '\x322', '\x312', '\x3', '\x2', '\x2', '\x2', '\x322', '\x323', 
		'\x3', '\x2', '\x2', '\x2', '\x323', '\x377', '\x3', '\x2', '\x2', '\x2', 
		'\x324', '\x326', '\a', '\x19B', '\x2', '\x2', '\x325', '\x324', '\x3', 
		'\x2', '\x2', '\x2', '\x325', '\x326', '\x3', '\x2', '\x2', '\x2', '\x326', 
		'\x327', '\x3', '\x2', '\x2', '\x2', '\x327', '\x328', '\x5', 'r', ':', 
		'\x2', '\x328', '\x329', '\x5', 'x', '=', '\x2', '\x329', '\x377', '\x3', 
		'\x2', '\x2', '\x2', '\x32A', '\x32C', '\a', '\x19B', '\x2', '\x2', '\x32B', 
		'\x32A', '\x3', '\x2', '\x2', '\x2', '\x32B', '\x32C', '\x3', '\x2', '\x2', 
		'\x2', '\x32C', '\x32D', '\x3', '\x2', '\x2', '\x2', '\x32D', '\x330', 
		'\x5', 'X', '-', '\x2', '\x32E', '\x32F', '\a', '\x1BC', '\x2', '\x2', 
		'\x32F', '\x331', '\a', '\xA5', '\x2', '\x2', '\x330', '\x32E', '\x3', 
		'\x2', '\x2', '\x2', '\x330', '\x331', '\x3', '\x2', '\x2', '\x2', '\x331', 
		'\x346', '\x3', '\x2', '\x2', '\x2', '\x332', '\x333', '\a', '\x176', 
		'\x2', '\x2', '\x333', '\x347', '\x5', '\x46', '$', '\x2', '\x334', '\x336', 
		'\a', '\x176', '\x2', '\x2', '\x335', '\x334', '\x3', '\x2', '\x2', '\x2', 
		'\x335', '\x336', '\x3', '\x2', '\x2', '\x2', '\x336', '\x337', '\x3', 
		'\x2', '\x2', '\x2', '\x337', '\x344', '\x5', '\b', '\x5', '\x2', '\x338', 
		'\x339', '\a', '\x24B', '\x2', '\x2', '\x339', '\x33E', '\x5', '\b', '\x5', 
		'\x2', '\x33A', '\x33B', '\a', '\x245', '\x2', '\x2', '\x33B', '\x33D', 
		'\x5', '\b', '\x5', '\x2', '\x33C', '\x33A', '\x3', '\x2', '\x2', '\x2', 
		'\x33D', '\x340', '\x3', '\x2', '\x2', '\x2', '\x33E', '\x33C', '\x3', 
		'\x2', '\x2', '\x2', '\x33E', '\x33F', '\x3', '\x2', '\x2', '\x2', '\x33F', 
		'\x341', '\x3', '\x2', '\x2', '\x2', '\x340', '\x33E', '\x3', '\x2', '\x2', 
		'\x2', '\x341', '\x342', '\a', '\x24C', '\x2', '\x2', '\x342', '\x345', 
		'\x3', '\x2', '\x2', '\x2', '\x343', '\x345', '\x5', '\x46', '$', '\x2', 
		'\x344', '\x338', '\x3', '\x2', '\x2', '\x2', '\x344', '\x343', '\x3', 
		'\x2', '\x2', '\x2', '\x344', '\x345', '\x3', '\x2', '\x2', '\x2', '\x345', 
		'\x347', '\x3', '\x2', '\x2', '\x2', '\x346', '\x332', '\x3', '\x2', '\x2', 
		'\x2', '\x346', '\x335', '\x3', '\x2', '\x2', '\x2', '\x346', '\x347', 
		'\x3', '\x2', '\x2', '\x2', '\x347', '\x377', '\x3', '\x2', '\x2', '\x2', 
		'\x348', '\x34A', '\a', '\x19B', '\x2', '\x2', '\x349', '\x348', '\x3', 
		'\x2', '\x2', '\x2', '\x349', '\x34A', '\x3', '\x2', '\x2', '\x2', '\x34A', 
		'\x34B', '\x3', '\x2', '\x2', '\x2', '\x34B', '\x34C', '\a', '\xD8', '\x2', 
		'\x2', '\x34C', '\x34D', '\a', '\x193', '\x2', '\x2', '\x34D', '\x34E', 
		'\a', '\x24B', '\x2', '\x2', '\x34E', '\x351', '\x5', 'X', '-', '\x2', 
		'\x34F', '\x350', '\a', '\x176', '\x2', '\x2', '\x350', '\x352', '\x5', 
		'\x46', '$', '\x2', '\x351', '\x34F', '\x3', '\x2', '\x2', '\x2', '\x351', 
		'\x352', '\x3', '\x2', '\x2', '\x2', '\x352', '\x35B', '\x3', '\x2', '\x2', 
		'\x2', '\x353', '\x354', '\a', '\x245', '\x2', '\x2', '\x354', '\x357', 
		'\x5', 'X', '-', '\x2', '\x355', '\x356', '\a', '\x176', '\x2', '\x2', 
		'\x356', '\x358', '\x5', '\x46', '$', '\x2', '\x357', '\x355', '\x3', 
		'\x2', '\x2', '\x2', '\x357', '\x358', '\x3', '\x2', '\x2', '\x2', '\x358', 
		'\x35A', '\x3', '\x2', '\x2', '\x2', '\x359', '\x353', '\x3', '\x2', '\x2', 
		'\x2', '\x35A', '\x35D', '\x3', '\x2', '\x2', '\x2', '\x35B', '\x359', 
		'\x3', '\x2', '\x2', '\x2', '\x35B', '\x35C', '\x3', '\x2', '\x2', '\x2', 
		'\x35C', '\x35E', '\x3', '\x2', '\x2', '\x2', '\x35D', '\x35B', '\x3', 
		'\x2', '\x2', '\x2', '\x35E', '\x361', '\a', '\x24C', '\x2', '\x2', '\x35F', 
		'\x360', '\a', '\x1BC', '\x2', '\x2', '\x360', '\x362', '\a', '\xA5', 
		'\x2', '\x2', '\x361', '\x35F', '\x3', '\x2', '\x2', '\x2', '\x361', '\x362', 
		'\x3', '\x2', '\x2', '\x2', '\x362', '\x374', '\x3', '\x2', '\x2', '\x2', 
		'\x363', '\x365', '\a', '\x176', '\x2', '\x2', '\x364', '\x363', '\x3', 
		'\x2', '\x2', '\x2', '\x364', '\x365', '\x3', '\x2', '\x2', '\x2', '\x365', 
		'\x366', '\x3', '\x2', '\x2', '\x2', '\x366', '\x372', '\x5', '\b', '\x5', 
		'\x2', '\x367', '\x368', '\a', '\x24B', '\x2', '\x2', '\x368', '\x36D', 
		'\x5', '\b', '\x5', '\x2', '\x369', '\x36A', '\a', '\x245', '\x2', '\x2', 
		'\x36A', '\x36C', '\x5', '\b', '\x5', '\x2', '\x36B', '\x369', '\x3', 
		'\x2', '\x2', '\x2', '\x36C', '\x36F', '\x3', '\x2', '\x2', '\x2', '\x36D', 
		'\x36B', '\x3', '\x2', '\x2', '\x2', '\x36D', '\x36E', '\x3', '\x2', '\x2', 
		'\x2', '\x36E', '\x370', '\x3', '\x2', '\x2', '\x2', '\x36F', '\x36D', 
		'\x3', '\x2', '\x2', '\x2', '\x370', '\x371', '\a', '\x24C', '\x2', '\x2', 
		'\x371', '\x373', '\x3', '\x2', '\x2', '\x2', '\x372', '\x367', '\x3', 
		'\x2', '\x2', '\x2', '\x372', '\x373', '\x3', '\x2', '\x2', '\x2', '\x373', 
		'\x375', '\x3', '\x2', '\x2', '\x2', '\x374', '\x364', '\x3', '\x2', '\x2', 
		'\x2', '\x374', '\x375', '\x3', '\x2', '\x2', '\x2', '\x375', '\x377', 
		'\x3', '\x2', '\x2', '\x2', '\x376', '\x309', '\x3', '\x2', '\x2', '\x2', 
		'\x376', '\x325', '\x3', '\x2', '\x2', '\x2', '\x376', '\x32B', '\x3', 
		'\x2', '\x2', '\x2', '\x376', '\x349', '\x3', '\x2', '\x2', '\x2', '\x377', 
		'\x45', '\x3', '\x2', '\x2', '\x2', '\x378', '\x379', '\a', '\x24B', '\x2', 
		'\x2', '\x379', '\x37A', '\x5', '\b', '\x5', '\x2', '\x37A', '\x381', 
		'\x5', 'H', '%', '\x2', '\x37B', '\x37C', '\a', '\x245', '\x2', '\x2', 
		'\x37C', '\x37D', '\x5', '\b', '\x5', '\x2', '\x37D', '\x37E', '\x5', 
		'H', '%', '\x2', '\x37E', '\x380', '\x3', '\x2', '\x2', '\x2', '\x37F', 
		'\x37B', '\x3', '\x2', '\x2', '\x2', '\x380', '\x383', '\x3', '\x2', '\x2', 
		'\x2', '\x381', '\x37F', '\x3', '\x2', '\x2', '\x2', '\x381', '\x382', 
		'\x3', '\x2', '\x2', '\x2', '\x382', '\x384', '\x3', '\x2', '\x2', '\x2', 
		'\x383', '\x381', '\x3', '\x2', '\x2', '\x2', '\x384', '\x385', '\a', 
		'\x24C', '\x2', '\x2', '\x385', 'G', '\x3', '\x2', '\x2', '\x2', '\x386', 
		'\x388', '\a', '\x145', '\x2', '\x2', '\x387', '\x386', '\x3', '\x2', 
		'\x2', '\x2', '\x387', '\x388', '\x3', '\x2', '\x2', '\x2', '\x388', '\x389', 
		'\x3', '\x2', '\x2', '\x2', '\x389', '\x393', '\x5', 'L', '\'', '\x2', 
		'\x38A', '\x38C', '\a', '\x175', '\x2', '\x2', '\x38B', '\x38D', '\x5', 
		'J', '&', '\x2', '\x38C', '\x38B', '\x3', '\x2', '\x2', '\x2', '\x38C', 
		'\x38D', '\x3', '\x2', '\x2', '\x2', '\x38D', '\x394', '\x3', '\x2', '\x2', 
		'\x2', '\x38E', '\x390', '\x5', 'J', '&', '\x2', '\x38F', '\x38E', '\x3', 
		'\x2', '\x2', '\x2', '\x390', '\x391', '\x3', '\x2', '\x2', '\x2', '\x391', 
		'\x38F', '\x3', '\x2', '\x2', '\x2', '\x391', '\x392', '\x3', '\x2', '\x2', 
		'\x2', '\x392', '\x394', '\x3', '\x2', '\x2', '\x2', '\x393', '\x38A', 
		'\x3', '\x2', '\x2', '\x2', '\x393', '\x38F', '\x3', '\x2', '\x2', '\x2', 
		'\x393', '\x394', '\x3', '\x2', '\x2', '\x2', '\x394', 'I', '\x3', '\x2', 
		'\x2', '\x2', '\x395', '\x397', '\a', '\x257', '\x2', '\x2', '\x396', 
		'\x398', '\a', '\x262', '\x2', '\x2', '\x397', '\x396', '\x3', '\x2', 
		'\x2', '\x2', '\x397', '\x398', '\x3', '\x2', '\x2', '\x2', '\x398', '\x399', 
		'\x3', '\x2', '\x2', '\x2', '\x399', '\x39A', '\a', '\x258', '\x2', '\x2', 
		'\x39A', 'K', '\x3', '\x2', '\x2', '\x2', '\x39B', '\x3F7', '\a', '\x128', 
		'\x2', '\x2', '\x39C', '\x39E', '\a', '\x129', '\x2', '\x2', '\x39D', 
		'\x39F', '\a', '\x118', '\x2', '\x2', '\x39E', '\x39D', '\x3', '\x2', 
		'\x2', '\x2', '\x39E', '\x39F', '\x3', '\x2', '\x2', '\x2', '\x39F', '\x3A1', 
		'\x3', '\x2', '\x2', '\x2', '\x3A0', '\x3A2', '\x5', 'T', '+', '\x2', 
		'\x3A1', '\x3A0', '\x3', '\x2', '\x2', '\x2', '\x3A1', '\x3A2', '\x3', 
		'\x2', '\x2', '\x2', '\x3A2', '\x3F7', '\x3', '\x2', '\x2', '\x2', '\x3A3', 
		'\x3F7', '\a', '\x12A', '\x2', '\x2', '\x3A4', '\x3A6', '\a', '\x12E', 
		'\x2', '\x2', '\x3A5', '\x3A7', '\x5', 'V', ',', '\x2', '\x3A6', '\x3A5', 
		'\x3', '\x2', '\x2', '\x2', '\x3A6', '\x3A7', '\x3', '\x2', '\x2', '\x2', 
		'\x3A7', '\x3F7', '\x3', '\x2', '\x2', '\x2', '\x3A8', '\x3AA', '\a', 
		'\x12F', '\x2', '\x2', '\x3A9', '\x3AB', '\x5', 'V', ',', '\x2', '\x3AA', 
		'\x3A9', '\x3', '\x2', '\x2', '\x2', '\x3AA', '\x3AB', '\x3', '\x2', '\x2', 
		'\x2', '\x3AB', '\x3F7', '\x3', '\x2', '\x2', '\x2', '\x3AC', '\x3AD', 
		'\a', 'H', '\x2', '\x2', '\x3AD', '\x3F7', '\a', '\x142', '\x2', '\x2', 
		'\x3AE', '\x3B0', '\a', '\x132', '\x2', '\x2', '\x3AF', '\x3B1', '\x5', 
		'V', ',', '\x2', '\x3B0', '\x3AF', '\x3', '\x2', '\x2', '\x2', '\x3B0', 
		'\x3B1', '\x3', '\x2', '\x2', '\x2', '\x3B1', '\x3F7', '\x3', '\x2', '\x2', 
		'\x2', '\x3B2', '\x3F7', '\a', '\x136', '\x2', '\x2', '\x3B3', '\x3F7', 
		'\a', '\x137', '\x2', '\x2', '\x3B4', '\x3B6', '\a', '\x138', '\x2', '\x2', 
		'\x3B5', '\x3B7', '\x5', 'R', '*', '\x2', '\x3B6', '\x3B5', '\x3', '\x2', 
		'\x2', '\x2', '\x3B6', '\x3B7', '\x3', '\x2', '\x2', '\x2', '\x3B7', '\x3B9', 
		'\x3', '\x2', '\x2', '\x2', '\x3B8', '\x3BA', '\x5', 'T', '+', '\x2', 
		'\x3B9', '\x3B8', '\x3', '\x2', '\x2', '\x2', '\x3B9', '\x3BA', '\x3', 
		'\x2', '\x2', '\x2', '\x3BA', '\x3F7', '\x3', '\x2', '\x2', '\x2', '\x3BB', 
		'\x3BD', '\a', '\x13A', '\x2', '\x2', '\x3BC', '\x3BB', '\x3', '\x2', 
		'\x2', '\x2', '\x3BC', '\x3BD', '\x3', '\x2', '\x2', '\x2', '\x3BD', '\x3BE', 
		'\x3', '\x2', '\x2', '\x2', '\x3BE', '\x3C0', '\t', '\n', '\x2', '\x2', 
		'\x3BF', '\x3C1', '\a', '\x118', '\x2', '\x2', '\x3C0', '\x3BF', '\x3', 
		'\x2', '\x2', '\x2', '\x3C0', '\x3C1', '\x3', '\x2', '\x2', '\x2', '\x3C1', 
		'\x3C3', '\x3', '\x2', '\x2', '\x2', '\x3C2', '\x3C4', '\x5', 'T', '+', 
		'\x2', '\x3C3', '\x3C2', '\x3', '\x2', '\x2', '\x2', '\x3C3', '\x3C4', 
		'\x3', '\x2', '\x2', '\x2', '\x3C4', '\x3F7', '\x3', '\x2', '\x2', '\x2', 
		'\x3C5', '\x3C7', '\a', '\x13B', '\x2', '\x2', '\x3C6', '\x3C8', '\a', 
		'\x118', '\x2', '\x2', '\x3C7', '\x3C6', '\x3', '\x2', '\x2', '\x2', '\x3C7', 
		'\x3C8', '\x3', '\x2', '\x2', '\x2', '\x3C8', '\x3CA', '\x3', '\x2', '\x2', 
		'\x2', '\x3C9', '\x3CB', '\x5', 'T', '+', '\x2', '\x3CA', '\x3C9', '\x3', 
		'\x2', '\x2', '\x2', '\x3CA', '\x3CB', '\x3', '\x2', '\x2', '\x2', '\x3CB', 
		'\x3F7', '\x3', '\x2', '\x2', '\x2', '\x3CC', '\x3CE', '\a', '\x13E', 
		'\x2', '\x2', '\x3CD', '\x3CF', '\x5', 'V', ',', '\x2', '\x3CE', '\x3CD', 
		'\x3', '\x2', '\x2', '\x2', '\x3CE', '\x3CF', '\x3', '\x2', '\x2', '\x2', 
		'\x3CF', '\x3F7', '\x3', '\x2', '\x2', '\x2', '\x3D0', '\x3F7', '\a', 
		'\x143', '\x2', '\x2', '\x3D1', '\x3F7', '\a', '\x146', '\x2', '\x2', 
		'\x3D2', '\x3D4', '\a', '\x148', '\x2', '\x2', '\x3D3', '\x3D5', '\x5', 
		'T', '+', '\x2', '\x3D4', '\x3D3', '\x3', '\x2', '\x2', '\x2', '\x3D4', 
		'\x3D5', '\x3', '\x2', '\x2', '\x2', '\x3D5', '\x3D9', '\x3', '\x2', '\x2', 
		'\x2', '\x3D6', '\x3D7', '\t', '\v', '\x2', '\x2', '\x3D7', '\x3D8', '\a', 
		'\x148', '\x2', '\x2', '\x3D8', '\x3DA', '\a', '\x126', '\x2', '\x2', 
		'\x3D9', '\x3D6', '\x3', '\x2', '\x2', '\x2', '\x3D9', '\x3DA', '\x3', 
		'\x2', '\x2', '\x2', '\x3DA', '\x3F7', '\x3', '\x2', '\x2', '\x2', '\x3DB', 
		'\x3DD', '\a', '\x149', '\x2', '\x2', '\x3DC', '\x3DE', '\x5', 'T', '+', 
		'\x2', '\x3DD', '\x3DC', '\x3', '\x2', '\x2', '\x2', '\x3DD', '\x3DE', 
		'\x3', '\x2', '\x2', '\x2', '\x3DE', '\x3E2', '\x3', '\x2', '\x2', '\x2', 
		'\x3DF', '\x3E0', '\t', '\v', '\x2', '\x2', '\x3E0', '\x3E1', '\a', '\x148', 
		'\x2', '\x2', '\x3E1', '\x3E3', '\a', '\x126', '\x2', '\x2', '\x3E2', 
		'\x3DF', '\x3', '\x2', '\x2', '\x2', '\x3E2', '\x3E3', '\x3', '\x2', '\x2', 
		'\x2', '\x3E3', '\x3F7', '\x3', '\x2', '\x2', '\x2', '\x3E4', '\x3E6', 
		'\a', '\x14D', '\x2', '\x2', '\x3E5', '\x3E7', '\x5', 'T', '+', '\x2', 
		'\x3E6', '\x3E5', '\x3', '\x2', '\x2', '\x2', '\x3E6', '\x3E7', '\x3', 
		'\x2', '\x2', '\x2', '\x3E7', '\x3F7', '\x3', '\x2', '\x2', '\x2', '\x3E8', 
		'\x3F4', '\x5', 'N', '(', '\x2', '\x3E9', '\x3EA', '\a', '\x24B', '\x2', 
		'\x2', '\x3EA', '\x3EF', '\x5', '\x142', '\xA2', '\x2', '\x3EB', '\x3EC', 
		'\a', '\x245', '\x2', '\x2', '\x3EC', '\x3EE', '\x5', '\x142', '\xA2', 
		'\x2', '\x3ED', '\x3EB', '\x3', '\x2', '\x2', '\x2', '\x3EE', '\x3F1', 
		'\x3', '\x2', '\x2', '\x2', '\x3EF', '\x3ED', '\x3', '\x2', '\x2', '\x2', 
		'\x3EF', '\x3F0', '\x3', '\x2', '\x2', '\x2', '\x3F0', '\x3F2', '\x3', 
		'\x2', '\x2', '\x2', '\x3F1', '\x3EF', '\x3', '\x2', '\x2', '\x2', '\x3F2', 
		'\x3F3', '\a', '\x24C', '\x2', '\x2', '\x3F3', '\x3F5', '\x3', '\x2', 
		'\x2', '\x2', '\x3F4', '\x3E9', '\x3', '\x2', '\x2', '\x2', '\x3F4', '\x3F5', 
		'\x3', '\x2', '\x2', '\x2', '\x3F5', '\x3F7', '\x3', '\x2', '\x2', '\x2', 
		'\x3F6', '\x39B', '\x3', '\x2', '\x2', '\x2', '\x3F6', '\x39C', '\x3', 
		'\x2', '\x2', '\x2', '\x3F6', '\x3A3', '\x3', '\x2', '\x2', '\x2', '\x3F6', 
		'\x3A4', '\x3', '\x2', '\x2', '\x2', '\x3F6', '\x3A8', '\x3', '\x2', '\x2', 
		'\x2', '\x3F6', '\x3AC', '\x3', '\x2', '\x2', '\x2', '\x3F6', '\x3AE', 
		'\x3', '\x2', '\x2', '\x2', '\x3F6', '\x3B2', '\x3', '\x2', '\x2', '\x2', 
		'\x3F6', '\x3B3', '\x3', '\x2', '\x2', '\x2', '\x3F6', '\x3B4', '\x3', 
		'\x2', '\x2', '\x2', '\x3F6', '\x3BC', '\x3', '\x2', '\x2', '\x2', '\x3F6', 
		'\x3C5', '\x3', '\x2', '\x2', '\x2', '\x3F6', '\x3CC', '\x3', '\x2', '\x2', 
		'\x2', '\x3F6', '\x3D0', '\x3', '\x2', '\x2', '\x2', '\x3F6', '\x3D1', 
		'\x3', '\x2', '\x2', '\x2', '\x3F6', '\x3D2', '\x3', '\x2', '\x2', '\x2', 
		'\x3F6', '\x3DB', '\x3', '\x2', '\x2', '\x2', '\x3F6', '\x3E4', '\x3', 
		'\x2', '\x2', '\x2', '\x3F6', '\x3E8', '\x3', '\x2', '\x2', '\x2', '\x3F7', 
		'M', '\x3', '\x2', '\x2', '\x2', '\x3F8', '\x3FE', '\x5', 'P', ')', '\x2', 
		'\x3F9', '\x3FA', '\x5', '\b', '\x5', '\x2', '\x3FA', '\x3FB', '\a', '\x253', 
		'\x2', '\x2', '\x3FB', '\x3FC', '\x5', 'P', ')', '\x2', '\x3FC', '\x3FE', 
		'\x3', '\x2', '\x2', '\x2', '\x3FD', '\x3F8', '\x3', '\x2', '\x2', '\x2', 
		'\x3FD', '\x3F9', '\x3', '\x2', '\x2', '\x2', '\x3FE', 'O', '\x3', '\x2', 
		'\x2', '\x2', '\x3FF', '\x403', '\x5', '\x6', '\x4', '\x2', '\x400', '\x403', 
		'\x5', '\x144', '\xA3', '\x2', '\x401', '\x403', '\x5', '\x148', '\xA5', 
		'\x2', '\x402', '\x3FF', '\x3', '\x2', '\x2', '\x2', '\x402', '\x400', 
		'\x3', '\x2', '\x2', '\x2', '\x402', '\x401', '\x3', '\x2', '\x2', '\x2', 
		'\x403', 'Q', '\x3', '\x2', '\x2', '\x2', '\x404', '\x420', '\a', '\x124', 
		'\x2', '\x2', '\x405', '\x420', '\a', '\x92', '\x2', '\x2', '\x406', '\x420', 
		'\a', '\x38', '\x2', '\x2', '\x407', '\x420', '\a', 'g', '\x2', '\x2', 
		'\x408', '\x420', '\a', '\x8F', '\x2', '\x2', '\x409', '\x420', '\a', 
		'\xDF', '\x2', '\x2', '\x40A', '\x40B', '\a', '\x124', '\x2', '\x2', '\x40B', 
		'\x40C', '\a', '\x1B1', '\x2', '\x2', '\x40C', '\x420', '\a', '\x92', 
		'\x2', '\x2', '\x40D', '\x40E', '\a', '\x38', '\x2', '\x2', '\x40E', '\x40F', 
		'\a', '\x1B1', '\x2', '\x2', '\x40F', '\x420', '\a', 'g', '\x2', '\x2', 
		'\x410', '\x411', '\a', '\x38', '\x2', '\x2', '\x411', '\x412', '\a', 
		'\x1B1', '\x2', '\x2', '\x412', '\x420', '\a', '\x8F', '\x2', '\x2', '\x413', 
		'\x414', '\a', '\x38', '\x2', '\x2', '\x414', '\x415', '\a', '\x1B1', 
		'\x2', '\x2', '\x415', '\x420', '\a', '\xDF', '\x2', '\x2', '\x416', '\x417', 
		'\a', 'g', '\x2', '\x2', '\x417', '\x418', '\a', '\x1B1', '\x2', '\x2', 
		'\x418', '\x420', '\a', '\x8F', '\x2', '\x2', '\x419', '\x41A', '\a', 
		'g', '\x2', '\x2', '\x41A', '\x41B', '\a', '\x1B1', '\x2', '\x2', '\x41B', 
		'\x420', '\a', '\xDF', '\x2', '\x2', '\x41C', '\x41D', '\a', '\x8F', '\x2', 
		'\x2', '\x41D', '\x41E', '\a', '\x1B1', '\x2', '\x2', '\x41E', '\x420', 
		'\a', '\xDF', '\x2', '\x2', '\x41F', '\x404', '\x3', '\x2', '\x2', '\x2', 
		'\x41F', '\x405', '\x3', '\x2', '\x2', '\x2', '\x41F', '\x406', '\x3', 
		'\x2', '\x2', '\x2', '\x41F', '\x407', '\x3', '\x2', '\x2', '\x2', '\x41F', 
		'\x408', '\x3', '\x2', '\x2', '\x2', '\x41F', '\x409', '\x3', '\x2', '\x2', 
		'\x2', '\x41F', '\x40A', '\x3', '\x2', '\x2', '\x2', '\x41F', '\x40D', 
		'\x3', '\x2', '\x2', '\x2', '\x41F', '\x410', '\x3', '\x2', '\x2', '\x2', 
		'\x41F', '\x413', '\x3', '\x2', '\x2', '\x2', '\x41F', '\x416', '\x3', 
		'\x2', '\x2', '\x2', '\x41F', '\x419', '\x3', '\x2', '\x2', '\x2', '\x41F', 
		'\x41C', '\x3', '\x2', '\x2', '\x2', '\x420', 'S', '\x3', '\x2', '\x2', 
		'\x2', '\x421', '\x422', '\a', '\x24B', '\x2', '\x2', '\x422', '\x423', 
		'\a', '\x262', '\x2', '\x2', '\x423', '\x424', '\a', '\x24C', '\x2', '\x2', 
		'\x424', 'U', '\x3', '\x2', '\x2', '\x2', '\x425', '\x426', '\a', '\x24B', 
		'\x2', '\x2', '\x426', '\x429', '\a', '\x262', '\x2', '\x2', '\x427', 
		'\x428', '\a', '\x245', '\x2', '\x2', '\x428', '\x42A', '\a', '\x262', 
		'\x2', '\x2', '\x429', '\x427', '\x3', '\x2', '\x2', '\x2', '\x429', '\x42A', 
		'\x3', '\x2', '\x2', '\x2', '\x42A', '\x42B', '\x3', '\x2', '\x2', '\x2', 
		'\x42B', '\x42C', '\a', '\x24C', '\x2', '\x2', '\x42C', 'W', '\x3', '\x2', 
		'\x2', '\x2', '\x42D', '\x42E', '\x5', 'N', '(', '\x2', '\x42E', '\x43D', 
		'\a', '\x24B', '\x2', '\x2', '\x42F', '\x431', '\x5', '|', '?', '\x2', 
		'\x430', '\x42F', '\x3', '\x2', '\x2', '\x2', '\x430', '\x431', '\x3', 
		'\x2', '\x2', '\x2', '\x431', '\x432', '\x3', '\x2', '\x2', '\x2', '\x432', 
		'\x437', '\x5', 'n', '\x38', '\x2', '\x433', '\x434', '\a', '\x245', '\x2', 
		'\x2', '\x434', '\x436', '\x5', 'n', '\x38', '\x2', '\x435', '\x433', 
		'\x3', '\x2', '\x2', '\x2', '\x436', '\x439', '\x3', '\x2', '\x2', '\x2', 
		'\x437', '\x435', '\x3', '\x2', '\x2', '\x2', '\x437', '\x438', '\x3', 
		'\x2', '\x2', '\x2', '\x438', '\x43B', '\x3', '\x2', '\x2', '\x2', '\x439', 
		'\x437', '\x3', '\x2', '\x2', '\x2', '\x43A', '\x43C', '\x5', '\x1E', 
		'\x10', '\x2', '\x43B', '\x43A', '\x3', '\x2', '\x2', '\x2', '\x43B', 
		'\x43C', '\x3', '\x2', '\x2', '\x2', '\x43C', '\x43E', '\x3', '\x2', '\x2', 
		'\x2', '\x43D', '\x430', '\x3', '\x2', '\x2', '\x2', '\x43D', '\x43E', 
		'\x3', '\x2', '\x2', '\x2', '\x43E', '\x43F', '\x3', '\x2', '\x2', '\x2', 
		'\x43F', '\x446', '\a', '\x24C', '\x2', '\x2', '\x440', '\x441', '\a', 
		'\x11E', '\x2', '\x2', '\x441', '\x442', '\a', '\x195', '\x2', '\x2', 
		'\x442', '\x443', '\a', '\x24B', '\x2', '\x2', '\x443', '\x444', '\x5', 
		'\x1E', '\x10', '\x2', '\x444', '\x445', '\a', '\x24C', '\x2', '\x2', 
		'\x445', '\x447', '\x3', '\x2', '\x2', '\x2', '\x446', '\x440', '\x3', 
		'\x2', '\x2', '\x2', '\x446', '\x447', '\x3', '\x2', '\x2', '\x2', '\x447', 
		'\x449', '\x3', '\x2', '\x2', '\x2', '\x448', '\x44A', '\x5', 'l', '\x37', 
		'\x2', '\x449', '\x448', '\x3', '\x2', '\x2', '\x2', '\x449', '\x44A', 
		'\x3', '\x2', '\x2', '\x2', '\x44A', '\x450', '\x3', '\x2', '\x2', '\x2', 
		'\x44B', '\x44E', '\a', '\xA7', '\x2', '\x2', '\x44C', '\x44F', '\x5', 
		'\b', '\x5', '\x2', '\x44D', '\x44F', '\x5', '\x18', '\r', '\x2', '\x44E', 
		'\x44C', '\x3', '\x2', '\x2', '\x2', '\x44E', '\x44D', '\x3', '\x2', '\x2', 
		'\x2', '\x44F', '\x451', '\x3', '\x2', '\x2', '\x2', '\x450', '\x44B', 
		'\x3', '\x2', '\x2', '\x2', '\x450', '\x451', '\x3', '\x2', '\x2', '\x2', 
		'\x451', '\x459', '\x3', '\x2', '\x2', '\x2', '\x452', '\x459', '\x5', 
		'j', '\x36', '\x2', '\x453', '\x459', '\x5', '\x66', '\x34', '\x2', '\x454', 
		'\x459', '\x5', '\x62', '\x32', '\x2', '\x455', '\x459', '\x5', '`', '\x31', 
		'\x2', '\x456', '\x459', '\x5', '^', '\x30', '\x2', '\x457', '\x459', 
		'\x5', 'Z', '.', '\x2', '\x458', '\x42D', '\x3', '\x2', '\x2', '\x2', 
		'\x458', '\x452', '\x3', '\x2', '\x2', '\x2', '\x458', '\x453', '\x3', 
		'\x2', '\x2', '\x2', '\x458', '\x454', '\x3', '\x2', '\x2', '\x2', '\x458', 
		'\x455', '\x3', '\x2', '\x2', '\x2', '\x458', '\x456', '\x3', '\x2', '\x2', 
		'\x2', '\x458', '\x457', '\x3', '\x2', '\x2', '\x2', '\x459', 'Y', '\x3', 
		'\x2', '\x2', '\x2', '\x45A', '\x45B', '\a', '\x150', '\x2', '\x2', '\x45B', 
		'\x45C', '\a', '\x24B', '\x2', '\x2', '\x45C', '\x45D', '\a', '\x94', 
		'\x2', '\x2', '\x45D', '\x473', '\x5', '\b', '\x5', '\x2', '\x45E', '\x45F', 
		'\a', '\x245', '\x2', '\x2', '\x45F', '\x460', '\a', '\x14E', '\x2', '\x2', 
		'\x460', '\x461', '\a', '\x24B', '\x2', '\x2', '\x461', '\x464', '\x5', 
		'\x142', '\xA2', '\x2', '\x462', '\x463', '\a', '\x176', '\x2', '\x2', 
		'\x463', '\x465', '\x5', '\b', '\x5', '\x2', '\x464', '\x462', '\x3', 
		'\x2', '\x2', '\x2', '\x464', '\x465', '\x3', '\x2', '\x2', '\x2', '\x465', 
		'\x46E', '\x3', '\x2', '\x2', '\x2', '\x466', '\x467', '\a', '\x245', 
		'\x2', '\x2', '\x467', '\x46A', '\x5', '\x142', '\xA2', '\x2', '\x468', 
		'\x469', '\a', '\x176', '\x2', '\x2', '\x469', '\x46B', '\x5', '\b', '\x5', 
		'\x2', '\x46A', '\x468', '\x3', '\x2', '\x2', '\x2', '\x46A', '\x46B', 
		'\x3', '\x2', '\x2', '\x2', '\x46B', '\x46D', '\x3', '\x2', '\x2', '\x2', 
		'\x46C', '\x466', '\x3', '\x2', '\x2', '\x2', '\x46D', '\x470', '\x3', 
		'\x2', '\x2', '\x2', '\x46E', '\x46C', '\x3', '\x2', '\x2', '\x2', '\x46E', 
		'\x46F', '\x3', '\x2', '\x2', '\x2', '\x46F', '\x471', '\x3', '\x2', '\x2', 
		'\x2', '\x470', '\x46E', '\x3', '\x2', '\x2', '\x2', '\x471', '\x472', 
		'\a', '\x24C', '\x2', '\x2', '\x472', '\x474', '\x3', '\x2', '\x2', '\x2', 
		'\x473', '\x45E', '\x3', '\x2', '\x2', '\x2', '\x473', '\x474', '\x3', 
		'\x2', '\x2', '\x2', '\x474', '\x479', '\x3', '\x2', '\x2', '\x2', '\x475', 
		'\x476', '\a', '\x245', '\x2', '\x2', '\x476', '\x478', '\x5', '\x142', 
		'\xA2', '\x2', '\x477', '\x475', '\x3', '\x2', '\x2', '\x2', '\x478', 
		'\x47B', '\x3', '\x2', '\x2', '\x2', '\x479', '\x477', '\x3', '\x2', '\x2', 
		'\x2', '\x479', '\x47A', '\x3', '\x2', '\x2', '\x2', '\x47A', '\x47C', 
		'\x3', '\x2', '\x2', '\x2', '\x47B', '\x479', '\x3', '\x2', '\x2', '\x2', 
		'\x47C', '\x47D', '\a', '\x24C', '\x2', '\x2', '\x47D', '\x4FC', '\x3', 
		'\x2', '\x2', '\x2', '\x47E', '\x47F', '\a', '\x152', '\x2', '\x2', '\x47F', 
		'\x480', '\a', '\x24B', '\x2', '\x2', '\x480', '\x483', '\x5', '\x142', 
		'\xA2', '\x2', '\x481', '\x482', '\a', '\x176', '\x2', '\x2', '\x482', 
		'\x484', '\x5', '\b', '\x5', '\x2', '\x483', '\x481', '\x3', '\x2', '\x2', 
		'\x2', '\x483', '\x484', '\x3', '\x2', '\x2', '\x2', '\x484', '\x48D', 
		'\x3', '\x2', '\x2', '\x2', '\x485', '\x486', '\a', '\x245', '\x2', '\x2', 
		'\x486', '\x489', '\x5', '\x142', '\xA2', '\x2', '\x487', '\x488', '\a', 
		'\x176', '\x2', '\x2', '\x488', '\x48A', '\x5', '\b', '\x5', '\x2', '\x489', 
		'\x487', '\x3', '\x2', '\x2', '\x2', '\x489', '\x48A', '\x3', '\x2', '\x2', 
		'\x2', '\x48A', '\x48C', '\x3', '\x2', '\x2', '\x2', '\x48B', '\x485', 
		'\x3', '\x2', '\x2', '\x2', '\x48C', '\x48F', '\x3', '\x2', '\x2', '\x2', 
		'\x48D', '\x48B', '\x3', '\x2', '\x2', '\x2', '\x48D', '\x48E', '\x3', 
		'\x2', '\x2', '\x2', '\x48E', '\x490', '\x3', '\x2', '\x2', '\x2', '\x48F', 
		'\x48D', '\x3', '\x2', '\x2', '\x2', '\x490', '\x491', '\a', '\x24C', 
		'\x2', '\x2', '\x491', '\x4FC', '\x3', '\x2', '\x2', '\x2', '\x492', '\x493', 
		'\a', '\x155', '\x2', '\x2', '\x493', '\x494', '\a', '\x24B', '\x2', '\x2', 
		'\x494', '\x495', '\a', '\x94', '\x2', '\x2', '\x495', '\x498', '\x5', 
		'\b', '\x5', '\x2', '\x496', '\x497', '\a', '\x245', '\x2', '\x2', '\x497', 
		'\x499', '\x5', '\x142', '\xA2', '\x2', '\x498', '\x496', '\x3', '\x2', 
		'\x2', '\x2', '\x498', '\x499', '\x3', '\x2', '\x2', '\x2', '\x499', '\x49A', 
		'\x3', '\x2', '\x2', '\x2', '\x49A', '\x49B', '\a', '\x24C', '\x2', '\x2', 
		'\x49B', '\x4FC', '\x3', '\x2', '\x2', '\x2', '\x49C', '\x49D', '\a', 
		'\x156', '\x2', '\x2', '\x49D', '\x49E', '\a', '\x24B', '\x2', '\x2', 
		'\x49E', '\x49F', '\x5', '\x142', '\xA2', '\x2', '\x49F', '\x4A0', '\a', 
		'\x245', '\x2', '\x2', '\x4A0', '\x4A4', '\a', '\x119', '\x2', '\x2', 
		'\x4A1', '\x4A5', '\x5', '\x142', '\xA2', '\x2', '\x4A2', '\x4A3', '\a', 
		'\x98', '\x2', '\x2', '\x4A3', '\x4A5', '\a', '\x117', '\x2', '\x2', '\x4A4', 
		'\x4A1', '\x3', '\x2', '\x2', '\x2', '\x4A4', '\x4A2', '\x3', '\x2', '\x2', 
		'\x2', '\x4A5', '\x4AE', '\x3', '\x2', '\x2', '\x2', '\x4A6', '\x4A7', 
		'\a', '\x245', '\x2', '\x2', '\x4A7', '\x4AC', '\a', '\xEF', '\x2', '\x2', 
		'\x4A8', '\x4AD', '\a', '\x125', '\x2', '\x2', '\x4A9', '\x4AD', '\a', 
		'\x98', '\x2', '\x2', '\x4AA', '\x4AB', '\a', '\x98', '\x2', '\x2', '\x4AB', 
		'\x4AD', '\a', '\x117', '\x2', '\x2', '\x4AC', '\x4A8', '\x3', '\x2', 
		'\x2', '\x2', '\x4AC', '\x4A9', '\x3', '\x2', '\x2', '\x2', '\x4AC', '\x4AA', 
		'\x3', '\x2', '\x2', '\x2', '\x4AD', '\x4AF', '\x3', '\x2', '\x2', '\x2', 
		'\x4AE', '\x4A6', '\x3', '\x2', '\x2', '\x2', '\x4AE', '\x4AF', '\x3', 
		'\x2', '\x2', '\x2', '\x4AF', '\x4B0', '\x3', '\x2', '\x2', '\x2', '\x4B0', 
		'\x4B1', '\a', '\x24C', '\x2', '\x2', '\x4B1', '\x4FC', '\x3', '\x2', 
		'\x2', '\x2', '\x4B2', '\x4B3', '\a', '\x151', '\x2', '\x2', '\x4B3', 
		'\x4B4', '\a', '\x24B', '\x2', '\x2', '\x4B4', '\x4B5', '\x5', '\x142', 
		'\xA2', '\x2', '\x4B5', '\x4B8', '\a', '\xAF', '\x2', '\x2', '\x4B6', 
		'\x4B7', '\a', '\x16', '\x2', '\x2', '\x4B7', '\x4B9', '\a', '\xC4', '\x2', 
		'\x2', '\x4B8', '\x4B6', '\x3', '\x2', '\x2', '\x2', '\x4B8', '\x4B9', 
		'\x3', '\x2', '\x2', '\x2', '\x4B9', '\x4BA', '\x3', '\x2', '\x2', '\x2', 
		'\x4BA', '\x4BD', '\x5', '\x142', '\xA2', '\x2', '\x4BB', '\x4BC', '\a', 
		'\x16', '\x2', '\x2', '\x4BC', '\x4BE', '\a', '\xC4', '\x2', '\x2', '\x4BD', 
		'\x4BB', '\x3', '\x2', '\x2', '\x2', '\x4BD', '\x4BE', '\x3', '\x2', '\x2', 
		'\x2', '\x4BE', '\x4BF', '\x3', '\x2', '\x2', '\x2', '\x4BF', '\x4C0', 
		'\a', '\x24C', '\x2', '\x2', '\x4C0', '\x4FC', '\x3', '\x2', '\x2', '\x2', 
		'\x4C1', '\x4C2', '\a', '\x154', '\x2', '\x2', '\x4C2', '\x4C3', '\a', 
		'\x24B', '\x2', '\x2', '\x4C3', '\x4C4', '\t', '\f', '\x2', '\x2', '\x4C4', 
		'\x4C5', '\x5', '\x142', '\xA2', '\x2', '\x4C5', '\x4C6', '\a', '\x24C', 
		'\x2', '\x2', '\x4C6', '\x4FC', '\x3', '\x2', '\x2', '\x2', '\x4C7', '\x4C8', 
		'\a', '\x157', '\x2', '\x2', '\x4C8', '\x4C9', '\a', '\x24B', '\x2', '\x2', 
		'\x4C9', '\x4CA', '\t', '\f', '\x2', '\x2', '\x4CA', '\x4CB', '\x5', '\x142', 
		'\xA2', '\x2', '\x4CB', '\x4CC', '\a', '\x176', '\x2', '\x2', '\x4CC', 
		'\x4CD', '\x5', 'H', '%', '\x2', '\x4CD', '\x4CE', '\a', '\x24C', '\x2', 
		'\x2', '\x4CE', '\x4FC', '\x3', '\x2', '\x2', '\x2', '\x4CF', '\x4D0', 
		'\a', '\x158', '\x2', '\x2', '\x4D0', '\x4E3', '\a', '\x24B', '\x2', '\x2', 
		'\x4D1', '\x4D2', '\a', '\x153', '\x2', '\x2', '\x4D2', '\x4D3', '\a', 
		'\x24B', '\x2', '\x2', '\x4D3', '\x4D4', '\x5', '\x142', '\xA2', '\x2', 
		'\x4D4', '\x4D5', '\a', '\x176', '\x2', '\x2', '\x4D5', '\x4DD', '\x5', 
		'\b', '\x5', '\x2', '\x4D6', '\x4D7', '\a', '\x245', '\x2', '\x2', '\x4D7', 
		'\x4D8', '\x5', '\x142', '\xA2', '\x2', '\x4D8', '\x4D9', '\a', '\x176', 
		'\x2', '\x2', '\x4D9', '\x4DA', '\x5', '\b', '\x5', '\x2', '\x4DA', '\x4DC', 
		'\x3', '\x2', '\x2', '\x2', '\x4DB', '\x4D6', '\x3', '\x2', '\x2', '\x2', 
		'\x4DC', '\x4DF', '\x3', '\x2', '\x2', '\x2', '\x4DD', '\x4DB', '\x3', 
		'\x2', '\x2', '\x2', '\x4DD', '\x4DE', '\x3', '\x2', '\x2', '\x2', '\x4DE', 
		'\x4E0', '\x3', '\x2', '\x2', '\x2', '\x4DF', '\x4DD', '\x3', '\x2', '\x2', 
		'\x2', '\x4E0', '\x4E1', '\a', '\x24C', '\x2', '\x2', '\x4E1', '\x4E2', 
		'\a', '\x245', '\x2', '\x2', '\x4E2', '\x4E4', '\x3', '\x2', '\x2', '\x2', 
		'\x4E3', '\x4D1', '\x3', '\x2', '\x2', '\x2', '\x4E3', '\x4E4', '\x3', 
		'\x2', '\x2', '\x2', '\x4E4', '\x4E5', '\x3', '\x2', '\x2', '\x2', '\x4E5', 
		'\x4E6', '\x5', '\x142', '\xA2', '\x2', '\x4E6', '\x4E9', '\a', '\xAF', 
		'\x2', '\x2', '\x4E7', '\x4E8', '\a', '\x16', '\x2', '\x2', '\x4E8', '\x4EA', 
		'\a', '\xC4', '\x2', '\x2', '\x4E9', '\x4E7', '\x3', '\x2', '\x2', '\x2', 
		'\x4E9', '\x4EA', '\x3', '\x2', '\x2', '\x2', '\x4EA', '\x4EB', '\x3', 
		'\x2', '\x2', '\x2', '\x4EB', '\x4EE', '\x5', '\x142', '\xA2', '\x2', 
		'\x4EC', '\x4ED', '\a', '\x16', '\x2', '\x2', '\x4ED', '\x4EF', '\a', 
		'\xC4', '\x2', '\x2', '\x4EE', '\x4EC', '\x3', '\x2', '\x2', '\x2', '\x4EE', 
		'\x4EF', '\x3', '\x2', '\x2', '\x2', '\x4EF', '\x4F0', '\x3', '\x2', '\x2', 
		'\x2', '\x4F0', '\x4F1', '\a', '#', '\x2', '\x2', '\x4F1', '\x4F6', '\x5', 
		'\\', '/', '\x2', '\x4F2', '\x4F3', '\a', '\x245', '\x2', '\x2', '\x4F3', 
		'\x4F5', '\x5', '\\', '/', '\x2', '\x4F4', '\x4F2', '\x3', '\x2', '\x2', 
		'\x2', '\x4F5', '\x4F8', '\x3', '\x2', '\x2', '\x2', '\x4F6', '\x4F4', 
		'\x3', '\x2', '\x2', '\x2', '\x4F6', '\x4F7', '\x3', '\x2', '\x2', '\x2', 
		'\x4F7', '\x4F9', '\x3', '\x2', '\x2', '\x2', '\x4F8', '\x4F6', '\x3', 
		'\x2', '\x2', '\x2', '\x4F9', '\x4FA', '\a', '\x24C', '\x2', '\x2', '\x4FA', 
		'\x4FC', '\x3', '\x2', '\x2', '\x2', '\x4FB', '\x45A', '\x3', '\x2', '\x2', 
		'\x2', '\x4FB', '\x47E', '\x3', '\x2', '\x2', '\x2', '\x4FB', '\x492', 
		'\x3', '\x2', '\x2', '\x2', '\x4FB', '\x49C', '\x3', '\x2', '\x2', '\x2', 
		'\x4FB', '\x4B2', '\x3', '\x2', '\x2', '\x2', '\x4FB', '\x4C1', '\x3', 
		'\x2', '\x2', '\x2', '\x4FB', '\x4C7', '\x3', '\x2', '\x2', '\x2', '\x4FB', 
		'\x4CF', '\x3', '\x2', '\x2', '\x2', '\x4FC', '[', '\x3', '\x2', '\x2', 
		'\x2', '\x4FD', '\x50F', '\x5', '\b', '\x5', '\x2', '\x4FE', '\x501', 
		'\x5', 'H', '%', '\x2', '\x4FF', '\x500', '\a', '\x1FD', '\x2', '\x2', 
		'\x500', '\x502', '\x5', '\x142', '\xA2', '\x2', '\x501', '\x4FF', '\x3', 
		'\x2', '\x2', '\x2', '\x501', '\x502', '\x3', '\x2', '\x2', '\x2', '\x502', 
		'\x505', '\x3', '\x2', '\x2', '\x2', '\x503', '\x504', '\a', '\x187', 
		'\x2', '\x2', '\x504', '\x506', '\x5', '\x142', '\xA2', '\x2', '\x505', 
		'\x503', '\x3', '\x2', '\x2', '\x2', '\x505', '\x506', '\x3', '\x2', '\x2', 
		'\x2', '\x506', '\x50B', '\x3', '\x2', '\x2', '\x2', '\x507', '\x509', 
		'\a', '\x1A0', '\x2', '\x2', '\x508', '\x507', '\x3', '\x2', '\x2', '\x2', 
		'\x508', '\x509', '\x3', '\x2', '\x2', '\x2', '\x509', '\x50A', '\x3', 
		'\x2', '\x2', '\x2', '\x50A', '\x50C', '\a', '\x1A1', '\x2', '\x2', '\x50B', 
		'\x508', '\x3', '\x2', '\x2', '\x2', '\x50B', '\x50C', '\x3', '\x2', '\x2', 
		'\x2', '\x50C', '\x510', '\x3', '\x2', '\x2', '\x2', '\x50D', '\x50E', 
		'\a', '\x191', '\x2', '\x2', '\x50E', '\x510', '\a', '\xA5', '\x2', '\x2', 
		'\x50F', '\x4FE', '\x3', '\x2', '\x2', '\x2', '\x50F', '\x50D', '\x3', 
		'\x2', '\x2', '\x2', '\x510', ']', '\x3', '\x2', '\x2', '\x2', '\x511', 
		'\x512', '\a', '\x14B', '\x2', '\x2', '\x512', '\x514', '\a', '\x24B', 
		'\x2', '\x2', '\x513', '\x515', '\t', '\r', '\x2', '\x2', '\x514', '\x513', 
		'\x3', '\x2', '\x2', '\x2', '\x514', '\x515', '\x3', '\x2', '\x2', '\x2', 
		'\x515', '\x522', '\x3', '\x2', '\x2', '\x2', '\x516', '\x517', '\x5', 
		'\x142', '\xA2', '\x2', '\x517', '\x518', '\a', '\x193', '\x2', '\x2', 
		'\x518', '\x519', '\x5', '\x142', '\xA2', '\x2', '\x519', '\x523', '\x3', 
		'\x2', '\x2', '\x2', '\x51A', '\x51C', '\a', '\x193', '\x2', '\x2', '\x51B', 
		'\x51A', '\x3', '\x2', '\x2', '\x2', '\x51B', '\x51C', '\x3', '\x2', '\x2', 
		'\x2', '\x51C', '\x51D', '\x3', '\x2', '\x2', '\x2', '\x51D', '\x520', 
		'\x5', '\x142', '\xA2', '\x2', '\x51E', '\x51F', '\a', '\x245', '\x2', 
		'\x2', '\x51F', '\x521', '\x5', '\x142', '\xA2', '\x2', '\x520', '\x51E', 
		'\x3', '\x2', '\x2', '\x2', '\x520', '\x521', '\x3', '\x2', '\x2', '\x2', 
		'\x521', '\x523', '\x3', '\x2', '\x2', '\x2', '\x522', '\x516', '\x3', 
		'\x2', '\x2', '\x2', '\x522', '\x51B', '\x3', '\x2', '\x2', '\x2', '\x523', 
		'\x524', '\x3', '\x2', '\x2', '\x2', '\x524', '\x525', '\a', '\x24C', 
		'\x2', '\x2', '\x525', '\x555', '\x3', '\x2', '\x2', '\x2', '\x526', '\x527', 
		'\a', '\x147', '\x2', '\x2', '\x527', '\x528', '\a', '\x24B', '\x2', '\x2', 
		'\x528', '\x52D', '\x5', '\x142', '\xA2', '\x2', '\x529', '\x52A', '\a', 
		'\x245', '\x2', '\x2', '\x52A', '\x52C', '\x5', '\x142', '\xA2', '\x2', 
		'\x52B', '\x529', '\x3', '\x2', '\x2', '\x2', '\x52C', '\x52F', '\x3', 
		'\x2', '\x2', '\x2', '\x52D', '\x52B', '\x3', '\x2', '\x2', '\x2', '\x52D', 
		'\x52E', '\x3', '\x2', '\x2', '\x2', '\x52E', '\x532', '\x3', '\x2', '\x2', 
		'\x2', '\x52F', '\x52D', '\x3', '\x2', '\x2', '\x2', '\x530', '\x531', 
		'\a', '\x193', '\x2', '\x2', '\x531', '\x533', '\x5', '\x142', '\xA2', 
		'\x2', '\x532', '\x530', '\x3', '\x2', '\x2', '\x2', '\x532', '\x533', 
		'\x3', '\x2', '\x2', '\x2', '\x533', '\x536', '\x3', '\x2', '\x2', '\x2', 
		'\x534', '\x535', '\a', '\x191', '\x2', '\x2', '\x535', '\x537', '\x5', 
		'\x142', '\xA2', '\x2', '\x536', '\x534', '\x3', '\x2', '\x2', '\x2', 
		'\x536', '\x537', '\x3', '\x2', '\x2', '\x2', '\x537', '\x538', '\x3', 
		'\x2', '\x2', '\x2', '\x538', '\x539', '\a', '\x24C', '\x2', '\x2', '\x539', 
		'\x555', '\x3', '\x2', '\x2', '\x2', '\x53A', '\x53B', '\a', '\x141', 
		'\x2', '\x2', '\x53B', '\x53C', '\a', '\x24B', '\x2', '\x2', '\x53C', 
		'\x53D', '\x5', '\x126', '\x94', '\x2', '\x53D', '\x53E', '\a', '\x197', 
		'\x2', '\x2', '\x53E', '\x53F', '\x5', '\x142', '\xA2', '\x2', '\x53F', 
		'\x540', '\a', '\x24C', '\x2', '\x2', '\x540', '\x555', '\x3', '\x2', 
		'\x2', '\x2', '\x541', '\x542', '\a', '\x140', '\x2', '\x2', '\x542', 
		'\x543', '\a', '\x24B', '\x2', '\x2', '\x543', '\x544', '\x5', '\x142', 
		'\xA2', '\x2', '\x544', '\x545', '\a', '\x1A7', '\x2', '\x2', '\x545', 
		'\x546', '\x5', '\x142', '\xA2', '\x2', '\x546', '\x547', '\a', '\x193', 
		'\x2', '\x2', '\x547', '\x54A', '\x5', '\x142', '\xA2', '\x2', '\x548', 
		'\x549', '\a', '\x191', '\x2', '\x2', '\x549', '\x54B', '\x5', '\x142', 
		'\xA2', '\x2', '\x54A', '\x548', '\x3', '\x2', '\x2', '\x2', '\x54A', 
		'\x54B', '\x3', '\x2', '\x2', '\x2', '\x54B', '\x54C', '\x3', '\x2', '\x2', 
		'\x2', '\x54C', '\x54D', '\a', '\x24C', '\x2', '\x2', '\x54D', '\x555', 
		'\x3', '\x2', '\x2', '\x2', '\x54E', '\x54F', '\a', '\x15B', '\x2', '\x2', 
		'\x54F', '\x550', '\a', '\x191', '\x2', '\x2', '\x550', '\x551', '\a', 
		'\x24B', '\x2', '\x2', '\x551', '\x552', '\x5', '\x142', '\xA2', '\x2', 
		'\x552', '\x553', '\a', '\x24C', '\x2', '\x2', '\x553', '\x555', '\x3', 
		'\x2', '\x2', '\x2', '\x554', '\x511', '\x3', '\x2', '\x2', '\x2', '\x554', 
		'\x526', '\x3', '\x2', '\x2', '\x2', '\x554', '\x53A', '\x3', '\x2', '\x2', 
		'\x2', '\x554', '\x541', '\x3', '\x2', '\x2', '\x2', '\x554', '\x54E', 
		'\x3', '\x2', '\x2', '\x2', '\x555', '_', '\x3', '\x2', '\x2', '\x2', 
		'\x556', '\x568', '\a', '\x182', '\x2', '\x2', '\x557', '\x559', '\a', 
		'\x184', '\x2', '\x2', '\x558', '\x55A', '\x5', 'T', '+', '\x2', '\x559', 
		'\x558', '\x3', '\x2', '\x2', '\x2', '\x559', '\x55A', '\x3', '\x2', '\x2', 
		'\x2', '\x55A', '\x568', '\x3', '\x2', '\x2', '\x2', '\x55B', '\x55D', 
		'\a', '\x185', '\x2', '\x2', '\x55C', '\x55E', '\x5', 'T', '+', '\x2', 
		'\x55D', '\x55C', '\x3', '\x2', '\x2', '\x2', '\x55D', '\x55E', '\x3', 
		'\x2', '\x2', '\x2', '\x55E', '\x568', '\x3', '\x2', '\x2', '\x2', '\x55F', 
		'\x561', '\a', '\x19E', '\x2', '\x2', '\x560', '\x562', '\x5', 'T', '+', 
		'\x2', '\x561', '\x560', '\x3', '\x2', '\x2', '\x2', '\x561', '\x562', 
		'\x3', '\x2', '\x2', '\x2', '\x562', '\x568', '\x3', '\x2', '\x2', '\x2', 
		'\x563', '\x565', '\a', '\x19F', '\x2', '\x2', '\x564', '\x566', '\x5', 
		'T', '+', '\x2', '\x565', '\x564', '\x3', '\x2', '\x2', '\x2', '\x565', 
		'\x566', '\x3', '\x2', '\x2', '\x2', '\x566', '\x568', '\x3', '\x2', '\x2', 
		'\x2', '\x567', '\x556', '\x3', '\x2', '\x2', '\x2', '\x567', '\x557', 
		'\x3', '\x2', '\x2', '\x2', '\x567', '\x55B', '\x3', '\x2', '\x2', '\x2', 
		'\x567', '\x55F', '\x3', '\x2', '\x2', '\x2', '\x567', '\x563', '\x3', 
		'\x2', '\x2', '\x2', '\x568', '\x61', '\x3', '\x2', '\x2', '\x2', '\x569', 
		'\x570', '\a', '\x181', '\x2', '\x2', '\x56A', '\x570', '\a', '\x15E', 
		'\x2', '\x2', '\x56B', '\x570', '\a', '\x186', '\x2', '\x2', '\x56C', 
		'\x570', '\a', '\x1AC', '\x2', '\x2', '\x56D', '\x570', '\a', '\x1B6', 
		'\x2', '\x2', '\x56E', '\x570', '\x5', '\x64', '\x33', '\x2', '\x56F', 
		'\x569', '\x3', '\x2', '\x2', '\x2', '\x56F', '\x56A', '\x3', '\x2', '\x2', 
		'\x2', '\x56F', '\x56B', '\x3', '\x2', '\x2', '\x2', '\x56F', '\x56C', 
		'\x3', '\x2', '\x2', '\x2', '\x56F', '\x56D', '\x3', '\x2', '\x2', '\x2', 
		'\x56F', '\x56E', '\x3', '\x2', '\x2', '\x2', '\x570', '\x63', '\x3', 
		'\x2', '\x2', '\x2', '\x571', '\x572', '\t', '\xE', '\x2', '\x2', '\x572', 
		'\x573', '\a', '\x24B', '\x2', '\x2', '\x573', '\x574', '\x5', '\x142', 
		'\xA2', '\x2', '\x574', '\x575', '\a', '\x176', '\x2', '\x2', '\x575', 
		'\x576', '\x5', 'H', '%', '\x2', '\x576', '\x577', '\a', '\x24C', '\x2', 
		'\x2', '\x577', '\x65', '\x3', '\x2', '\x2', '\x2', '\x578', '\x579', 
		'\a', '\x131', '\x2', '\x2', '\x579', '\x57C', '\a', '\x24B', '\x2', '\x2', 
		'\x57A', '\x57D', '\x5', '\b', '\x5', '\x2', '\x57B', '\x57D', '\x5', 
		'h', '\x35', '\x2', '\x57C', '\x57A', '\x3', '\x2', '\x2', '\x2', '\x57C', 
		'\x57B', '\x3', '\x2', '\x2', '\x2', '\x57D', '\x57E', '\x3', '\x2', '\x2', 
		'\x2', '\x57E', '\x57F', '\a', '\x193', '\x2', '\x2', '\x57F', '\x580', 
		'\x5', '\x142', '\xA2', '\x2', '\x580', '\x581', '\a', '\x24C', '\x2', 
		'\x2', '\x581', 'g', '\x3', '\x2', '\x2', '\x2', '\x582', '\x586', '\a', 
		'\x268', '\x2', '\x2', '\x583', '\x585', '\a', '\x26F', '\x2', '\x2', 
		'\x584', '\x583', '\x3', '\x2', '\x2', '\x2', '\x585', '\x588', '\x3', 
		'\x2', '\x2', '\x2', '\x586', '\x584', '\x3', '\x2', '\x2', '\x2', '\x586', 
		'\x587', '\x3', '\x2', '\x2', '\x2', '\x587', '\x589', '\x3', '\x2', '\x2', 
		'\x2', '\x588', '\x586', '\x3', '\x2', '\x2', '\x2', '\x589', '\x58C', 
		'\a', '\x270', '\x2', '\x2', '\x58A', '\x58C', '\a', '\x267', '\x2', '\x2', 
		'\x58B', '\x582', '\x3', '\x2', '\x2', '\x2', '\x58B', '\x58A', '\x3', 
		'\x2', '\x2', '\x2', '\x58C', 'i', '\x3', '\x2', '\x2', '\x2', '\x58D', 
		'\x58E', '\t', '\xF', '\x2', '\x2', '\x58E', '\x58F', '\a', '\x24B', '\x2', 
		'\x2', '\x58F', '\x594', '\x5', '\x142', '\xA2', '\x2', '\x590', '\x591', 
		'\a', '\x245', '\x2', '\x2', '\x591', '\x593', '\x5', '\x142', '\xA2', 
		'\x2', '\x592', '\x590', '\x3', '\x2', '\x2', '\x2', '\x593', '\x596', 
		'\x3', '\x2', '\x2', '\x2', '\x594', '\x592', '\x3', '\x2', '\x2', '\x2', 
		'\x594', '\x595', '\x3', '\x2', '\x2', '\x2', '\x595', '\x597', '\x3', 
		'\x2', '\x2', '\x2', '\x596', '\x594', '\x3', '\x2', '\x2', '\x2', '\x597', 
		'\x598', '\a', '\x24C', '\x2', '\x2', '\x598', '\x5A7', '\x3', '\x2', 
		'\x2', '\x2', '\x599', '\x59A', '\a', '\x144', '\x2', '\x2', '\x59A', 
		'\x5A3', '\a', '\x24B', '\x2', '\x2', '\x59B', '\x5A0', '\x5', '\x142', 
		'\xA2', '\x2', '\x59C', '\x59D', '\a', '\x245', '\x2', '\x2', '\x59D', 
		'\x59F', '\x5', '\x142', '\xA2', '\x2', '\x59E', '\x59C', '\x3', '\x2', 
		'\x2', '\x2', '\x59F', '\x5A2', '\x3', '\x2', '\x2', '\x2', '\x5A0', '\x59E', 
		'\x3', '\x2', '\x2', '\x2', '\x5A0', '\x5A1', '\x3', '\x2', '\x2', '\x2', 
		'\x5A1', '\x5A4', '\x3', '\x2', '\x2', '\x2', '\x5A2', '\x5A0', '\x3', 
		'\x2', '\x2', '\x2', '\x5A3', '\x59B', '\x3', '\x2', '\x2', '\x2', '\x5A3', 
		'\x5A4', '\x3', '\x2', '\x2', '\x2', '\x5A4', '\x5A5', '\x3', '\x2', '\x2', 
		'\x2', '\x5A5', '\x5A7', '\a', '\x24C', '\x2', '\x2', '\x5A6', '\x58D', 
		'\x3', '\x2', '\x2', '\x2', '\x5A6', '\x599', '\x3', '\x2', '\x2', '\x2', 
		'\x5A7', 'k', '\x3', '\x2', '\x2', '\x2', '\x5A8', '\x5A9', '\a', 'Y', 
		'\x2', '\x2', '\x5A9', '\x5AA', '\a', '\x24B', '\x2', '\x2', '\x5AA', 
		'\x5AB', '\a', '\x1BA', '\x2', '\x2', '\x5AB', '\x5AC', '\x5', '\x142', 
		'\xA2', '\x2', '\x5AC', '\x5AD', '\a', '\x24C', '\x2', '\x2', '\x5AD', 
		'm', '\x3', '\x2', '\x2', '\x2', '\x5AE', '\x5B0', '\a', '\x1B8', '\x2', 
		'\x2', '\x5AF', '\x5AE', '\x3', '\x2', '\x2', '\x2', '\x5AF', '\x5B0', 
		'\x3', '\x2', '\x2', '\x2', '\x5B0', '\x5B4', '\x3', '\x2', '\x2', '\x2', 
		'\x5B1', '\x5B2', '\x5', '\b', '\x5', '\x2', '\x5B2', '\x5B3', '\x5', 
		'p', '\x39', '\x2', '\x5B3', '\x5B5', '\x3', '\x2', '\x2', '\x2', '\x5B4', 
		'\x5B1', '\x3', '\x2', '\x2', '\x2', '\x5B4', '\x5B5', '\x3', '\x2', '\x2', 
		'\x2', '\x5B5', '\x5B6', '\x3', '\x2', '\x2', '\x2', '\x5B6', '\x5B7', 
		'\x5', '\x142', '\xA2', '\x2', '\x5B7', 'o', '\x3', '\x2', '\x2', '\x2', 
		'\x5B8', '\x5B9', '\t', '\x10', '\x2', '\x2', '\x5B9', 'q', '\x3', '\x2', 
		'\x2', '\x2', '\x5BA', '\x5BB', '\a', '\x24B', '\x2', '\x2', '\x5BB', 
		'\x5BC', '\x5', '\x12', '\n', '\x2', '\x5BC', '\x5BD', '\a', '\x24C', 
		'\x2', '\x2', '\x5BD', 's', '\x3', '\x2', '\x2', '\x2', '\x5BE', '\x5BF', 
		'\a', '\x24B', '\x2', '\x2', '\x5BF', '\x5C0', '\x5', 'v', '<', '\x2', 
		'\x5C0', '\x5C1', '\a', '\x24C', '\x2', '\x2', '\x5C1', 'u', '\x3', '\x2', 
		'\x2', '\x2', '\x5C2', '\x5C7', '\x5', '\x34', '\x1B', '\x2', '\x5C3', 
		'\x5C4', '\a', '\x245', '\x2', '\x2', '\x5C4', '\x5C6', '\x5', '\x34', 
		'\x1B', '\x2', '\x5C5', '\x5C3', '\x3', '\x2', '\x2', '\x2', '\x5C6', 
		'\x5C9', '\x3', '\x2', '\x2', '\x2', '\x5C7', '\x5C5', '\x3', '\x2', '\x2', 
		'\x2', '\x5C7', '\x5C8', '\x3', '\x2', '\x2', '\x2', '\x5C8', 'w', '\x3', 
		'\x2', '\x2', '\x2', '\x5C9', '\x5C7', '\x3', '\x2', '\x2', '\x2', '\x5CA', 
		'\x5CC', '\a', '\x176', '\x2', '\x2', '\x5CB', '\x5CA', '\x3', '\x2', 
		'\x2', '\x2', '\x5CB', '\x5CC', '\x3', '\x2', '\x2', '\x2', '\x5CC', '\x5CD', 
		'\x3', '\x2', '\x2', '\x2', '\x5CD', '\x5D9', '\x5', '\b', '\x5', '\x2', 
		'\x5CE', '\x5CF', '\a', '\x24B', '\x2', '\x2', '\x5CF', '\x5D4', '\x5', 
		'\b', '\x5', '\x2', '\x5D0', '\x5D1', '\a', '\x245', '\x2', '\x2', '\x5D1', 
		'\x5D3', '\x5', '\b', '\x5', '\x2', '\x5D2', '\x5D0', '\x3', '\x2', '\x2', 
		'\x2', '\x5D3', '\x5D6', '\x3', '\x2', '\x2', '\x2', '\x5D4', '\x5D2', 
		'\x3', '\x2', '\x2', '\x2', '\x5D4', '\x5D5', '\x3', '\x2', '\x2', '\x2', 
		'\x5D5', '\x5D7', '\x3', '\x2', '\x2', '\x2', '\x5D6', '\x5D4', '\x3', 
		'\x2', '\x2', '\x2', '\x5D7', '\x5D8', '\a', '\x24C', '\x2', '\x2', '\x5D8', 
		'\x5DA', '\x3', '\x2', '\x2', '\x2', '\x5D9', '\x5CE', '\x3', '\x2', '\x2', 
		'\x2', '\x5D9', '\x5DA', '\x3', '\x2', '\x2', '\x2', '\x5DA', 'y', '\x3', 
		'\x2', '\x2', '\x2', '\x5DB', '\x5DD', '\a', '\x19A', '\x2', '\x2', '\x5DC', 
		'\x5DE', '\t', '\x11', '\x2', '\x2', '\x5DD', '\x5DC', '\x3', '\x2', '\x2', 
		'\x2', '\x5DD', '\x5DE', '\x3', '\x2', '\x2', '\x2', '\x5DE', '\x5E0', 
		'\x3', '\x2', '\x2', '\x2', '\x5DF', '\x5E1', '\a', '\x1AF', '\x2', '\x2', 
		'\x5E0', '\x5DF', '\x3', '\x2', '\x2', '\x2', '\x5E0', '\x5E1', '\x3', 
		'\x2', '\x2', '\x2', '\x5E1', '\x5E2', '\x3', '\x2', '\x2', '\x2', '\x5E2', 
		'\x5E7', '\x5', '\x34', '\x1B', '\x2', '\x5E3', '\x5E4', '\a', '\x245', 
		'\x2', '\x2', '\x5E4', '\x5E6', '\x5', '\x34', '\x1B', '\x2', '\x5E5', 
		'\x5E3', '\x3', '\x2', '\x2', '\x2', '\x5E6', '\x5E9', '\x3', '\x2', '\x2', 
		'\x2', '\x5E7', '\x5E5', '\x3', '\x2', '\x2', '\x2', '\x5E7', '\x5E8', 
		'\x3', '\x2', '\x2', '\x2', '\x5E8', '{', '\x3', '\x2', '\x2', '\x2', 
		'\x5E9', '\x5E7', '\x3', '\x2', '\x2', '\x2', '\x5EA', '\x5EB', '\t', 
		'\x12', '\x2', '\x2', '\x5EB', '}', '\x3', '\x2', '\x2', '\x2', '\x5EC', 
		'\x5EE', '\a', '\x1BC', '\x2', '\x2', '\x5ED', '\x5EF', '\a', '\xC3', 
		'\x2', '\x2', '\x5EE', '\x5ED', '\x3', '\x2', '\x2', '\x2', '\x5EE', '\x5EF', 
		'\x3', '\x2', '\x2', '\x2', '\x5EF', '\x5F0', '\x3', '\x2', '\x2', '\x2', 
		'\x5F0', '\x5F5', '\x5', '\x80', '\x41', '\x2', '\x5F1', '\x5F2', '\a', 
		'\x245', '\x2', '\x2', '\x5F2', '\x5F4', '\x5', '\x80', '\x41', '\x2', 
		'\x5F3', '\x5F1', '\x3', '\x2', '\x2', '\x2', '\x5F4', '\x5F7', '\x3', 
		'\x2', '\x2', '\x2', '\x5F5', '\x5F3', '\x3', '\x2', '\x2', '\x2', '\x5F5', 
		'\x5F6', '\x3', '\x2', '\x2', '\x2', '\x5F6', '\x7F', '\x3', '\x2', '\x2', 
		'\x2', '\x5F7', '\x5F5', '\x3', '\x2', '\x2', '\x2', '\x5F8', '\x604', 
		'\x5', '\b', '\x5', '\x2', '\x5F9', '\x5FA', '\a', '\x24B', '\x2', '\x2', 
		'\x5FA', '\x5FF', '\x5', '\b', '\x5', '\x2', '\x5FB', '\x5FC', '\a', '\x245', 
		'\x2', '\x2', '\x5FC', '\x5FE', '\x5', '\b', '\x5', '\x2', '\x5FD', '\x5FB', 
		'\x3', '\x2', '\x2', '\x2', '\x5FE', '\x601', '\x3', '\x2', '\x2', '\x2', 
		'\x5FF', '\x5FD', '\x3', '\x2', '\x2', '\x2', '\x5FF', '\x600', '\x3', 
		'\x2', '\x2', '\x2', '\x600', '\x602', '\x3', '\x2', '\x2', '\x2', '\x601', 
		'\x5FF', '\x3', '\x2', '\x2', '\x2', '\x602', '\x603', '\a', '\x24C', 
		'\x2', '\x2', '\x603', '\x605', '\x3', '\x2', '\x2', '\x2', '\x604', '\x5F9', 
		'\x3', '\x2', '\x2', '\x2', '\x604', '\x605', '\x3', '\x2', '\x2', '\x2', 
		'\x605', '\x606', '\x3', '\x2', '\x2', '\x2', '\x606', '\x60B', '\a', 
		'\x176', '\x2', '\x2', '\x607', '\x609', '\a', '\x1A0', '\x2', '\x2', 
		'\x608', '\x607', '\x3', '\x2', '\x2', '\x2', '\x608', '\x609', '\x3', 
		'\x2', '\x2', '\x2', '\x609', '\x60A', '\x3', '\x2', '\x2', '\x2', '\x60A', 
		'\x60C', '\a', '\x8C', '\x2', '\x2', '\x60B', '\x608', '\x3', '\x2', '\x2', 
		'\x2', '\x60B', '\x60C', '\x3', '\x2', '\x2', '\x2', '\x60C', '\x60D', 
		'\x3', '\x2', '\x2', '\x2', '\x60D', '\x612', '\a', '\x24B', '\x2', '\x2', 
		'\x60E', '\x613', '\x5', '\x12', '\n', '\x2', '\x60F', '\x613', '\x5', 
		'\x8E', 'H', '\x2', '\x610', '\x613', '\x5', '\x84', '\x43', '\x2', '\x611', 
		'\x613', '\x5', '\x82', '\x42', '\x2', '\x612', '\x60E', '\x3', '\x2', 
		'\x2', '\x2', '\x612', '\x60F', '\x3', '\x2', '\x2', '\x2', '\x612', '\x610', 
		'\x3', '\x2', '\x2', '\x2', '\x612', '\x611', '\x3', '\x2', '\x2', '\x2', 
		'\x613', '\x614', '\x3', '\x2', '\x2', '\x2', '\x614', '\x615', '\a', 
		'\x24C', '\x2', '\x2', '\x615', '\x81', '\x3', '\x2', '\x2', '\x2', '\x616', 
		'\x618', '\x5', '~', '@', '\x2', '\x617', '\x616', '\x3', '\x2', '\x2', 
		'\x2', '\x617', '\x618', '\x3', '\x2', '\x2', '\x2', '\x618', '\x619', 
		'\x3', '\x2', '\x2', '\x2', '\x619', '\x61A', '\a', '>', '\x2', '\x2', 
		'\x61A', '\x61C', '\a', '\x193', '\x2', '\x2', '\x61B', '\x61D', '\a', 
		'\x1A4', '\x2', '\x2', '\x61C', '\x61B', '\x3', '\x2', '\x2', '\x2', '\x61C', 
		'\x61D', '\x3', '\x2', '\x2', '\x2', '\x61D', '\x61E', '\x3', '\x2', '\x2', 
		'\x2', '\x61E', '\x620', '\x5', '\x34', '\x1B', '\x2', '\x61F', '\x621', 
		'\a', '\x24F', '\x2', '\x2', '\x620', '\x61F', '\x3', '\x2', '\x2', '\x2', 
		'\x620', '\x621', '\x3', '\x2', '\x2', '\x2', '\x621', '\x626', '\x3', 
		'\x2', '\x2', '\x2', '\x622', '\x624', '\a', '\x176', '\x2', '\x2', '\x623', 
		'\x622', '\x3', '\x2', '\x2', '\x2', '\x623', '\x624', '\x3', '\x2', '\x2', 
		'\x2', '\x624', '\x625', '\x3', '\x2', '\x2', '\x2', '\x625', '\x627', 
		'\x5', '\b', '\x5', '\x2', '\x626', '\x623', '\x3', '\x2', '\x2', '\x2', 
		'\x626', '\x627', '\x3', '\x2', '\x2', '\x2', '\x627', '\x631', '\x3', 
		'\x2', '\x2', '\x2', '\x628', '\x629', '\a', '\x1B7', '\x2', '\x2', '\x629', 
		'\x62E', '\x5', '\x42', '\"', '\x2', '\x62A', '\x62B', '\a', '\x245', 
		'\x2', '\x2', '\x62B', '\x62D', '\x5', '\x42', '\"', '\x2', '\x62C', '\x62A', 
		'\x3', '\x2', '\x2', '\x2', '\x62D', '\x630', '\x3', '\x2', '\x2', '\x2', 
		'\x62E', '\x62C', '\x3', '\x2', '\x2', '\x2', '\x62E', '\x62F', '\x3', 
		'\x2', '\x2', '\x2', '\x62F', '\x632', '\x3', '\x2', '\x2', '\x2', '\x630', 
		'\x62E', '\x3', '\x2', '\x2', '\x2', '\x631', '\x628', '\x3', '\x2', '\x2', 
		'\x2', '\x631', '\x632', '\x3', '\x2', '\x2', '\x2', '\x632', '\x63A', 
		'\x3', '\x2', '\x2', '\x2', '\x633', '\x638', '\a', '\x1BA', '\x2', '\x2', 
		'\x634', '\x639', '\x5', '\x142', '\xA2', '\x2', '\x635', '\x636', '\a', 
		'\x33', '\x2', '\x2', '\x636', '\x637', '\a', '\x9E', '\x2', '\x2', '\x637', 
		'\x639', '\x5', '\b', '\x5', '\x2', '\x638', '\x634', '\x3', '\x2', '\x2', 
		'\x2', '\x638', '\x635', '\x3', '\x2', '\x2', '\x2', '\x639', '\x63B', 
		'\x3', '\x2', '\x2', '\x2', '\x63A', '\x633', '\x3', '\x2', '\x2', '\x2', 
		'\x63A', '\x63B', '\x3', '\x2', '\x2', '\x2', '\x63B', '\x63E', '\x3', 
		'\x2', '\x2', '\x2', '\x63C', '\x63D', '\a', '\x1AA', '\x2', '\x2', '\x63D', 
		'\x63F', '\x5', '\x36', '\x1C', '\x2', '\x63E', '\x63C', '\x3', '\x2', 
		'\x2', '\x2', '\x63E', '\x63F', '\x3', '\x2', '\x2', '\x2', '\x63F', '\x83', 
		'\x3', '\x2', '\x2', '\x2', '\x640', '\x642', '\x5', '~', '@', '\x2', 
		'\x641', '\x640', '\x3', '\x2', '\x2', '\x2', '\x641', '\x642', '\x3', 
		'\x2', '\x2', '\x2', '\x642', '\x643', '\x3', '\x2', '\x2', '\x2', '\x643', 
		'\x645', '\a', '\x112', '\x2', '\x2', '\x644', '\x646', '\a', '\x1A4', 
		'\x2', '\x2', '\x645', '\x644', '\x3', '\x2', '\x2', '\x2', '\x645', '\x646', 
		'\x3', '\x2', '\x2', '\x2', '\x646', '\x647', '\x3', '\x2', '\x2', '\x2', 
		'\x647', '\x649', '\x5', '\x34', '\x1B', '\x2', '\x648', '\x64A', '\a', 
		'\x24F', '\x2', '\x2', '\x649', '\x648', '\x3', '\x2', '\x2', '\x2', '\x649', 
		'\x64A', '\x3', '\x2', '\x2', '\x2', '\x64A', '\x64F', '\x3', '\x2', '\x2', 
		'\x2', '\x64B', '\x64D', '\a', '\x176', '\x2', '\x2', '\x64C', '\x64B', 
		'\x3', '\x2', '\x2', '\x2', '\x64C', '\x64D', '\x3', '\x2', '\x2', '\x2', 
		'\x64D', '\x64E', '\x3', '\x2', '\x2', '\x2', '\x64E', '\x650', '\x5', 
		'\b', '\x5', '\x2', '\x64F', '\x64C', '\x3', '\x2', '\x2', '\x2', '\x64F', 
		'\x650', '\x3', '\x2', '\x2', '\x2', '\x650', '\x651', '\x3', '\x2', '\x2', 
		'\x2', '\x651', '\x652', '\a', '\xE6', '\x2', '\x2', '\x652', '\x657', 
		'\x5', '\x86', '\x44', '\x2', '\x653', '\x654', '\a', '\x245', '\x2', 
		'\x2', '\x654', '\x656', '\x5', '\x86', '\x44', '\x2', '\x655', '\x653', 
		'\x3', '\x2', '\x2', '\x2', '\x656', '\x659', '\x3', '\x2', '\x2', '\x2', 
		'\x657', '\x655', '\x3', '\x2', '\x2', '\x2', '\x657', '\x658', '\x3', 
		'\x2', '\x2', '\x2', '\x658', '\x663', '\x3', '\x2', '\x2', '\x2', '\x659', 
		'\x657', '\x3', '\x2', '\x2', '\x2', '\x65A', '\x65B', '\a', '\x193', 
		'\x2', '\x2', '\x65B', '\x660', '\x5', '\x42', '\"', '\x2', '\x65C', '\x65D', 
		'\a', '\x245', '\x2', '\x2', '\x65D', '\x65F', '\x5', '\x42', '\"', '\x2', 
		'\x65E', '\x65C', '\x3', '\x2', '\x2', '\x2', '\x65F', '\x662', '\x3', 
		'\x2', '\x2', '\x2', '\x660', '\x65E', '\x3', '\x2', '\x2', '\x2', '\x660', 
		'\x661', '\x3', '\x2', '\x2', '\x2', '\x661', '\x664', '\x3', '\x2', '\x2', 
		'\x2', '\x662', '\x660', '\x3', '\x2', '\x2', '\x2', '\x663', '\x65A', 
		'\x3', '\x2', '\x2', '\x2', '\x663', '\x664', '\x3', '\x2', '\x2', '\x2', 
		'\x664', '\x66C', '\x3', '\x2', '\x2', '\x2', '\x665', '\x66A', '\a', 
		'\x1BA', '\x2', '\x2', '\x666', '\x66B', '\x5', '\x142', '\xA2', '\x2', 
		'\x667', '\x668', '\a', '\x33', '\x2', '\x2', '\x668', '\x669', '\a', 
		'\x9E', '\x2', '\x2', '\x669', '\x66B', '\x5', '\b', '\x5', '\x2', '\x66A', 
		'\x666', '\x3', '\x2', '\x2', '\x2', '\x66A', '\x667', '\x3', '\x2', '\x2', 
		'\x2', '\x66B', '\x66D', '\x3', '\x2', '\x2', '\x2', '\x66C', '\x665', 
		'\x3', '\x2', '\x2', '\x2', '\x66C', '\x66D', '\x3', '\x2', '\x2', '\x2', 
		'\x66D', '\x670', '\x3', '\x2', '\x2', '\x2', '\x66E', '\x66F', '\a', 
		'\x1AA', '\x2', '\x2', '\x66F', '\x671', '\x5', '\x36', '\x1C', '\x2', 
		'\x670', '\x66E', '\x3', '\x2', '\x2', '\x2', '\x670', '\x671', '\x3', 
		'\x2', '\x2', '\x2', '\x671', '\x85', '\x3', '\x2', '\x2', '\x2', '\x672', 
		'\x673', '\x5', '\x88', '\x45', '\x2', '\x673', '\x676', '\a', '\x242', 
		'\x2', '\x2', '\x674', '\x677', '\x5', '\x142', '\xA2', '\x2', '\x675', 
		'\x677', '\a', '\x187', '\x2', '\x2', '\x676', '\x674', '\x3', '\x2', 
		'\x2', '\x2', '\x676', '\x675', '\x3', '\x2', '\x2', '\x2', '\x677', '\x69A', 
		'\x3', '\x2', '\x2', '\x2', '\x678', '\x679', '\a', '\x24B', '\x2', '\x2', 
		'\x679', '\x67E', '\x5', '\x88', '\x45', '\x2', '\x67A', '\x67B', '\a', 
		'\x245', '\x2', '\x2', '\x67B', '\x67D', '\x5', '\x88', '\x45', '\x2', 
		'\x67C', '\x67A', '\x3', '\x2', '\x2', '\x2', '\x67D', '\x680', '\x3', 
		'\x2', '\x2', '\x2', '\x67E', '\x67C', '\x3', '\x2', '\x2', '\x2', '\x67E', 
		'\x67F', '\x3', '\x2', '\x2', '\x2', '\x67F', '\x681', '\x3', '\x2', '\x2', 
		'\x2', '\x680', '\x67E', '\x3', '\x2', '\x2', '\x2', '\x681', '\x682', 
		'\a', '\x24C', '\x2', '\x2', '\x682', '\x684', '\a', '\x242', '\x2', '\x2', 
		'\x683', '\x685', '\a', '\x144', '\x2', '\x2', '\x684', '\x683', '\x3', 
		'\x2', '\x2', '\x2', '\x684', '\x685', '\x3', '\x2', '\x2', '\x2', '\x685', 
		'\x697', '\x3', '\x2', '\x2', '\x2', '\x686', '\x689', '\a', '\x24B', 
		'\x2', '\x2', '\x687', '\x68A', '\x5', '\x142', '\xA2', '\x2', '\x688', 
		'\x68A', '\a', '\x187', '\x2', '\x2', '\x689', '\x687', '\x3', '\x2', 
		'\x2', '\x2', '\x689', '\x688', '\x3', '\x2', '\x2', '\x2', '\x68A', '\x692', 
		'\x3', '\x2', '\x2', '\x2', '\x68B', '\x68E', '\a', '\x245', '\x2', '\x2', 
		'\x68C', '\x68F', '\x5', '\x142', '\xA2', '\x2', '\x68D', '\x68F', '\a', 
		'\x187', '\x2', '\x2', '\x68E', '\x68C', '\x3', '\x2', '\x2', '\x2', '\x68E', 
		'\x68D', '\x3', '\x2', '\x2', '\x2', '\x68F', '\x691', '\x3', '\x2', '\x2', 
		'\x2', '\x690', '\x68B', '\x3', '\x2', '\x2', '\x2', '\x691', '\x694', 
		'\x3', '\x2', '\x2', '\x2', '\x692', '\x690', '\x3', '\x2', '\x2', '\x2', 
		'\x692', '\x693', '\x3', '\x2', '\x2', '\x2', '\x693', '\x695', '\x3', 
		'\x2', '\x2', '\x2', '\x694', '\x692', '\x3', '\x2', '\x2', '\x2', '\x695', 
		'\x698', '\a', '\x24C', '\x2', '\x2', '\x696', '\x698', '\x5', 'r', ':', 
		'\x2', '\x697', '\x686', '\x3', '\x2', '\x2', '\x2', '\x697', '\x696', 
		'\x3', '\x2', '\x2', '\x2', '\x698', '\x69A', '\x3', '\x2', '\x2', '\x2', 
		'\x699', '\x672', '\x3', '\x2', '\x2', '\x2', '\x699', '\x678', '\x3', 
		'\x2', '\x2', '\x2', '\x69A', '\x87', '\x3', '\x2', '\x2', '\x2', '\x69B', 
		'\x69D', '\x5', '\b', '\x5', '\x2', '\x69C', '\x69E', '\x5', '\x8A', '\x46', 
		'\x2', '\x69D', '\x69C', '\x3', '\x2', '\x2', '\x2', '\x69D', '\x69E', 
		'\x3', '\x2', '\x2', '\x2', '\x69E', '\x89', '\x3', '\x2', '\x2', '\x2', 
		'\x69F', '\x6A1', '\x5', '\x8C', 'G', '\x2', '\x6A0', '\x69F', '\x3', 
		'\x2', '\x2', '\x2', '\x6A1', '\x6A2', '\x3', '\x2', '\x2', '\x2', '\x6A2', 
		'\x6A0', '\x3', '\x2', '\x2', '\x2', '\x6A2', '\x6A3', '\x3', '\x2', '\x2', 
		'\x2', '\x6A3', '\x6AD', '\x3', '\x2', '\x2', '\x2', '\x6A4', '\x6A6', 
		'\x5', '\x8C', 'G', '\x2', '\x6A5', '\x6A4', '\x3', '\x2', '\x2', '\x2', 
		'\x6A6', '\x6A9', '\x3', '\x2', '\x2', '\x2', '\x6A7', '\x6A5', '\x3', 
		'\x2', '\x2', '\x2', '\x6A7', '\x6A8', '\x3', '\x2', '\x2', '\x2', '\x6A8', 
		'\x6AA', '\x3', '\x2', '\x2', '\x2', '\x6A9', '\x6A7', '\x3', '\x2', '\x2', 
		'\x2', '\x6AA', '\x6AB', '\a', '\x253', '\x2', '\x2', '\x6AB', '\x6AD', 
		'\a', '\x24F', '\x2', '\x2', '\x6AC', '\x6A0', '\x3', '\x2', '\x2', '\x2', 
		'\x6AC', '\x6A7', '\x3', '\x2', '\x2', '\x2', '\x6AD', '\x8B', '\x3', 
		'\x2', '\x2', '\x2', '\x6AE', '\x6AF', '\a', '\x253', '\x2', '\x2', '\x6AF', 
		'\x6BE', '\x5', ':', '\x1E', '\x2', '\x6B0', '\x6B1', '\a', '\x257', '\x2', 
		'\x2', '\x6B1', '\x6B2', '\x5', '\x142', '\xA2', '\x2', '\x6B2', '\x6B3', 
		'\a', '\x258', '\x2', '\x2', '\x6B3', '\x6BE', '\x3', '\x2', '\x2', '\x2', 
		'\x6B4', '\x6B6', '\a', '\x257', '\x2', '\x2', '\x6B5', '\x6B7', '\x5', 
		'\x142', '\xA2', '\x2', '\x6B6', '\x6B5', '\x3', '\x2', '\x2', '\x2', 
		'\x6B6', '\x6B7', '\x3', '\x2', '\x2', '\x2', '\x6B7', '\x6B8', '\x3', 
		'\x2', '\x2', '\x2', '\x6B8', '\x6BA', '\a', '\x243', '\x2', '\x2', '\x6B9', 
		'\x6BB', '\x5', '\x142', '\xA2', '\x2', '\x6BA', '\x6B9', '\x3', '\x2', 
		'\x2', '\x2', '\x6BA', '\x6BB', '\x3', '\x2', '\x2', '\x2', '\x6BB', '\x6BC', 
		'\x3', '\x2', '\x2', '\x2', '\x6BC', '\x6BE', '\a', '\x258', '\x2', '\x2', 
		'\x6BD', '\x6AE', '\x3', '\x2', '\x2', '\x2', '\x6BD', '\x6B0', '\x3', 
		'\x2', '\x2', '\x2', '\x6BD', '\x6B4', '\x3', '\x2', '\x2', '\x2', '\x6BE', 
		'\x8D', '\x3', '\x2', '\x2', '\x2', '\x6BF', '\x6C1', '\x5', '~', '@', 
		'\x2', '\x6C0', '\x6BF', '\x3', '\x2', '\x2', '\x2', '\x6C0', '\x6C1', 
		'\x3', '\x2', '\x2', '\x2', '\x6C1', '\x6C2', '\x3', '\x2', '\x2', '\x2', 
		'\x6C2', '\x6C3', '\a', 'x', '\x2', '\x2', '\x6C3', '\x6C4', '\a', '\x19A', 
		'\x2', '\x2', '\x6C4', '\x6C7', '\x5', '\x34', '\x1B', '\x2', '\x6C5', 
		'\x6C6', '\a', '\x176', '\x2', '\x2', '\x6C6', '\x6C8', '\x5', '\b', '\x5', 
		'\x2', '\x6C7', '\x6C5', '\x3', '\x2', '\x2', '\x2', '\x6C7', '\x6C8', 
		'\x3', '\x2', '\x2', '\x2', '\x6C8', '\x6CC', '\x3', '\x2', '\x2', '\x2', 
		'\x6C9', '\x6CA', '\a', '\xA8', '\x2', '\x2', '\x6CA', '\x6CB', '\t', 
		'\x13', '\x2', '\x2', '\x6CB', '\x6CD', '\a', '\x117', '\x2', '\x2', '\x6CC', 
		'\x6C9', '\x3', '\x2', '\x2', '\x2', '\x6CC', '\x6CD', '\x3', '\x2', '\x2', 
		'\x2', '\x6CD', '\x6CF', '\x3', '\x2', '\x2', '\x2', '\x6CE', '\x6D0', 
		'\x5', '\x98', 'M', '\x2', '\x6CF', '\x6CE', '\x3', '\x2', '\x2', '\x2', 
		'\x6CF', '\x6D0', '\x3', '\x2', '\x2', '\x2', '\x6D0', '\x6D4', '\x3', 
		'\x2', '\x2', '\x2', '\x6D1', '\x6D5', '\x5', '\x12', '\n', '\x2', '\x6D2', 
		'\x6D3', '\a', '\x187', '\x2', '\x2', '\x6D3', '\x6D5', '\a', '\x14C', 
		'\x2', '\x2', '\x6D4', '\x6D1', '\x3', '\x2', '\x2', '\x2', '\x6D4', '\x6D2', 
		'\x3', '\x2', '\x2', '\x2', '\x6D5', '\x6DC', '\x3', '\x2', '\x2', '\x2', 
		'\x6D6', '\x6D7', '\a', '\x1A3', '\x2', '\x2', '\x6D7', '\x6D9', '\a', 
		')', '\x2', '\x2', '\x6D8', '\x6DA', '\x5', '\x92', 'J', '\x2', '\x6D9', 
		'\x6D8', '\x3', '\x2', '\x2', '\x2', '\x6D9', '\x6DA', '\x3', '\x2', '\x2', 
		'\x2', '\x6DA', '\x6DB', '\x3', '\x2', '\x2', '\x2', '\x6DB', '\x6DD', 
		'\x5', '\x90', 'I', '\x2', '\x6DC', '\x6D6', '\x3', '\x2', '\x2', '\x2', 
		'\x6DC', '\x6DD', '\x3', '\x2', '\x2', '\x2', '\x6DD', '\x6E0', '\x3', 
		'\x2', '\x2', '\x2', '\x6DE', '\x6DF', '\a', '\x1AA', '\x2', '\x2', '\x6DF', 
		'\x6E1', '\x5', '\x36', '\x1C', '\x2', '\x6E0', '\x6DE', '\x3', '\x2', 
		'\x2', '\x2', '\x6E0', '\x6E1', '\x3', '\x2', '\x2', '\x2', '\x6E1', '\x8F', 
		'\x3', '\x2', '\x2', '\x2', '\x6E2', '\x6E3', '\a', '\x18B', '\x2', '\x2', 
		'\x6E3', '\x6F4', '\a', '\x99', '\x2', '\x2', '\x6E4', '\x6E5', '\a', 
		'\x18B', '\x2', '\x2', '\x6E5', '\x6E6', '\a', '\x112', '\x2', '\x2', 
		'\x6E6', '\x6E7', '\a', '\xE6', '\x2', '\x2', '\x6E7', '\x6EC', '\x5', 
		'\x86', '\x44', '\x2', '\x6E8', '\x6E9', '\a', '\x245', '\x2', '\x2', 
		'\x6E9', '\x6EB', '\x5', '\x86', '\x44', '\x2', '\x6EA', '\x6E8', '\x3', 
		'\x2', '\x2', '\x2', '\x6EB', '\x6EE', '\x3', '\x2', '\x2', '\x2', '\x6EC', 
		'\x6EA', '\x3', '\x2', '\x2', '\x2', '\x6EC', '\x6ED', '\x3', '\x2', '\x2', 
		'\x2', '\x6ED', '\x6F1', '\x3', '\x2', '\x2', '\x2', '\x6EE', '\x6EC', 
		'\x3', '\x2', '\x2', '\x2', '\x6EF', '\x6F0', '\a', '\x1BA', '\x2', '\x2', 
		'\x6F0', '\x6F2', '\x5', '\x142', '\xA2', '\x2', '\x6F1', '\x6EF', '\x3', 
		'\x2', '\x2', '\x2', '\x6F1', '\x6F2', '\x3', '\x2', '\x2', '\x2', '\x6F2', 
		'\x6F4', '\x3', '\x2', '\x2', '\x2', '\x6F3', '\x6E2', '\x3', '\x2', '\x2', 
		'\x2', '\x6F3', '\x6E4', '\x3', '\x2', '\x2', '\x2', '\x6F4', '\x91', 
		'\x3', '\x2', '\x2', '\x2', '\x6F5', '\x6F7', '\x5', '\x96', 'L', '\x2', 
		'\x6F6', '\x6F8', '\x5', '\x94', 'K', '\x2', '\x6F7', '\x6F6', '\x3', 
		'\x2', '\x2', '\x2', '\x6F7', '\x6F8', '\x3', '\x2', '\x2', '\x2', '\x6F8', 
		'\x6FD', '\x3', '\x2', '\x2', '\x2', '\x6F9', '\x6FA', '\a', '\x1A3', 
		'\x2', '\x2', '\x6FA', '\x6FB', '\a', '\x17F', '\x2', '\x2', '\x6FB', 
		'\x6FD', '\x5', '\b', '\x5', '\x2', '\x6FC', '\x6F5', '\x3', '\x2', '\x2', 
		'\x2', '\x6FC', '\x6F9', '\x3', '\x2', '\x2', '\x2', '\x6FD', '\x93', 
		'\x3', '\x2', '\x2', '\x2', '\x6FE', '\x6FF', '\a', '\x1BA', '\x2', '\x2', 
		'\x6FF', '\x700', '\x5', '\x142', '\xA2', '\x2', '\x700', '\x95', '\x3', 
		'\x2', '\x2', '\x2', '\x701', '\x702', '\a', '\x24B', '\x2', '\x2', '\x702', 
		'\x703', '\x5', ' ', '\x11', '\x2', '\x703', '\x704', '\a', '\x24C', '\x2', 
		'\x2', '\x704', '\x97', '\x3', '\x2', '\x2', '\x2', '\x705', '\x706', 
		'\a', '\x24B', '\x2', '\x2', '\x706', '\x70B', '\x5', '\x88', '\x45', 
		'\x2', '\x707', '\x708', '\a', '\x245', '\x2', '\x2', '\x708', '\x70A', 
		'\x5', '\x88', '\x45', '\x2', '\x709', '\x707', '\x3', '\x2', '\x2', '\x2', 
		'\x70A', '\x70D', '\x3', '\x2', '\x2', '\x2', '\x70B', '\x709', '\x3', 
		'\x2', '\x2', '\x2', '\x70B', '\x70C', '\x3', '\x2', '\x2', '\x2', '\x70C', 
		'\x70E', '\x3', '\x2', '\x2', '\x2', '\x70D', '\x70B', '\x3', '\x2', '\x2', 
		'\x2', '\x70E', '\x70F', '\a', '\x24C', '\x2', '\x2', '\x70F', '\x99', 
		'\x3', '\x2', '\x2', '\x2', '\x710', '\x73F', '\x5', '\x1E', '\x10', '\x2', 
		'\x711', '\x714', '\a', '\x19D', '\x2', '\x2', '\x712', '\x715', '\x5', 
		'\x142', '\xA2', '\x2', '\x713', '\x715', '\a', '\x170', '\x2', '\x2', 
		'\x714', '\x712', '\x3', '\x2', '\x2', '\x2', '\x714', '\x713', '\x3', 
		'\x2', '\x2', '\x2', '\x715', '\x73F', '\x3', '\x2', '\x2', '\x2', '\x716', 
		'\x717', '\a', '\x1A2', '\x2', '\x2', '\x717', '\x719', '\x5', '\x142', 
		'\xA2', '\x2', '\x718', '\x71A', '\t', '\x14', '\x2', '\x2', '\x719', 
		'\x718', '\x3', '\x2', '\x2', '\x2', '\x719', '\x71A', '\x3', '\x2', '\x2', 
		'\x2', '\x71A', '\x73F', '\x3', '\x2', '\x2', '\x2', '\x71B', '\x71C', 
		'\a', '\x190', '\x2', '\x2', '\x71C', '\x71E', '\t', '\x15', '\x2', '\x2', 
		'\x71D', '\x71F', '\x5', '\x142', '\xA2', '\x2', '\x71E', '\x71D', '\x3', 
		'\x2', '\x2', '\x2', '\x71E', '\x71F', '\x3', '\x2', '\x2', '\x2', '\x71F', 
		'\x720', '\x3', '\x2', '\x2', '\x2', '\x720', '\x722', '\t', '\x14', '\x2', 
		'\x2', '\x721', '\x723', '\a', '\x1A4', '\x2', '\x2', '\x722', '\x721', 
		'\x3', '\x2', '\x2', '\x2', '\x722', '\x723', '\x3', '\x2', '\x2', '\x2', 
		'\x723', '\x73F', '\x3', '\x2', '\x2', '\x2', '\x724', '\x72C', '\a', 
		'\x191', '\x2', '\x2', '\x725', '\x72D', '\a', '\x112', '\x2', '\x2', 
		'\x726', '\x727', '\a', '\x98', '\x2', '\x2', '\x727', '\x728', '\a', 
		'|', '\x2', '\x2', '\x728', '\x72D', '\a', '\x112', '\x2', '\x2', '\x729', 
		'\x72D', '\a', '\xE8', '\x2', '\x2', '\x72A', '\x72B', '\a', '|', '\x2', 
		'\x2', '\x72B', '\x72D', '\a', '\xE8', '\x2', '\x2', '\x72C', '\x725', 
		'\x3', '\x2', '\x2', '\x2', '\x72C', '\x726', '\x3', '\x2', '\x2', '\x2', 
		'\x72C', '\x729', '\x3', '\x2', '\x2', '\x2', '\x72C', '\x72A', '\x3', 
		'\x2', '\x2', '\x2', '\x72D', '\x737', '\x3', '\x2', '\x2', '\x2', '\x72E', 
		'\x72F', '\a', '\x9E', '\x2', '\x2', '\x72F', '\x734', '\x5', '\x34', 
		'\x1B', '\x2', '\x730', '\x731', '\a', '\x245', '\x2', '\x2', '\x731', 
		'\x733', '\x5', '\x34', '\x1B', '\x2', '\x732', '\x730', '\x3', '\x2', 
		'\x2', '\x2', '\x733', '\x736', '\x3', '\x2', '\x2', '\x2', '\x734', '\x732', 
		'\x3', '\x2', '\x2', '\x2', '\x734', '\x735', '\x3', '\x2', '\x2', '\x2', 
		'\x735', '\x738', '\x3', '\x2', '\x2', '\x2', '\x736', '\x734', '\x3', 
		'\x2', '\x2', '\x2', '\x737', '\x72E', '\x3', '\x2', '\x2', '\x2', '\x737', 
		'\x738', '\x3', '\x2', '\x2', '\x2', '\x738', '\x73C', '\x3', '\x2', '\x2', 
		'\x2', '\x739', '\x73D', '\a', '\x9B', '\x2', '\x2', '\x73A', '\x73B', 
		'\a', '\xEB', '\x2', '\x2', '\x73B', '\x73D', '\a', '\x88', '\x2', '\x2', 
		'\x73C', '\x739', '\x3', '\x2', '\x2', '\x2', '\x73C', '\x73A', '\x3', 
		'\x2', '\x2', '\x2', '\x73C', '\x73D', '\x3', '\x2', '\x2', '\x2', '\x73D', 
		'\x73F', '\x3', '\x2', '\x2', '\x2', '\x73E', '\x710', '\x3', '\x2', '\x2', 
		'\x2', '\x73E', '\x711', '\x3', '\x2', '\x2', '\x2', '\x73E', '\x716', 
		'\x3', '\x2', '\x2', '\x2', '\x73E', '\x71B', '\x3', '\x2', '\x2', '\x2', 
		'\x73E', '\x724', '\x3', '\x2', '\x2', '\x2', '\x73F', '\x9B', '\x3', 
		'\x2', '\x2', '\x2', '\x740', '\x741', '\x5', '\b', '\x5', '\x2', '\x741', 
		'\x748', '\x5', 'H', '%', '\x2', '\x742', '\x743', '\a', '\x245', '\x2', 
		'\x2', '\x743', '\x744', '\x5', '\b', '\x5', '\x2', '\x744', '\x745', 
		'\x5', 'H', '%', '\x2', '\x745', '\x747', '\x3', '\x2', '\x2', '\x2', 
		'\x746', '\x742', '\x3', '\x2', '\x2', '\x2', '\x747', '\x74A', '\x3', 
		'\x2', '\x2', '\x2', '\x748', '\x746', '\x3', '\x2', '\x2', '\x2', '\x748', 
		'\x749', '\x3', '\x2', '\x2', '\x2', '\x749', '\x9D', '\x3', '\x2', '\x2', 
		'\x2', '\x74A', '\x748', '\x3', '\x2', '\x2', '\x2', '\x74B', '\x74C', 
		'\a', '\x17D', '\x2', '\x2', '\x74C', '\x74D', '\x5', '\x34', '\x1B', 
		'\x2', '\x74D', '\x9F', '\x3', '\x2', '\x2', '\x2', '\x74E', '\x758', 
		'\x5', 'H', '%', '\x2', '\x74F', '\x750', '\x5', '\x34', '\x1B', '\x2', 
		'\x750', '\x751', '\a', '\x251', '\x2', '\x2', '\x751', '\x752', '\a', 
		'\x109', '\x2', '\x2', '\x752', '\x758', '\x3', '\x2', '\x2', '\x2', '\x753', 
		'\x754', '\x5', 'N', '(', '\x2', '\x754', '\x755', '\a', '\x251', '\x2', 
		'\x2', '\x755', '\x756', '\a', '\x23B', '\x2', '\x2', '\x756', '\x758', 
		'\x3', '\x2', '\x2', '\x2', '\x757', '\x74E', '\x3', '\x2', '\x2', '\x2', 
		'\x757', '\x74F', '\x3', '\x2', '\x2', '\x2', '\x757', '\x753', '\x3', 
		'\x2', '\x2', '\x2', '\x758', '\xA1', '\x3', '\x2', '\x2', '\x2', '\x759', 
		'\x75F', '\a', '\x22B', '\x2', '\x2', '\x75A', '\x75B', '\a', '\x1B9', 
		'\x2', '\x2', '\x75B', '\x75C', '\x5', '\x142', '\xA2', '\x2', '\x75C', 
		'\x75D', '\a', '\x1B0', '\x2', '\x2', '\x75D', '\x75E', '\x5', '\xA4', 
		'S', '\x2', '\x75E', '\x760', '\x3', '\x2', '\x2', '\x2', '\x75F', '\x75A', 
		'\x3', '\x2', '\x2', '\x2', '\x760', '\x761', '\x3', '\x2', '\x2', '\x2', 
		'\x761', '\x75F', '\x3', '\x2', '\x2', '\x2', '\x761', '\x762', '\x3', 
		'\x2', '\x2', '\x2', '\x762', '\xA3', '\x3', '\x2', '\x2', '\x2', '\x763', 
		'\x765', '\x5', '\xA6', 'T', '\x2', '\x764', '\x766', '\a', '\x244', '\x2', 
		'\x2', '\x765', '\x764', '\x3', '\x2', '\x2', '\x2', '\x765', '\x766', 
		'\x3', '\x2', '\x2', '\x2', '\x766', '\x768', '\x3', '\x2', '\x2', '\x2', 
		'\x767', '\x763', '\x3', '\x2', '\x2', '\x2', '\x768', '\x76B', '\x3', 
		'\x2', '\x2', '\x2', '\x769', '\x767', '\x3', '\x2', '\x2', '\x2', '\x769', 
		'\x76A', '\x3', '\x2', '\x2', '\x2', '\x76A', '\xA5', '\x3', '\x2', '\x2', 
		'\x2', '\x76B', '\x769', '\x3', '\x2', '\x2', '\x2', '\x76C', '\x775', 
		'\x5', '\x4', '\x3', '\x2', '\x76D', '\x775', '\x5', '\xA8', 'U', '\x2', 
		'\x76E', '\x775', '\x5', '\xB0', 'Y', '\x2', '\x76F', '\x775', '\x5', 
		'\xE6', 't', '\x2', '\x770', '\x775', '\x5', '\xEE', 'x', '\x2', '\x771', 
		'\x775', '\x5', '\xF6', '|', '\x2', '\x772', '\x775', '\x5', '\xFE', '\x80', 
		'\x2', '\x773', '\x775', '\x5', '\x106', '\x84', '\x2', '\x774', '\x76C', 
		'\x3', '\x2', '\x2', '\x2', '\x774', '\x76D', '\x3', '\x2', '\x2', '\x2', 
		'\x774', '\x76E', '\x3', '\x2', '\x2', '\x2', '\x774', '\x76F', '\x3', 
		'\x2', '\x2', '\x2', '\x774', '\x770', '\x3', '\x2', '\x2', '\x2', '\x774', 
		'\x771', '\x3', '\x2', '\x2', '\x2', '\x774', '\x772', '\x3', '\x2', '\x2', 
		'\x2', '\x774', '\x773', '\x3', '\x2', '\x2', '\x2', '\x775', '\xA7', 
		'\x3', '\x2', '\x2', '\x2', '\x776', '\x78D', '\x5', '\x120', '\x91', 
		'\x2', '\x777', '\x778', '\a', 'T', '\x2', '\x2', '\x778', '\x77A', '\x5', 
		'\x142', '\xA2', '\x2', '\x779', '\x77B', '\x5', '\x11E', '\x90', '\x2', 
		'\x77A', '\x779', '\x3', '\x2', '\x2', '\x2', '\x77A', '\x77B', '\x3', 
		'\x2', '\x2', '\x2', '\x77B', '\x78D', '\x3', '\x2', '\x2', '\x2', '\x77C', 
		'\x77D', '\a', '\x235', '\x2', '\x2', '\x77D', '\x78D', '\x5', '\xAE', 
		'X', '\x2', '\x77E', '\x780', '\a', '\x22D', '\x2', '\x2', '\x77F', '\x781', 
		'\t', '\x16', '\x2', '\x2', '\x780', '\x77F', '\x3', '\x2', '\x2', '\x2', 
		'\x780', '\x781', '\x3', '\x2', '\x2', '\x2', '\x781', '\x782', '\x3', 
		'\x2', '\x2', '\x2', '\x782', '\x783', '\a', '\x226', '\x2', '\x2', '\x783', 
		'\x788', '\x5', '\xAA', 'V', '\x2', '\x784', '\x785', '\a', '\x245', '\x2', 
		'\x2', '\x785', '\x787', '\x5', '\xAA', 'V', '\x2', '\x786', '\x784', 
		'\x3', '\x2', '\x2', '\x2', '\x787', '\x78A', '\x3', '\x2', '\x2', '\x2', 
		'\x788', '\x786', '\x3', '\x2', '\x2', '\x2', '\x788', '\x789', '\x3', 
		'\x2', '\x2', '\x2', '\x789', '\x78D', '\x3', '\x2', '\x2', '\x2', '\x78A', 
		'\x788', '\x3', '\x2', '\x2', '\x2', '\x78B', '\x78D', '\a', '\x1A1', 
		'\x2', '\x2', '\x78C', '\x776', '\x3', '\x2', '\x2', '\x2', '\x78C', '\x777', 
		'\x3', '\x2', '\x2', '\x2', '\x78C', '\x77C', '\x3', '\x2', '\x2', '\x2', 
		'\x78C', '\x77E', '\x3', '\x2', '\x2', '\x2', '\x78C', '\x78B', '\x3', 
		'\x2', '\x2', '\x2', '\x78D', '\xA9', '\x3', '\x2', '\x2', '\x2', '\x78E', 
		'\x78F', '\x5', '\xAC', 'W', '\x2', '\x78F', '\x790', '\t', '\x17', '\x2', 
		'\x2', '\x790', '\x791', '\x5', '\b', '\x5', '\x2', '\x791', '\xAB', '\x3', 
		'\x2', '\x2', '\x2', '\x792', '\x795', '\x5', '\x34', '\x1B', '\x2', '\x793', 
		'\x795', '\a', '\x264', '\x2', '\x2', '\x794', '\x792', '\x3', '\x2', 
		'\x2', '\x2', '\x794', '\x793', '\x3', '\x2', '\x2', '\x2', '\x795', '\x79C', 
		'\x3', '\x2', '\x2', '\x2', '\x796', '\x797', '\a', '\x257', '\x2', '\x2', 
		'\x797', '\x798', '\x5', '\x142', '\xA2', '\x2', '\x798', '\x799', '\a', 
		'\x258', '\x2', '\x2', '\x799', '\x79B', '\x3', '\x2', '\x2', '\x2', '\x79A', 
		'\x796', '\x3', '\x2', '\x2', '\x2', '\x79B', '\x79E', '\x3', '\x2', '\x2', 
		'\x2', '\x79C', '\x79A', '\x3', '\x2', '\x2', '\x2', '\x79C', '\x79D', 
		'\x3', '\x2', '\x2', '\x2', '\x79D', '\xAD', '\x3', '\x2', '\x2', '\x2', 
		'\x79E', '\x79C', '\x3', '\x2', '\x2', '\x2', '\x79F', '\x7AC', '\x5', 
		'|', '?', '\x2', '\x7A0', '\x7A1', '\a', '\x1A3', '\x2', '\x2', '\x7A1', 
		'\x7A2', '\a', '\x24B', '\x2', '\x2', '\x7A2', '\x7A7', '\x5', '\x142', 
		'\xA2', '\x2', '\x7A3', '\x7A4', '\a', '\x245', '\x2', '\x2', '\x7A4', 
		'\x7A6', '\x5', '\x142', '\xA2', '\x2', '\x7A5', '\x7A3', '\x3', '\x2', 
		'\x2', '\x2', '\x7A6', '\x7A9', '\x3', '\x2', '\x2', '\x2', '\x7A7', '\x7A5', 
		'\x3', '\x2', '\x2', '\x2', '\x7A7', '\x7A8', '\x3', '\x2', '\x2', '\x2', 
		'\x7A8', '\x7AA', '\x3', '\x2', '\x2', '\x2', '\x7A9', '\x7A7', '\x3', 
		'\x2', '\x2', '\x2', '\x7AA', '\x7AB', '\a', '\x24C', '\x2', '\x2', '\x7AB', 
		'\x7AD', '\x3', '\x2', '\x2', '\x2', '\x7AC', '\x7A0', '\x3', '\x2', '\x2', 
		'\x2', '\x7AC', '\x7AD', '\x3', '\x2', '\x2', '\x2', '\x7AD', '\x7AF', 
		'\x3', '\x2', '\x2', '\x2', '\x7AE', '\x79F', '\x3', '\x2', '\x2', '\x2', 
		'\x7AE', '\x7AF', '\x3', '\x2', '\x2', '\x2', '\x7AF', '\x7B0', '\x3', 
		'\x2', '\x2', '\x2', '\x7B0', '\x7BA', '\x5', '\x36', '\x1C', '\x2', '\x7B1', 
		'\x7B2', '\a', '\x193', '\x2', '\x2', '\x7B2', '\x7B7', '\x5', '\x42', 
		'\"', '\x2', '\x7B3', '\x7B4', '\a', '\x245', '\x2', '\x2', '\x7B4', '\x7B6', 
		'\x5', '\x42', '\"', '\x2', '\x7B5', '\x7B3', '\x3', '\x2', '\x2', '\x2', 
		'\x7B6', '\x7B9', '\x3', '\x2', '\x2', '\x2', '\x7B7', '\x7B5', '\x3', 
		'\x2', '\x2', '\x2', '\x7B7', '\x7B8', '\x3', '\x2', '\x2', '\x2', '\x7B8', 
		'\x7BB', '\x3', '\x2', '\x2', '\x2', '\x7B9', '\x7B7', '\x3', '\x2', '\x2', 
		'\x2', '\x7BA', '\x7B1', '\x3', '\x2', '\x2', '\x2', '\x7BA', '\x7BB', 
		'\x3', '\x2', '\x2', '\x2', '\x7BB', '\x7BE', '\x3', '\x2', '\x2', '\x2', 
		'\x7BC', '\x7BD', '\a', '\x1BA', '\x2', '\x2', '\x7BD', '\x7BF', '\x5', 
		'\x142', '\xA2', '\x2', '\x7BE', '\x7BC', '\x3', '\x2', '\x2', '\x2', 
		'\x7BE', '\x7BF', '\x3', '\x2', '\x2', '\x2', '\x7BF', '\x7C1', '\x3', 
		'\x2', '\x2', '\x2', '\x7C0', '\x7C2', '\x5', '<', '\x1F', '\x2', '\x7C1', 
		'\x7C0', '\x3', '\x2', '\x2', '\x2', '\x7C1', '\x7C2', '\x3', '\x2', '\x2', 
		'\x2', '\x7C2', '\x7C5', '\x3', '\x2', '\x2', '\x2', '\x7C3', '\x7C4', 
		'\a', '\x196', '\x2', '\x2', '\x7C4', '\x7C6', '\x5', '\x142', '\xA2', 
		'\x2', '\x7C5', '\x7C3', '\x3', '\x2', '\x2', '\x2', '\x7C5', '\x7C6', 
		'\x3', '\x2', '\x2', '\x2', '\x7C6', '\x7D5', '\x3', '\x2', '\x2', '\x2', 
		'\x7C7', '\x7C8', '\a', '\x1BB', '\x2', '\x2', '\x7C8', '\x7C9', '\x5', 
		'\b', '\x5', '\x2', '\x7C9', '\x7CA', '\a', '\x176', '\x2', '\x2', '\x7CA', 
		'\x7D2', '\x5', '\x18', '\r', '\x2', '\x7CB', '\x7CC', '\a', '\x245', 
		'\x2', '\x2', '\x7CC', '\x7CD', '\x5', '\b', '\x5', '\x2', '\x7CD', '\x7CE', 
		'\a', '\x176', '\x2', '\x2', '\x7CE', '\x7CF', '\x5', '\x18', '\r', '\x2', 
		'\x7CF', '\x7D1', '\x3', '\x2', '\x2', '\x2', '\x7D0', '\x7CB', '\x3', 
		'\x2', '\x2', '\x2', '\x7D1', '\x7D4', '\x3', '\x2', '\x2', '\x2', '\x7D2', 
		'\x7D0', '\x3', '\x2', '\x2', '\x2', '\x7D2', '\x7D3', '\x3', '\x2', '\x2', 
		'\x2', '\x7D3', '\x7D6', '\x3', '\x2', '\x2', '\x2', '\x7D4', '\x7D2', 
		'\x3', '\x2', '\x2', '\x2', '\x7D5', '\x7C7', '\x3', '\x2', '\x2', '\x2', 
		'\x7D5', '\x7D6', '\x3', '\x2', '\x2', '\x2', '\x7D6', '\x7DC', '\x3', 
		'\x2', '\x2', '\x2', '\x7D7', '\x7D9', '\t', '\x4', '\x2', '\x2', '\x7D8', 
		'\x7DA', '\x5', '|', '?', '\x2', '\x7D9', '\x7D8', '\x3', '\x2', '\x2', 
		'\x2', '\x7D9', '\x7DA', '\x3', '\x2', '\x2', '\x2', '\x7DA', '\x7DB', 
		'\x3', '\x2', '\x2', '\x2', '\x7DB', '\x7DD', '\x5', '\x14', '\v', '\x2', 
		'\x7DC', '\x7D7', '\x3', '\x2', '\x2', '\x2', '\x7DC', '\x7DD', '\x3', 
		'\x2', '\x2', '\x2', '\x7DD', '\x7E1', '\x3', '\x2', '\x2', '\x2', '\x7DE', 
		'\x7E0', '\x5', '\x9A', 'N', '\x2', '\x7DF', '\x7DE', '\x3', '\x2', '\x2', 
		'\x2', '\x7E0', '\x7E3', '\x3', '\x2', '\x2', '\x2', '\x7E1', '\x7DF', 
		'\x3', '\x2', '\x2', '\x2', '\x7E1', '\x7E2', '\x3', '\x2', '\x2', '\x2', 
		'\x7E2', '\xAF', '\x3', '\x2', '\x2', '\x2', '\x7E3', '\x7E1', '\x3', 
		'\x2', '\x2', '\x2', '\x7E4', '\x7EB', '\x5', '\xB2', 'Z', '\x2', '\x7E5', 
		'\x7E6', '\a', '\x18', '\x2', '\x2', '\x7E6', '\x7EB', '\x5', 'X', '-', 
		'\x2', '\x7E7', '\x7EB', '\x5', '\xDA', 'n', '\x2', '\x7E8', '\x7EB', 
		'\x5', '\xDC', 'o', '\x2', '\x7E9', '\x7EB', '\x5', '\xDE', 'p', '\x2', 
		'\x7EA', '\x7E4', '\x3', '\x2', '\x2', '\x2', '\x7EA', '\x7E5', '\x3', 
		'\x2', '\x2', '\x2', '\x7EA', '\x7E7', '\x3', '\x2', '\x2', '\x2', '\x7EA', 
		'\x7E8', '\x3', '\x2', '\x2', '\x2', '\x7EA', '\x7E9', '\x3', '\x2', '\x2', 
		'\x2', '\x7EB', '\xB1', '\x3', '\x2', '\x2', '\x2', '\x7EC', '\x7ED', 
		'\a', '\x239', '\x2', '\x2', '\x7ED', '\x7F2', '\a', '\x236', '\x2', '\x2', 
		'\x7EE', '\x7F3', '\x5', '\x12', '\n', '\x2', '\x7EF', '\x7F3', '\x5', 
		'\xD8', 'm', '\x2', '\x7F0', '\x7F3', '\x5', '\xD6', 'l', '\x2', '\x7F1', 
		'\x7F3', '\x5', '\xB4', '[', '\x2', '\x7F2', '\x7EE', '\x3', '\x2', '\x2', 
		'\x2', '\x7F2', '\x7EF', '\x3', '\x2', '\x2', '\x2', '\x7F2', '\x7F0', 
		'\x3', '\x2', '\x2', '\x2', '\x7F2', '\x7F1', '\x3', '\x2', '\x2', '\x2', 
		'\x7F3', '\x7FC', '\x3', '\x2', '\x2', '\x2', '\x7F4', '\x7F5', '\a', 
		'\x239', '\x2', '\x2', '\x7F5', '\x7F6', '\a', '\x97', '\x2', '\x2', '\x7F6', 
		'\x7FC', '\x5', '\x142', '\xA2', '\x2', '\x7F7', '\x7F9', '\a', '\x239', 
		'\x2', '\x2', '\x7F8', '\x7FA', '\x5', '\xAE', 'X', '\x2', '\x7F9', '\x7F8', 
		'\x3', '\x2', '\x2', '\x2', '\x7F9', '\x7FA', '\x3', '\x2', '\x2', '\x2', 
		'\x7FA', '\x7FC', '\x3', '\x2', '\x2', '\x2', '\x7FB', '\x7EC', '\x3', 
		'\x2', '\x2', '\x2', '\x7FB', '\x7F4', '\x3', '\x2', '\x2', '\x2', '\x7FB', 
		'\x7F7', '\x3', '\x2', '\x2', '\x2', '\x7FC', '\xB3', '\x3', '\x2', '\x2', 
		'\x2', '\x7FD', '\x80F', '\a', 'U', '\x2', '\x2', '\x7FE', '\x800', '\a', 
		'\x172', '\x2', '\x2', '\x7FF', '\x7FE', '\x3', '\x2', '\x2', '\x2', '\x7FF', 
		'\x800', '\x3', '\x2', '\x2', '\x2', '\x800', '\x802', '\x3', '\x2', '\x2', 
		'\x2', '\x801', '\x803', '\a', '\x16F', '\x2', '\x2', '\x802', '\x801', 
		'\x3', '\x2', '\x2', '\x2', '\x802', '\x803', '\x3', '\x2', '\x2', '\x2', 
		'\x803', '\x810', '\x3', '\x2', '\x2', '\x2', '\x804', '\x805', '\a', 
		'\x24B', '\x2', '\x2', '\x805', '\x80A', '\x5', '\xD2', 'j', '\x2', '\x806', 
		'\x807', '\a', '\x245', '\x2', '\x2', '\x807', '\x809', '\x5', '\xD2', 
		'j', '\x2', '\x808', '\x806', '\x3', '\x2', '\x2', '\x2', '\x809', '\x80C', 
		'\x3', '\x2', '\x2', '\x2', '\x80A', '\x808', '\x3', '\x2', '\x2', '\x2', 
		'\x80A', '\x80B', '\x3', '\x2', '\x2', '\x2', '\x80B', '\x80D', '\x3', 
		'\x2', '\x2', '\x2', '\x80C', '\x80A', '\x3', '\x2', '\x2', '\x2', '\x80D', 
		'\x80E', '\a', '\x24C', '\x2', '\x2', '\x80E', '\x810', '\x3', '\x2', 
		'\x2', '\x2', '\x80F', '\x7FF', '\x3', '\x2', '\x2', '\x2', '\x80F', '\x804', 
		'\x3', '\x2', '\x2', '\x2', '\x810', '\x811', '\x3', '\x2', '\x2', '\x2', 
		'\x811', '\x812', '\x5', '\xB6', '\\', '\x2', '\x812', '\xB5', '\x3', 
		'\x2', '\x2', '\x2', '\x813', '\x81D', '\x5', '\xFE', '\x80', '\x2', '\x814', 
		'\x81D', '\x5', '.', '\x18', '\x2', '\x815', '\x81D', '\x5', '\xCE', 'h', 
		'\x2', '\x816', '\x81D', '\x5', '\xD0', 'i', '\x2', '\x817', '\x81A', 
		'\a', '\x180', '\x2', '\x2', '\x818', '\x81B', '\x5', '\xB8', ']', '\x2', 
		'\x819', '\x81B', '\x5', '\xC8', '\x65', '\x2', '\x81A', '\x818', '\x3', 
		'\x2', '\x2', '\x2', '\x81A', '\x819', '\x3', '\x2', '\x2', '\x2', '\x81B', 
		'\x81D', '\x3', '\x2', '\x2', '\x2', '\x81C', '\x813', '\x3', '\x2', '\x2', 
		'\x2', '\x81C', '\x814', '\x3', '\x2', '\x2', '\x2', '\x81C', '\x815', 
		'\x3', '\x2', '\x2', '\x2', '\x81C', '\x816', '\x3', '\x2', '\x2', '\x2', 
		'\x81C', '\x817', '\x3', '\x2', '\x2', '\x2', '\x81D', '\xB7', '\x3', 
		'\x2', '\x2', '\x2', '\x81E', '\x820', '\t', '\x18', '\x2', '\x2', '\x81F', 
		'\x81E', '\x3', '\x2', '\x2', '\x2', '\x81F', '\x820', '\x3', '\x2', '\x2', 
		'\x2', '\x820', '\x821', '\x3', '\x2', '\x2', '\x2', '\x821', '\x824', 
		'\t', '\x19', '\x2', '\x2', '\x822', '\x824', '\a', '\x110', '\x2', '\x2', 
		'\x823', '\x81F', '\x3', '\x2', '\x2', '\x2', '\x823', '\x822', '\x3', 
		'\x2', '\x2', '\x2', '\x823', '\x824', '\x3', '\x2', '\x2', '\x2', '\x824', 
		'\x825', '\x3', '\x2', '\x2', '\x2', '\x825', '\x827', '\a', '\x1AF', 
		'\x2', '\x2', '\x826', '\x828', '\x5', '\xC6', '\x64', '\x2', '\x827', 
		'\x826', '\x3', '\x2', '\x2', '\x2', '\x827', '\x828', '\x3', '\x2', '\x2', 
		'\x2', '\x828', '\x829', '\x3', '\x2', '\x2', '\x2', '\x829', '\x82B', 
		'\x5', '\x34', '\x1B', '\x2', '\x82A', '\x82C', '\x5', 't', ';', '\x2', 
		'\x82B', '\x82A', '\x3', '\x2', '\x2', '\x2', '\x82B', '\x82C', '\x3', 
		'\x2', '\x2', '\x2', '\x82C', '\x82F', '\x3', '\x2', '\x2', '\x2', '\x82D', 
		'\x82E', '\a', '\x1B7', '\x2', '\x2', '\x82E', '\x830', '\x5', '\b', '\x5', 
		'\x2', '\x82F', '\x82D', '\x3', '\x2', '\x2', '\x2', '\x82F', '\x830', 
		'\x3', '\x2', '\x2', '\x2', '\x830', '\x832', '\x3', '\x2', '\x2', '\x2', 
		'\x831', '\x833', '\x5', '\xBA', '^', '\x2', '\x832', '\x831', '\x3', 
		'\x2', '\x2', '\x2', '\x832', '\x833', '\x3', '\x2', '\x2', '\x2', '\x833', 
		'\x835', '\x3', '\x2', '\x2', '\x2', '\x834', '\x836', '\x5', '\xC2', 
		'\x62', '\x2', '\x835', '\x834', '\x3', '\x2', '\x2', '\x2', '\x835', 
		'\x836', '\x3', '\x2', '\x2', '\x2', '\x836', '\x838', '\x3', '\x2', '\x2', 
		'\x2', '\x837', '\x839', '\x5', '\xC4', '\x63', '\x2', '\x838', '\x837', 
		'\x3', '\x2', '\x2', '\x2', '\x838', '\x839', '\x3', '\x2', '\x2', '\x2', 
		'\x839', '\x83A', '\x3', '\x2', '\x2', '\x2', '\x83A', '\x83E', '\a', 
		'\x176', '\x2', '\x2', '\x83B', '\x83F', '\x5', '\x12', '\n', '\x2', '\x83C', 
		'\x83D', '\a', 'T', '\x2', '\x2', '\x83D', '\x83F', '\x5', 'X', '-', '\x2', 
		'\x83E', '\x83B', '\x3', '\x2', '\x2', '\x2', '\x83E', '\x83C', '\x3', 
		'\x2', '\x2', '\x2', '\x83F', '\x845', '\x3', '\x2', '\x2', '\x2', '\x840', 
		'\x842', '\a', '\x1BC', '\x2', '\x2', '\x841', '\x843', '\a', '\x98', 
		'\x2', '\x2', '\x842', '\x841', '\x3', '\x2', '\x2', '\x2', '\x842', '\x843', 
		'\x3', '\x2', '\x2', '\x2', '\x843', '\x844', '\x3', '\x2', '\x2', '\x2', 
		'\x844', '\x846', '\a', '\x36', '\x2', '\x2', '\x845', '\x840', '\x3', 
		'\x2', '\x2', '\x2', '\x845', '\x846', '\x3', '\x2', '\x2', '\x2', '\x846', 
		'\xB9', '\x3', '\x2', '\x2', '\x2', '\x847', '\x84D', '\x5', '\xBC', '_', 
		'\x2', '\x848', '\x849', '\a', '\x1BC', '\x2', '\x2', '\x849', '\x84D', 
		'\a', '\xA0', '\x2', '\x2', '\x84A', '\x84B', '\a', '\x11F', '\x2', '\x2', 
		'\x84B', '\x84D', '\a', '\xA0', '\x2', '\x2', '\x84C', '\x847', '\x3', 
		'\x2', '\x2', '\x2', '\x84C', '\x848', '\x3', '\x2', '\x2', '\x2', '\x84C', 
		'\x84A', '\x3', '\x2', '\x2', '\x2', '\x84D', '\xBB', '\x3', '\x2', '\x2', 
		'\x2', '\x84E', '\x84F', '\a', '\x1BC', '\x2', '\x2', '\x84F', '\x850', 
		'\x5', '\xBE', '`', '\x2', '\x850', '\xBD', '\x3', '\x2', '\x2', '\x2', 
		'\x851', '\x852', '\a', '\x24B', '\x2', '\x2', '\x852', '\x857', '\x5', 
		'\xC0', '\x61', '\x2', '\x853', '\x854', '\a', '\x245', '\x2', '\x2', 
		'\x854', '\x856', '\x5', '\xC0', '\x61', '\x2', '\x855', '\x853', '\x3', 
		'\x2', '\x2', '\x2', '\x856', '\x859', '\x3', '\x2', '\x2', '\x2', '\x857', 
		'\x855', '\x3', '\x2', '\x2', '\x2', '\x857', '\x858', '\x3', '\x2', '\x2', 
		'\x2', '\x858', '\x85A', '\x3', '\x2', '\x2', '\x2', '\x859', '\x857', 
		'\x3', '\x2', '\x2', '\x2', '\x85A', '\x85B', '\a', '\x24C', '\x2', '\x2', 
		'\x85B', '\xBF', '\x3', '\x2', '\x2', '\x2', '\x85C', '\x85F', '\x5', 
		'\x34', '\x1B', '\x2', '\x85D', '\x85E', '\a', '\x242', '\x2', '\x2', 
		'\x85E', '\x860', '\x5', '\x142', '\xA2', '\x2', '\x85F', '\x85D', '\x3', 
		'\x2', '\x2', '\x2', '\x85F', '\x860', '\x3', '\x2', '\x2', '\x2', '\x860', 
		'\xC1', '\x3', '\x2', '\x2', '\x2', '\x861', '\x862', '\a', '\x1A3', '\x2', 
		'\x2', '\x862', '\x868', '\a', '&', '\x2', '\x2', '\x863', '\x864', '\a', 
		'\xB6', '\x2', '\x2', '\x864', '\x869', '\a', '\xD8', '\x2', '\x2', '\x865', 
		'\x866', '\a', '>', '\x2', '\x2', '\x866', '\x869', '\a', '\xD8', '\x2', 
		'\x2', '\x867', '\x869', '\a', 'I', '\x2', '\x2', '\x868', '\x863', '\x3', 
		'\x2', '\x2', '\x2', '\x868', '\x865', '\x3', '\x2', '\x2', '\x2', '\x868', 
		'\x867', '\x3', '\x2', '\x2', '\x2', '\x869', '\xC3', '\x3', '\x2', '\x2', 
		'\x2', '\x86A', '\x86B', '\a', '\xFE', '\x2', '\x2', '\x86B', '\x86C', 
		'\x5', '\b', '\x5', '\x2', '\x86C', '\xC5', '\x3', '\x2', '\x2', '\x2', 
		'\x86D', '\x86E', '\a', 'i', '\x2', '\x2', '\x86E', '\x86F', '\a', '\x1A0', 
		'\x2', '\x2', '\x86F', '\x870', '\a', '\x130', '\x2', '\x2', '\x870', 
		'\xC7', '\x3', '\x2', '\x2', '\x2', '\x871', '\x872', '\a', '\x1A5', '\x2', 
		'\x2', '\x872', '\x874', '\a', '\xCC', '\x2', '\x2', '\x873', '\x871', 
		'\x3', '\x2', '\x2', '\x2', '\x873', '\x874', '\x3', '\x2', '\x2', '\x2', 
		'\x874', '\x876', '\x3', '\x2', '\x2', '\x2', '\x875', '\x877', '\t', 
		'\x19', '\x2', '\x2', '\x876', '\x875', '\x3', '\x2', '\x2', '\x2', '\x876', 
		'\x877', '\x3', '\x2', '\x2', '\x2', '\x877', '\x879', '\x3', '\x2', '\x2', 
		'\x2', '\x878', '\x87A', '\a', '\xC3', '\x2', '\x2', '\x879', '\x878', 
		'\x3', '\x2', '\x2', '\x2', '\x879', '\x87A', '\x3', '\x2', '\x2', '\x2', 
		'\x87A', '\x87C', '\x3', '\x2', '\x2', '\x2', '\x87B', '\x87D', '\a', 
		'\x8C', '\x2', '\x2', '\x87C', '\x87B', '\x3', '\x2', '\x2', '\x2', '\x87C', 
		'\x87D', '\x3', '\x2', '\x2', '\x2', '\x87D', '\x87E', '\x3', '\x2', '\x2', 
		'\x2', '\x87E', '\x880', '\a', '\x11A', '\x2', '\x2', '\x87F', '\x881', 
		'\x5', '\xC6', '\x64', '\x2', '\x880', '\x87F', '\x3', '\x2', '\x2', '\x2', 
		'\x880', '\x881', '\x3', '\x2', '\x2', '\x2', '\x881', '\x882', '\x3', 
		'\x2', '\x2', '\x2', '\x882', '\x884', '\x5', '\x34', '\x1B', '\x2', '\x883', 
		'\x885', '\x5', '\xCA', '\x66', '\x2', '\x884', '\x883', '\x3', '\x2', 
		'\x2', '\x2', '\x884', '\x885', '\x3', '\x2', '\x2', '\x2', '\x885', '\x888', 
		'\x3', '\x2', '\x2', '\x2', '\x886', '\x887', '\a', '\x1B7', '\x2', '\x2', 
		'\x887', '\x889', '\x5', '\b', '\x5', '\x2', '\x888', '\x886', '\x3', 
		'\x2', '\x2', '\x2', '\x888', '\x889', '\x3', '\x2', '\x2', '\x2', '\x889', 
		'\x88C', '\x3', '\x2', '\x2', '\x2', '\x88A', '\x88B', '\a', '\x1BC', 
		'\x2', '\x2', '\x88B', '\x88D', '\x5', '\xBE', '`', '\x2', '\x88C', '\x88A', 
		'\x3', '\x2', '\x2', '\x2', '\x88C', '\x88D', '\x3', '\x2', '\x2', '\x2', 
		'\x88D', '\x88F', '\x3', '\x2', '\x2', '\x2', '\x88E', '\x890', '\x5', 
		'\xC4', '\x63', '\x2', '\x88F', '\x88E', '\x3', '\x2', '\x2', '\x2', '\x88F', 
		'\x890', '\x3', '\x2', '\x2', '\x2', '\x890', '\x891', '\x3', '\x2', '\x2', 
		'\x2', '\x891', '\x892', '\a', '\x176', '\x2', '\x2', '\x892', '\x894', 
		'\x5', '\x12', '\n', '\x2', '\x893', '\x895', '\x5', '\xCC', 'g', '\x2', 
		'\x894', '\x893', '\x3', '\x2', '\x2', '\x2', '\x894', '\x895', '\x3', 
		'\x2', '\x2', '\x2', '\x895', '\x89B', '\x3', '\x2', '\x2', '\x2', '\x896', 
		'\x898', '\a', '\x1BC', '\x2', '\x2', '\x897', '\x899', '\a', '\x98', 
		'\x2', '\x2', '\x898', '\x897', '\x3', '\x2', '\x2', '\x2', '\x898', '\x899', 
		'\x3', '\x2', '\x2', '\x2', '\x899', '\x89A', '\x3', '\x2', '\x2', '\x2', 
		'\x89A', '\x89C', '\a', '\x36', '\x2', '\x2', '\x89B', '\x896', '\x3', 
		'\x2', '\x2', '\x2', '\x89B', '\x89C', '\x3', '\x2', '\x2', '\x2', '\x89C', 
		'\xC9', '\x3', '\x2', '\x2', '\x2', '\x89D', '\x89E', '\a', '\x24B', '\x2', 
		'\x2', '\x89E', '\x8A3', '\x5', '\b', '\x5', '\x2', '\x89F', '\x8A0', 
		'\a', '\x245', '\x2', '\x2', '\x8A0', '\x8A2', '\x5', '\b', '\x5', '\x2', 
		'\x8A1', '\x89F', '\x3', '\x2', '\x2', '\x2', '\x8A2', '\x8A5', '\x3', 
		'\x2', '\x2', '\x2', '\x8A3', '\x8A1', '\x3', '\x2', '\x2', '\x2', '\x8A3', 
		'\x8A4', '\x3', '\x2', '\x2', '\x2', '\x8A4', '\x8A6', '\x3', '\x2', '\x2', 
		'\x2', '\x8A5', '\x8A3', '\x3', '\x2', '\x2', '\x2', '\x8A6', '\x8A7', 
		'\a', '\x24C', '\x2', '\x2', '\x8A7', '\xCB', '\x3', '\x2', '\x2', '\x2', 
		'\x8A8', '\x8AA', '\a', '\x1BC', '\x2', '\x2', '\x8A9', '\x8AB', '\t', 
		'\x1A', '\x2', '\x2', '\x8AA', '\x8A9', '\x3', '\x2', '\x2', '\x2', '\x8AA', 
		'\x8AB', '\x3', '\x2', '\x2', '\x2', '\x8AB', '\x8AC', '\x3', '\x2', '\x2', 
		'\x2', '\x8AC', '\x8AD', '\a', '\x17C', '\x2', '\x2', '\x8AD', '\x8AE', 
		'\a', '\xA3', '\x2', '\x2', '\x8AE', '\xCD', '\x3', '\x2', '\x2', '\x2', 
		'\x8AF', '\x8B0', '\a', 'T', '\x2', '\x2', '\x8B0', '\x8BC', '\x5', '\b', 
		'\x5', '\x2', '\x8B1', '\x8B2', '\a', '\x24B', '\x2', '\x2', '\x8B2', 
		'\x8B7', '\x5', '\x142', '\xA2', '\x2', '\x8B3', '\x8B4', '\a', '\x245', 
		'\x2', '\x2', '\x8B4', '\x8B6', '\x5', '\x142', '\xA2', '\x2', '\x8B5', 
		'\x8B3', '\x3', '\x2', '\x2', '\x2', '\x8B6', '\x8B9', '\x3', '\x2', '\x2', 
		'\x2', '\x8B7', '\x8B5', '\x3', '\x2', '\x2', '\x2', '\x8B7', '\x8B8', 
		'\x3', '\x2', '\x2', '\x2', '\x8B8', '\x8BA', '\x3', '\x2', '\x2', '\x2', 
		'\x8B9', '\x8B7', '\x3', '\x2', '\x2', '\x2', '\x8BA', '\x8BB', '\a', 
		'\x24C', '\x2', '\x2', '\x8BB', '\x8BD', '\x3', '\x2', '\x2', '\x2', '\x8BC', 
		'\x8B1', '\x3', '\x2', '\x2', '\x2', '\x8BC', '\x8BD', '\x3', '\x2', '\x2', 
		'\x2', '\x8BD', '\xCF', '\x3', '\x2', '\x2', '\x2', '\x8BE', '\x8BF', 
		'\a', ':', '\x2', '\x2', '\x8BF', '\x8C1', '\x5', '\b', '\x5', '\x2', 
		'\x8C0', '\x8C2', '\a', '\x15A', '\x2', '\x2', '\x8C1', '\x8C0', '\x3', 
		'\x2', '\x2', '\x2', '\x8C1', '\x8C2', '\x3', '\x2', '\x2', '\x2', '\x8C2', 
		'\x8C4', '\x3', '\x2', '\x2', '\x2', '\x8C3', '\x8C5', '\a', 'w', '\x2', 
		'\x2', '\x8C4', '\x8C3', '\x3', '\x2', '\x2', '\x2', '\x8C4', '\x8C5', 
		'\x3', '\x2', '\x2', '\x2', '\x8C5', '\x8CA', '\x3', '\x2', '\x2', '\x2', 
		'\x8C6', '\x8C8', '\a', '\x98', '\x2', '\x2', '\x8C7', '\x8C6', '\x3', 
		'\x2', '\x2', '\x2', '\x8C7', '\x8C8', '\x3', '\x2', '\x2', '\x2', '\x8C8', 
		'\x8C9', '\x3', '\x2', '\x2', '\x2', '\x8C9', '\x8CB', '\a', '\xDD', '\x2', 
		'\x2', '\x8CA', '\x8C7', '\x3', '\x2', '\x2', '\x2', '\x8CA', '\x8CB', 
		'\x3', '\x2', '\x2', '\x2', '\x8CB', '\x8CC', '\x3', '\x2', '\x2', '\x2', 
		'\x8CC', '\x8CF', '\a', '\x34', '\x2', '\x2', '\x8CD', '\x8CE', '\t', 
		'\v', '\x2', '\x2', '\x8CE', '\x8D0', '\a', '\x66', '\x2', '\x2', '\x8CF', 
		'\x8CD', '\x3', '\x2', '\x2', '\x2', '\x8CF', '\x8D0', '\x3', '\x2', '\x2', 
		'\x2', '\x8D0', '\x8D1', '\x3', '\x2', '\x2', '\x2', '\x8D1', '\x8D2', 
		'\a', '\x191', '\x2', '\x2', '\x8D2', '\x8D3', '\x5', '\x12', '\n', '\x2', 
		'\x8D3', '\xD1', '\x3', '\x2', '\x2', '\x2', '\x8D4', '\x8D6', '\t', '\x1B', 
		'\x2', '\x2', '\x8D5', '\x8D7', '\x5', '\xD4', 'k', '\x2', '\x8D6', '\x8D5', 
		'\x3', '\x2', '\x2', '\x2', '\x8D6', '\x8D7', '\x3', '\x2', '\x2', '\x2', 
		'\x8D7', '\x8DB', '\x3', '\x2', '\x2', '\x2', '\x8D8', '\x8D9', '\a', 
		'\x1D5', '\x2', '\x2', '\x8D9', '\x8DB', '\t', '\x1C', '\x2', '\x2', '\x8DA', 
		'\x8D4', '\x3', '\x2', '\x2', '\x2', '\x8DA', '\x8D8', '\x3', '\x2', '\x2', 
		'\x2', '\x8DB', '\xD3', '\x3', '\x2', '\x2', '\x2', '\x8DC', '\x8DD', 
		'\t', '\x1D', '\x2', '\x2', '\x8DD', '\xD5', '\x3', '\x2', '\x2', '\x2', 
		'\x8DE', '\x8ED', '\a', '\xE9', '\x2', '\x2', '\x8DF', '\x8E0', '\x5', 
		'\b', '\x5', '\x2', '\x8E0', '\x8E1', '\a', '\x253', '\x2', '\x2', '\x8E1', 
		'\x8E3', '\x3', '\x2', '\x2', '\x2', '\x8E2', '\x8DF', '\x3', '\x2', '\x2', 
		'\x2', '\x8E2', '\x8E3', '\x3', '\x2', '\x2', '\x2', '\x8E3', '\x8E4', 
		'\x3', '\x2', '\x2', '\x2', '\x8E4', '\x8EE', '\x5', '\b', '\x5', '\x2', 
		'\x8E5', '\x8EE', '\a', '\x170', '\x2', '\x2', '\x8E6', '\x8E7', '\a', 
		'\x148', '\x2', '\x2', '\x8E7', '\x8EE', '\a', '\x126', '\x2', '\x2', 
		'\x8E8', '\x8E9', '\a', '\x104', '\x2', '\x2', '\x8E9', '\x8EA', '\a', 
		'{', '\x2', '\x2', '\x8EA', '\x8EE', '\a', '\x82', '\x2', '\x2', '\x8EB', 
		'\x8EC', '\a', '\xE5', '\x2', '\x2', '\x8EC', '\x8EE', '\a', '\x159', 
		'\x2', '\x2', '\x8ED', '\x8E2', '\x3', '\x2', '\x2', '\x2', '\x8ED', '\x8E5', 
		'\x3', '\x2', '\x2', '\x2', '\x8ED', '\x8E6', '\x3', '\x2', '\x2', '\x2', 
		'\x8ED', '\x8E8', '\x3', '\x2', '\x2', '\x2', '\x8ED', '\x8EB', '\x3', 
		'\x2', '\x2', '\x2', '\x8EE', '\xD7', '\x3', '\x2', '\x2', '\x2', '\x8EF', 
		'\x8F0', '\a', 'T', '\x2', '\x2', '\x8F0', '\x8F2', '\x5', '\x142', '\xA2', 
		'\x2', '\x8F1', '\x8F3', '\x5', '\x11E', '\x90', '\x2', '\x8F2', '\x8F1', 
		'\x3', '\x2', '\x2', '\x2', '\x8F2', '\x8F3', '\x3', '\x2', '\x2', '\x2', 
		'\x8F3', '\xD9', '\x3', '\x2', '\x2', '\x2', '\x8F4', '\x8F5', '\a', 'i', 
		'\x2', '\x2', '\x8F5', '\x8F6', '\x5', '\x142', '\xA2', '\x2', '\x8F6', 
		'\x8F7', '\a', '\x1B0', '\x2', '\x2', '\x8F7', '\x8FF', '\x5', '\xA4', 
		'S', '\x2', '\x8F8', '\x8F9', '\t', '\x1E', '\x2', '\x2', '\x8F9', '\x8FA', 
		'\x5', '\x142', '\xA2', '\x2', '\x8FA', '\x8FB', '\a', '\x1B0', '\x2', 
		'\x2', '\x8FB', '\x8FC', '\x5', '\xA4', 'S', '\x2', '\x8FC', '\x8FE', 
		'\x3', '\x2', '\x2', '\x2', '\x8FD', '\x8F8', '\x3', '\x2', '\x2', '\x2', 
		'\x8FE', '\x901', '\x3', '\x2', '\x2', '\x2', '\x8FF', '\x8FD', '\x3', 
		'\x2', '\x2', '\x2', '\x8FF', '\x900', '\x3', '\x2', '\x2', '\x2', '\x900', 
		'\x904', '\x3', '\x2', '\x2', '\x2', '\x901', '\x8FF', '\x3', '\x2', '\x2', 
		'\x2', '\x902', '\x903', '\a', '\x18C', '\x2', '\x2', '\x903', '\x905', 
		'\x5', '\xA4', 'S', '\x2', '\x904', '\x902', '\x3', '\x2', '\x2', '\x2', 
		'\x904', '\x905', '\x3', '\x2', '\x2', '\x2', '\x905', '\x906', '\x3', 
		'\x2', '\x2', '\x2', '\x906', '\x907', '\a', '\x18D', '\x2', '\x2', '\x907', 
		'\x908', '\a', 'i', '\x2', '\x2', '\x908', '\xDB', '\x3', '\x2', '\x2', 
		'\x2', '\x909', '\x90B', '\a', '\x17A', '\x2', '\x2', '\x90A', '\x90C', 
		'\x5', '\x142', '\xA2', '\x2', '\x90B', '\x90A', '\x3', '\x2', '\x2', 
		'\x2', '\x90B', '\x90C', '\x3', '\x2', '\x2', '\x2', '\x90C', '\x919', 
		'\x3', '\x2', '\x2', '\x2', '\x90D', '\x90E', '\a', '\x1B9', '\x2', '\x2', 
		'\x90E', '\x913', '\x5', '\x142', '\xA2', '\x2', '\x90F', '\x910', '\a', 
		'\x245', '\x2', '\x2', '\x910', '\x912', '\x5', '\x142', '\xA2', '\x2', 
		'\x911', '\x90F', '\x3', '\x2', '\x2', '\x2', '\x912', '\x915', '\x3', 
		'\x2', '\x2', '\x2', '\x913', '\x911', '\x3', '\x2', '\x2', '\x2', '\x913', 
		'\x914', '\x3', '\x2', '\x2', '\x2', '\x914', '\x916', '\x3', '\x2', '\x2', 
		'\x2', '\x915', '\x913', '\x3', '\x2', '\x2', '\x2', '\x916', '\x917', 
		'\a', '\x1B0', '\x2', '\x2', '\x917', '\x918', '\x5', '\xA4', 'S', '\x2', 
		'\x918', '\x91A', '\x3', '\x2', '\x2', '\x2', '\x919', '\x90D', '\x3', 
		'\x2', '\x2', '\x2', '\x91A', '\x91B', '\x3', '\x2', '\x2', '\x2', '\x91B', 
		'\x919', '\x3', '\x2', '\x2', '\x2', '\x91B', '\x91C', '\x3', '\x2', '\x2', 
		'\x2', '\x91C', '\x91F', '\x3', '\x2', '\x2', '\x2', '\x91D', '\x91E', 
		'\a', '\x18C', '\x2', '\x2', '\x91E', '\x920', '\x5', '\xA4', 'S', '\x2', 
		'\x91F', '\x91D', '\x3', '\x2', '\x2', '\x2', '\x91F', '\x920', '\x3', 
		'\x2', '\x2', '\x2', '\x920', '\x921', '\x3', '\x2', '\x2', '\x2', '\x921', 
		'\x922', '\a', '\x18D', '\x2', '\x2', '\x922', '\x923', '\a', '\x17A', 
		'\x2', '\x2', '\x923', '\xDD', '\x3', '\x2', '\x2', '\x2', '\x924', '\x926', 
		'\x5', '\n', '\x6', '\x2', '\x925', '\x924', '\x3', '\x2', '\x2', '\x2', 
		'\x925', '\x926', '\x3', '\x2', '\x2', '\x2', '\x926', '\x928', '\x3', 
		'\x2', '\x2', '\x2', '\x927', '\x929', '\x5', '\xE0', 'q', '\x2', '\x928', 
		'\x927', '\x3', '\x2', '\x2', '\x2', '\x928', '\x929', '\x3', '\x2', '\x2', 
		'\x2', '\x929', '\x92A', '\x3', '\x2', '\x2', '\x2', '\x92A', '\x92B', 
		'\a', '\x231', '\x2', '\x2', '\x92B', '\x92C', '\x5', '\xA4', 'S', '\x2', 
		'\x92C', '\x92D', '\a', '\x18D', '\x2', '\x2', '\x92D', '\x92F', '\a', 
		'\x231', '\x2', '\x2', '\x92E', '\x930', '\x5', '\b', '\x5', '\x2', '\x92F', 
		'\x92E', '\x3', '\x2', '\x2', '\x2', '\x92F', '\x930', '\x3', '\x2', '\x2', 
		'\x2', '\x930', '\x93A', '\x3', '\x2', '\x2', '\x2', '\x931', '\x933', 
		'\t', '\x1F', '\x2', '\x2', '\x932', '\x934', '\x5', '\b', '\x5', '\x2', 
		'\x933', '\x932', '\x3', '\x2', '\x2', '\x2', '\x933', '\x934', '\x3', 
		'\x2', '\x2', '\x2', '\x934', '\x937', '\x3', '\x2', '\x2', '\x2', '\x935', 
		'\x936', '\a', '\x1B9', '\x2', '\x2', '\x936', '\x938', '\x5', '\x142', 
		'\xA2', '\x2', '\x937', '\x935', '\x3', '\x2', '\x2', '\x2', '\x937', 
		'\x938', '\x3', '\x2', '\x2', '\x2', '\x938', '\x93A', '\x3', '\x2', '\x2', 
		'\x2', '\x939', '\x925', '\x3', '\x2', '\x2', '\x2', '\x939', '\x931', 
		'\x3', '\x2', '\x2', '\x2', '\x93A', '\xDF', '\x3', '\x2', '\x2', '\x2', 
		'\x93B', '\x93C', '\a', '\x240', '\x2', '\x2', '\x93C', '\x96D', '\x5', 
		'\x142', '\xA2', '\x2', '\x93D', '\x93E', '\a', '\x191', '\x2', '\x2', 
		'\x93E', '\x93F', '\x5', '\b', '\x5', '\x2', '\x93F', '\x941', '\a', '\x197', 
		'\x2', '\x2', '\x940', '\x942', '\a', '\x23A', '\x2', '\x2', '\x941', 
		'\x940', '\x3', '\x2', '\x2', '\x2', '\x941', '\x942', '\x3', '\x2', '\x2', 
		'\x2', '\x942', '\x943', '\x3', '\x2', '\x2', '\x2', '\x943', '\x944', 
		'\x5', '\x142', '\xA2', '\x2', '\x944', '\x945', '\a', '\x25D', '\x2', 
		'\x2', '\x945', '\x948', '\x5', '\x142', '\xA2', '\x2', '\x946', '\x947', 
		'\a', '\x16', '\x2', '\x2', '\x947', '\x949', '\x5', '\x142', '\xA2', 
		'\x2', '\x948', '\x946', '\x3', '\x2', '\x2', '\x2', '\x948', '\x949', 
		'\x3', '\x2', '\x2', '\x2', '\x949', '\x96D', '\x3', '\x2', '\x2', '\x2', 
		'\x94A', '\x94B', '\a', '\x191', '\x2', '\x2', '\x94B', '\x94C', '\x5', 
		'\xE4', 's', '\x2', '\x94C', '\x94F', '\a', '\x197', '\x2', '\x2', '\x94D', 
		'\x950', '\x5', '\x12', '\n', '\x2', '\x94E', '\x950', '\x5', '\xD8', 
		'm', '\x2', '\x94F', '\x94D', '\x3', '\x2', '\x2', '\x2', '\x94F', '\x94E', 
		'\x3', '\x2', '\x2', '\x2', '\x950', '\x96D', '\x3', '\x2', '\x2', '\x2', 
		'\x951', '\x952', '\a', '\x191', '\x2', '\x2', '\x952', '\x953', '\x5', 
		'\b', '\x5', '\x2', '\x953', '\x954', '\a', '\x197', '\x2', '\x2', '\x954', 
		'\x960', '\x5', '\b', '\x5', '\x2', '\x955', '\x956', '\a', '\x24B', '\x2', 
		'\x2', '\x956', '\x95B', '\x5', '\xE2', 'r', '\x2', '\x957', '\x958', 
		'\a', '\x245', '\x2', '\x2', '\x958', '\x95A', '\x5', '\xE2', 'r', '\x2', 
		'\x959', '\x957', '\x3', '\x2', '\x2', '\x2', '\x95A', '\x95D', '\x3', 
		'\x2', '\x2', '\x2', '\x95B', '\x959', '\x3', '\x2', '\x2', '\x2', '\x95B', 
		'\x95C', '\x3', '\x2', '\x2', '\x2', '\x95C', '\x95E', '\x3', '\x2', '\x2', 
		'\x2', '\x95D', '\x95B', '\x3', '\x2', '\x2', '\x2', '\x95E', '\x95F', 
		'\a', '\x24C', '\x2', '\x2', '\x95F', '\x961', '\x3', '\x2', '\x2', '\x2', 
		'\x960', '\x955', '\x3', '\x2', '\x2', '\x2', '\x960', '\x961', '\x3', 
		'\x2', '\x2', '\x2', '\x961', '\x96D', '\x3', '\x2', '\x2', '\x2', '\x962', 
		'\x963', '\a', '\x22C', '\x2', '\x2', '\x963', '\x966', '\x5', '\xE4', 
		's', '\x2', '\x964', '\x965', '\a', '\x23C', '\x2', '\x2', '\x965', '\x967', 
		'\a', '\x262', '\x2', '\x2', '\x966', '\x964', '\x3', '\x2', '\x2', '\x2', 
		'\x966', '\x967', '\x3', '\x2', '\x2', '\x2', '\x967', '\x968', '\x3', 
		'\x2', '\x2', '\x2', '\x968', '\x969', '\a', '\x197', '\x2', '\x2', '\x969', 
		'\x96A', '\a', '\x175', '\x2', '\x2', '\x96A', '\x96B', '\x5', '\x142', 
		'\xA2', '\x2', '\x96B', '\x96D', '\x3', '\x2', '\x2', '\x2', '\x96C', 
		'\x93B', '\x3', '\x2', '\x2', '\x2', '\x96C', '\x93D', '\x3', '\x2', '\x2', 
		'\x2', '\x96C', '\x94A', '\x3', '\x2', '\x2', '\x2', '\x96C', '\x951', 
		'\x3', '\x2', '\x2', '\x2', '\x96C', '\x962', '\x3', '\x2', '\x2', '\x2', 
		'\x96D', '\xE1', '\x3', '\x2', '\x2', '\x2', '\x96E', '\x96F', '\x5', 
		'\b', '\x5', '\x2', '\x96F', '\x970', '\a', '\x25A', '\x2', '\x2', '\x970', 
		'\x972', '\x3', '\x2', '\x2', '\x2', '\x971', '\x96E', '\x3', '\x2', '\x2', 
		'\x2', '\x971', '\x972', '\x3', '\x2', '\x2', '\x2', '\x972', '\x973', 
		'\x3', '\x2', '\x2', '\x2', '\x973', '\x974', '\x5', '\x142', '\xA2', 
		'\x2', '\x974', '\xE3', '\x3', '\x2', '\x2', '\x2', '\x975', '\x97A', 
		'\x5', '\b', '\x5', '\x2', '\x976', '\x977', '\a', '\x245', '\x2', '\x2', 
		'\x977', '\x979', '\x5', '\b', '\x5', '\x2', '\x978', '\x976', '\x3', 
		'\x2', '\x2', '\x2', '\x979', '\x97C', '\x3', '\x2', '\x2', '\x2', '\x97A', 
		'\x978', '\x3', '\x2', '\x2', '\x2', '\x97A', '\x97B', '\x3', '\x2', '\x2', 
		'\x2', '\x97B', '\xE5', '\x3', '\x2', '\x2', '\x2', '\x97C', '\x97A', 
		'\x3', '\x2', '\x2', '\x2', '\x97D', '\x983', '\t', ' ', '\x2', '\x2', 
		'\x97E', '\x980', '\a', '\x173', '\x2', '\x2', '\x97F', '\x981', '\a', 
		'\x98', '\x2', '\x2', '\x980', '\x97F', '\x3', '\x2', '\x2', '\x2', '\x980', 
		'\x981', '\x3', '\x2', '\x2', '\x2', '\x981', '\x982', '\x3', '\x2', '\x2', 
		'\x2', '\x982', '\x984', '\a', '\x1D', '\x2', '\x2', '\x983', '\x97E', 
		'\x3', '\x2', '\x2', '\x2', '\x983', '\x984', '\x3', '\x2', '\x2', '\x2', 
		'\x984', '\x987', '\x3', '\x2', '\x2', '\x2', '\x985', '\x987', '\x5', 
		'\xE8', 'u', '\x2', '\x986', '\x97D', '\x3', '\x2', '\x2', '\x2', '\x986', 
		'\x985', '\x3', '\x2', '\x2', '\x2', '\x987', '\xE7', '\x3', '\x2', '\x2', 
		'\x2', '\x988', '\x98A', '\a', '\x87', '\x2', '\x2', '\x989', '\x98B', 
		'\a', '\x1AF', '\x2', '\x2', '\x98A', '\x989', '\x3', '\x2', '\x2', '\x2', 
		'\x98A', '\x98B', '\x3', '\x2', '\x2', '\x2', '\x98B', '\x98C', '\x3', 
		'\x2', '\x2', '\x2', '\x98C', '\x991', '\x5', '\xEC', 'w', '\x2', '\x98D', 
		'\x98E', '\a', '\x245', '\x2', '\x2', '\x98E', '\x990', '\x5', '\xEC', 
		'w', '\x2', '\x98F', '\x98D', '\x3', '\x2', '\x2', '\x2', '\x990', '\x993', 
		'\x3', '\x2', '\x2', '\x2', '\x991', '\x98F', '\x3', '\x2', '\x2', '\x2', 
		'\x991', '\x992', '\x3', '\x2', '\x2', '\x2', '\x992', '\x998', '\x3', 
		'\x2', '\x2', '\x2', '\x993', '\x991', '\x3', '\x2', '\x2', '\x2', '\x994', 
		'\x995', '\a', '\x197', '\x2', '\x2', '\x995', '\x996', '\x5', '\xEA', 
		'v', '\x2', '\x996', '\x997', '\a', '\x91', '\x2', '\x2', '\x997', '\x999', 
		'\x3', '\x2', '\x2', '\x2', '\x998', '\x994', '\x3', '\x2', '\x2', '\x2', 
		'\x998', '\x999', '\x3', '\x2', '\x2', '\x2', '\x999', '\x99B', '\x3', 
		'\x2', '\x2', '\x2', '\x99A', '\x99C', '\a', '\x9B', '\x2', '\x2', '\x99B', 
		'\x99A', '\x3', '\x2', '\x2', '\x2', '\x99B', '\x99C', '\x3', '\x2', '\x2', 
		'\x2', '\x99C', '\xE9', '\x3', '\x2', '\x2', '\x2', '\x99D', '\x99E', 
		'\t', '!', '\x2', '\x2', '\x99E', '\x9AA', '\a', '\xE8', '\x2', '\x2', 
		'\x99F', '\x9A0', '\a', '\x144', '\x2', '\x2', '\x9A0', '\x9AA', '\a', 
		'S', '\x2', '\x2', '\x9A1', '\x9A2', '\a', '\xE8', '\x2', '\x2', '\x9A2', 
		'\x9A3', '\t', '\"', '\x2', '\x2', '\x9A3', '\x9AA', '\a', 'S', '\x2', 
		'\x2', '\x9A4', '\x9AA', '\a', '\xE8', '\x2', '\x2', '\x9A5', '\x9A7', 
		'\a', '\x5', '\x2', '\x2', '\x9A6', '\x9A5', '\x3', '\x2', '\x2', '\x2', 
		'\x9A6', '\x9A7', '\x3', '\x2', '\x2', '\x2', '\x9A7', '\x9A8', '\x3', 
		'\x2', '\x2', '\x2', '\x9A8', '\x9AA', '\a', 'S', '\x2', '\x2', '\x9A9', 
		'\x99D', '\x3', '\x2', '\x2', '\x2', '\x9A9', '\x99F', '\x3', '\x2', '\x2', 
		'\x2', '\x9A9', '\x9A1', '\x3', '\x2', '\x2', '\x2', '\x9A9', '\x9A4', 
		'\x3', '\x2', '\x2', '\x2', '\x9A9', '\x9A6', '\x3', '\x2', '\x2', '\x2', 
		'\x9AA', '\xEB', '\x3', '\x2', '\x2', '\x2', '\x9AB', '\x9AD', '\a', '\x1A4', 
		'\x2', '\x2', '\x9AC', '\x9AB', '\x3', '\x2', '\x2', '\x2', '\x9AC', '\x9AD', 
		'\x3', '\x2', '\x2', '\x2', '\x9AD', '\x9AE', '\x3', '\x2', '\x2', '\x2', 
		'\x9AE', '\x9B0', '\x5', '\x34', '\x1B', '\x2', '\x9AF', '\x9B1', '\a', 
		'\x24F', '\x2', '\x2', '\x9B0', '\x9AF', '\x3', '\x2', '\x2', '\x2', '\x9B0', 
		'\x9B1', '\x3', '\x2', '\x2', '\x2', '\x9B1', '\xED', '\x3', '\x2', '\x2', 
		'\x2', '\x9B2', '\x9B3', '\a', '\x234', '\x2', '\x2', '\x9B3', '\x9B8', 
		'\x5', '\xAC', 'W', '\x2', '\x9B4', '\x9B6', '\a', '\x98', '\x2', '\x2', 
		'\x9B5', '\x9B4', '\x3', '\x2', '\x2', '\x2', '\x9B5', '\x9B6', '\x3', 
		'\x2', '\x2', '\x2', '\x9B6', '\x9B7', '\x3', '\x2', '\x2', '\x2', '\x9B7', 
		'\x9B9', '\a', '\xDD', '\x2', '\x2', '\x9B8', '\x9B5', '\x3', '\x2', '\x2', 
		'\x2', '\x9B8', '\x9B9', '\x3', '\x2', '\x2', '\x2', '\x9B9', '\x9BA', 
		'\x3', '\x2', '\x2', '\x2', '\x9BA', '\x9BD', '\a', '\x191', '\x2', '\x2', 
		'\x9BB', '\x9BE', '\x5', '\x12', '\n', '\x2', '\x9BC', '\x9BE', '\x5', 
		'\xD8', 'm', '\x2', '\x9BD', '\x9BB', '\x3', '\x2', '\x2', '\x2', '\x9BD', 
		'\x9BC', '\x3', '\x2', '\x2', '\x2', '\x9BE', '\x9E4', '\x3', '\x2', '\x2', 
		'\x2', '\x9BF', '\x9C0', '\a', '\x234', '\x2', '\x2', '\x9C0', '\x9CC', 
		'\x5', '\xAC', 'W', '\x2', '\x9C1', '\x9C2', '\a', '\x24B', '\x2', '\x2', 
		'\x9C2', '\x9C7', '\x5', '\xE2', 'r', '\x2', '\x9C3', '\x9C4', '\a', '\x245', 
		'\x2', '\x2', '\x9C4', '\x9C6', '\x5', '\xE2', 'r', '\x2', '\x9C5', '\x9C3', 
		'\x3', '\x2', '\x2', '\x2', '\x9C6', '\x9C9', '\x3', '\x2', '\x2', '\x2', 
		'\x9C7', '\x9C5', '\x3', '\x2', '\x2', '\x2', '\x9C7', '\x9C8', '\x3', 
		'\x2', '\x2', '\x2', '\x9C8', '\x9CA', '\x3', '\x2', '\x2', '\x2', '\x9C9', 
		'\x9C7', '\x3', '\x2', '\x2', '\x2', '\x9CA', '\x9CB', '\a', '\x24C', 
		'\x2', '\x2', '\x9CB', '\x9CD', '\x3', '\x2', '\x2', '\x2', '\x9CC', '\x9C1', 
		'\x3', '\x2', '\x2', '\x2', '\x9CC', '\x9CD', '\x3', '\x2', '\x2', '\x2', 
		'\x9CD', '\x9E4', '\x3', '\x2', '\x2', '\x2', '\x9CE', '\x9D0', '\a', 
		'\x190', '\x2', '\x2', '\x9CF', '\x9D1', '\x5', '\xF0', 'y', '\x2', '\x9D0', 
		'\x9CF', '\x3', '\x2', '\x2', '\x2', '\x9D0', '\x9D1', '\x3', '\x2', '\x2', 
		'\x2', '\x9D1', '\x9D3', '\x3', '\x2', '\x2', '\x2', '\x9D2', '\x9D4', 
		'\t', '#', '\x2', '\x2', '\x9D3', '\x9D2', '\x3', '\x2', '\x2', '\x2', 
		'\x9D3', '\x9D4', '\x3', '\x2', '\x2', '\x2', '\x9D4', '\x9D5', '\x3', 
		'\x2', '\x2', '\x2', '\x9D5', '\x9D7', '\x5', '\xAC', 'W', '\x2', '\x9D6', 
		'\x9D8', '\x5', 'z', '>', '\x2', '\x9D7', '\x9D6', '\x3', '\x2', '\x2', 
		'\x2', '\x9D7', '\x9D8', '\x3', '\x2', '\x2', '\x2', '\x9D8', '\x9E4', 
		'\x3', '\x2', '\x2', '\x2', '\x9D9', '\x9DB', '\a', '\x93', '\x2', '\x2', 
		'\x9DA', '\x9DC', '\x5', '\xF0', 'y', '\x2', '\x9DB', '\x9DA', '\x3', 
		'\x2', '\x2', '\x2', '\x9DB', '\x9DC', '\x3', '\x2', '\x2', '\x2', '\x9DC', 
		'\x9DE', '\x3', '\x2', '\x2', '\x2', '\x9DD', '\x9DF', '\t', '#', '\x2', 
		'\x2', '\x9DE', '\x9DD', '\x3', '\x2', '\x2', '\x2', '\x9DE', '\x9DF', 
		'\x3', '\x2', '\x2', '\x2', '\x9DF', '\x9E0', '\x3', '\x2', '\x2', '\x2', 
		'\x9E0', '\x9E4', '\x5', '\xAC', 'W', '\x2', '\x9E1', '\x9E2', '\a', '!', 
		'\x2', '\x2', '\x9E2', '\x9E4', '\x5', '\xAC', 'W', '\x2', '\x9E3', '\x9B2', 
		'\x3', '\x2', '\x2', '\x2', '\x9E3', '\x9BF', '\x3', '\x2', '\x2', '\x2', 
		'\x9E3', '\x9CE', '\x3', '\x2', '\x2', '\x2', '\x9E3', '\x9D9', '\x3', 
		'\x2', '\x2', '\x2', '\x9E3', '\x9E1', '\x3', '\x2', '\x2', '\x2', '\x9E4', 
		'\xEF', '\x3', '\x2', '\x2', '\x2', '\x9E5', '\x9F7', '\a', '\x97', '\x2', 
		'\x2', '\x9E6', '\x9F7', '\a', '\xB7', '\x2', '\x2', '\x9E7', '\x9F7', 
		'\a', 'Z', '\x2', '\x2', '\x9E8', '\x9F7', '\a', '\x80', '\x2', '\x2', 
		'\x9E9', '\x9EB', '\t', '$', '\x2', '\x2', '\x9EA', '\x9E9', '\x3', '\x2', 
		'\x2', '\x2', '\x9EA', '\x9EB', '\x3', '\x2', '\x2', '\x2', '\x9EB', '\x9EC', 
		'\x3', '\x2', '\x2', '\x2', '\x9EC', '\x9F7', '\x5', '\xF2', 'z', '\x2', 
		'\x9ED', '\x9F7', '\a', '\x170', '\x2', '\x2', '\x9EE', '\x9F0', '\a', 
		']', '\x2', '\x2', '\x9EF', '\x9F1', '\t', '%', '\x2', '\x2', '\x9F0', 
		'\x9EF', '\x3', '\x2', '\x2', '\x2', '\x9F0', '\x9F1', '\x3', '\x2', '\x2', 
		'\x2', '\x9F1', '\x9F7', '\x3', '\x2', '\x2', '\x2', '\x9F2', '\x9F4', 
		'\a', '\x13', '\x2', '\x2', '\x9F3', '\x9F5', '\t', '%', '\x2', '\x2', 
		'\x9F4', '\x9F3', '\x3', '\x2', '\x2', '\x2', '\x9F4', '\x9F5', '\x3', 
		'\x2', '\x2', '\x2', '\x9F5', '\x9F7', '\x3', '\x2', '\x2', '\x2', '\x9F6', 
		'\x9E5', '\x3', '\x2', '\x2', '\x2', '\x9F6', '\x9E6', '\x3', '\x2', '\x2', 
		'\x2', '\x9F6', '\x9E7', '\x3', '\x2', '\x2', '\x2', '\x9F6', '\x9E8', 
		'\x3', '\x2', '\x2', '\x2', '\x9F6', '\x9EA', '\x3', '\x2', '\x2', '\x2', 
		'\x9F6', '\x9ED', '\x3', '\x2', '\x2', '\x2', '\x9F6', '\x9EE', '\x3', 
		'\x2', '\x2', '\x2', '\x9F6', '\x9F2', '\x3', '\x2', '\x2', '\x2', '\x9F7', 
		'\xF1', '\x3', '\x2', '\x2', '\x2', '\x9F8', '\x9FA', '\x5', '\xF4', '{', 
		'\x2', '\x9F9', '\x9F8', '\x3', '\x2', '\x2', '\x2', '\x9F9', '\x9FA', 
		'\x3', '\x2', '\x2', '\x2', '\x9FA', '\x9FB', '\x3', '\x2', '\x2', '\x2', 
		'\x9FB', '\x9FC', '\a', '\x262', '\x2', '\x2', '\x9FC', '\xF3', '\x3', 
		'\x2', '\x2', '\x2', '\x9FD', '\x9FE', '\t', '&', '\x2', '\x2', '\x9FE', 
		'\xF5', '\x3', '\x2', '\x2', '\x2', '\x9FF', '\xA01', '\a', '\x237', '\x2', 
		'\x2', '\xA00', '\xA02', '\x5', '\xFC', '\x7F', '\x2', '\xA01', '\xA00', 
		'\x3', '\x2', '\x2', '\x2', '\xA01', '\xA02', '\x3', '\x2', '\x2', '\x2', 
		'\xA02', '\xA0B', '\x3', '\x2', '\x2', '\x2', '\xA03', '\xA08', '\x5', 
		'h', '\x35', '\x2', '\xA04', '\xA05', '\a', '\x245', '\x2', '\x2', '\xA05', 
		'\xA07', '\x5', '\x142', '\xA2', '\x2', '\xA06', '\xA04', '\x3', '\x2', 
		'\x2', '\x2', '\xA07', '\xA0A', '\x3', '\x2', '\x2', '\x2', '\xA08', '\xA06', 
		'\x3', '\x2', '\x2', '\x2', '\xA08', '\xA09', '\x3', '\x2', '\x2', '\x2', 
		'\xA09', '\xA0C', '\x3', '\x2', '\x2', '\x2', '\xA0A', '\xA08', '\x3', 
		'\x2', '\x2', '\x2', '\xA0B', '\xA03', '\x3', '\x2', '\x2', '\x2', '\xA0B', 
		'\xA0C', '\x3', '\x2', '\x2', '\x2', '\xA0C', '\xA0E', '\x3', '\x2', '\x2', 
		'\x2', '\xA0D', '\xA0F', '\x5', '\xF8', '}', '\x2', '\xA0E', '\xA0D', 
		'\x3', '\x2', '\x2', '\x2', '\xA0E', '\xA0F', '\x3', '\x2', '\x2', '\x2', 
		'\xA0F', '\xA28', '\x3', '\x2', '\x2', '\x2', '\xA10', '\xA12', '\a', 
		'\x237', '\x2', '\x2', '\xA11', '\xA13', '\x5', '\xFC', '\x7F', '\x2', 
		'\xA12', '\xA11', '\x3', '\x2', '\x2', '\x2', '\xA12', '\xA13', '\x3', 
		'\x2', '\x2', '\x2', '\xA13', '\xA14', '\x3', '\x2', '\x2', '\x2', '\xA14', 
		'\xA16', '\x5', '\b', '\x5', '\x2', '\xA15', '\xA17', '\x5', '\xF8', '}', 
		'\x2', '\xA16', '\xA15', '\x3', '\x2', '\x2', '\x2', '\xA16', '\xA17', 
		'\x3', '\x2', '\x2', '\x2', '\xA17', '\xA28', '\x3', '\x2', '\x2', '\x2', 
		'\xA18', '\xA1A', '\a', '\x237', '\x2', '\x2', '\xA19', '\xA1B', '\x5', 
		'\xFC', '\x7F', '\x2', '\xA1A', '\xA19', '\x3', '\x2', '\x2', '\x2', '\xA1A', 
		'\xA1B', '\x3', '\x2', '\x2', '\x2', '\xA1B', '\xA1C', '\x3', '\x2', '\x2', 
		'\x2', '\xA1C', '\xA1D', '\a', '\x23D', '\x2', '\x2', '\xA1D', '\xA1F', 
		'\x5', 'h', '\x35', '\x2', '\xA1E', '\xA20', '\x5', '\xF8', '}', '\x2', 
		'\xA1F', '\xA1E', '\x3', '\x2', '\x2', '\x2', '\xA1F', '\xA20', '\x3', 
		'\x2', '\x2', '\x2', '\xA20', '\xA28', '\x3', '\x2', '\x2', '\x2', '\xA21', 
		'\xA22', '\a', '\x221', '\x2', '\x2', '\xA22', '\xA25', '\x5', '\x142', 
		'\xA2', '\x2', '\xA23', '\xA24', '\a', '\x245', '\x2', '\x2', '\xA24', 
		'\xA26', '\x5', '\x142', '\xA2', '\x2', '\xA25', '\xA23', '\x3', '\x2', 
		'\x2', '\x2', '\xA25', '\xA26', '\x3', '\x2', '\x2', '\x2', '\xA26', '\xA28', 
		'\x3', '\x2', '\x2', '\x2', '\xA27', '\x9FF', '\x3', '\x2', '\x2', '\x2', 
		'\xA27', '\xA10', '\x3', '\x2', '\x2', '\x2', '\xA27', '\xA18', '\x3', 
		'\x2', '\x2', '\x2', '\xA27', '\xA21', '\x3', '\x2', '\x2', '\x2', '\xA28', 
		'\xF7', '\x3', '\x2', '\x2', '\x2', '\xA29', '\xA2A', '\a', '\x1B7', '\x2', 
		'\x2', '\xA2A', '\xA2B', '\x5', '\xFA', '~', '\x2', '\xA2B', '\xA2C', 
		'\a', '\x242', '\x2', '\x2', '\xA2C', '\xA34', '\x5', '\x142', '\xA2', 
		'\x2', '\xA2D', '\xA2E', '\a', '\x245', '\x2', '\x2', '\xA2E', '\xA2F', 
		'\x5', '\xFA', '~', '\x2', '\xA2F', '\xA30', '\a', '\x242', '\x2', '\x2', 
		'\xA30', '\xA31', '\x5', '\x142', '\xA2', '\x2', '\xA31', '\xA33', '\x3', 
		'\x2', '\x2', '\x2', '\xA32', '\xA2D', '\x3', '\x2', '\x2', '\x2', '\xA33', 
		'\xA36', '\x3', '\x2', '\x2', '\x2', '\xA34', '\xA32', '\x3', '\x2', '\x2', 
		'\x2', '\xA34', '\xA35', '\x3', '\x2', '\x2', '\x2', '\xA35', '\xF9', 
		'\x3', '\x2', '\x2', '\x2', '\xA36', '\xA34', '\x3', '\x2', '\x2', '\x2', 
		'\xA37', '\xA38', '\t', '\'', '\x2', '\x2', '\xA38', '\xFB', '\x3', '\x2', 
		'\x2', '\x2', '\xA39', '\xA3A', '\t', '(', '\x2', '\x2', '\xA3A', '\xFD', 
		'\x3', '\x2', '\x2', '\x2', '\xA3B', '\xA42', '\x5', '\x12', '\n', '\x2', 
		'\xA3C', '\xA42', '\x5', '\x8E', 'H', '\x2', '\xA3D', '\xA42', '\x5', 
		'\x84', '\x43', '\x2', '\xA3E', '\xA42', '\x5', '\x82', '\x42', '\x2', 
		'\xA3F', '\xA42', '\x5', '\x100', '\x81', '\x2', '\xA40', '\xA42', '\x5', 
		'\x102', '\x82', '\x2', '\xA41', '\xA3B', '\x3', '\x2', '\x2', '\x2', 
		'\xA41', '\xA3C', '\x3', '\x2', '\x2', '\x2', '\xA41', '\xA3D', '\x3', 
		'\x2', '\x2', '\x2', '\xA41', '\xA3E', '\x3', '\x2', '\x2', '\x2', '\xA41', 
		'\xA3F', '\x3', '\x2', '\x2', '\x2', '\xA41', '\xA40', '\x3', '\x2', '\x2', 
		'\x2', '\xA42', '\xFF', '\x3', '\x2', '\x2', '\x2', '\xA43', '\xA44', 
		'\a', '\x9A', '\x2', '\x2', '\xA44', '\xA47', '\x5', '\b', '\x5', '\x2', 
		'\xA45', '\xA46', '\a', '\x245', '\x2', '\x2', '\xA46', '\xA48', '\x5', 
		'h', '\x35', '\x2', '\xA47', '\xA45', '\x3', '\x2', '\x2', '\x2', '\xA47', 
		'\xA48', '\x3', '\x2', '\x2', '\x2', '\xA48', '\x101', '\x3', '\x2', '\x2', 
		'\x2', '\xA49', '\xA4B', '\a', '\x107', '\x2', '\x2', '\xA4A', '\xA4C', 
		'\a', '\x1AF', '\x2', '\x2', '\xA4B', '\xA4A', '\x3', '\x2', '\x2', '\x2', 
		'\xA4B', '\xA4C', '\x3', '\x2', '\x2', '\x2', '\xA4C', '\xA4D', '\x3', 
		'\x2', '\x2', '\x2', '\xA4D', '\xA52', '\x5', '\xEC', 'w', '\x2', '\xA4E', 
		'\xA4F', '\a', '\x245', '\x2', '\x2', '\xA4F', '\xA51', '\x5', '\xEC', 
		'w', '\x2', '\xA50', '\xA4E', '\x3', '\x2', '\x2', '\x2', '\xA51', '\xA54', 
		'\x3', '\x2', '\x2', '\x2', '\xA52', '\xA50', '\x3', '\x2', '\x2', '\x2', 
		'\xA52', '\xA53', '\x3', '\x2', '\x2', '\x2', '\xA53', '\xA57', '\x3', 
		'\x2', '\x2', '\x2', '\xA54', '\xA52', '\x3', '\x2', '\x2', '\x2', '\xA55', 
		'\xA56', '\t', ')', '\x2', '\x2', '\xA56', '\xA58', '\a', 'h', '\x2', 
		'\x2', '\xA57', '\xA55', '\x3', '\x2', '\x2', '\x2', '\xA57', '\xA58', 
		'\x3', '\x2', '\x2', '\x2', '\xA58', '\xA5A', '\x3', '\x2', '\x2', '\x2', 
		'\xA59', '\xA5B', '\x5', '\x104', '\x83', '\x2', '\xA5A', '\xA59', '\x3', 
		'\x2', '\x2', '\x2', '\xA5A', '\xA5B', '\x3', '\x2', '\x2', '\x2', '\xA5B', 
		'\x103', '\x3', '\x2', '\x2', '\x2', '\xA5C', '\xA5D', '\t', '*', '\x2', 
		'\x2', '\xA5D', '\x105', '\x3', '\x2', '\x2', '\x2', '\xA5E', '\xADD', 
		'\x5', '\x11A', '\x8E', '\x2', '\xA5F', '\xA60', '\a', '\x83', '\x2', 
		'\x2', '\xA60', '\xADD', '\x5', '\b', '\x5', '\x2', '\xA61', '\xA64', 
		'\a', '\x10F', '\x2', '\x2', '\xA62', '\xA65', '\x5', '\b', '\x5', '\x2', 
		'\xA63', '\xA65', '\a', '\x24F', '\x2', '\x2', '\xA64', '\xA62', '\x3', 
		'\x2', '\x2', '\x2', '\xA64', '\xA63', '\x3', '\x2', '\x2', '\x2', '\xA65', 
		'\xADD', '\x3', '\x2', '\x2', '\x2', '\xA66', '\xA73', '\a', '\x172', 
		'\x2', '\x2', '\xA67', '\xA68', '\a', '\x24B', '\x2', '\x2', '\xA68', 
		'\xA6D', '\x5', '\x11C', '\x8F', '\x2', '\xA69', '\xA6A', '\a', '\x245', 
		'\x2', '\x2', '\xA6A', '\xA6C', '\x5', '\x11C', '\x8F', '\x2', '\xA6B', 
		'\xA69', '\x3', '\x2', '\x2', '\x2', '\xA6C', '\xA6F', '\x3', '\x2', '\x2', 
		'\x2', '\xA6D', '\xA6B', '\x3', '\x2', '\x2', '\x2', '\xA6D', '\xA6E', 
		'\x3', '\x2', '\x2', '\x2', '\xA6E', '\xA70', '\x3', '\x2', '\x2', '\x2', 
		'\xA6F', '\xA6D', '\x3', '\x2', '\x2', '\x2', '\xA70', '\xA71', '\a', 
		'\x24C', '\x2', '\x2', '\xA71', '\xA74', '\x3', '\x2', '\x2', '\x2', '\xA72', 
		'\xA74', '\a', '\x16F', '\x2', '\x2', '\xA73', '\xA67', '\x3', '\x2', 
		'\x2', '\x2', '\xA73', '\xA72', '\x3', '\x2', '\x2', '\x2', '\xA73', '\xA74', 
		'\x3', '\x2', '\x2', '\x2', '\xA74', '\xA76', '\x3', '\x2', '\x2', '\x2', 
		'\xA75', '\xA77', '\x5', '\x116', '\x8C', '\x2', '\xA76', '\xA75', '\x3', 
		'\x2', '\x2', '\x2', '\xA76', '\xA77', '\x3', '\x2', '\x2', '\x2', '\xA77', 
		'\xADD', '\x3', '\x2', '\x2', '\x2', '\xA78', '\xA7A', '\a', '\"', '\x2', 
		'\x2', '\xA79', '\xA7B', '\a', '\x16F', '\x2', '\x2', '\xA7A', '\xA79', 
		'\x3', '\x2', '\x2', '\x2', '\xA7A', '\xA7B', '\x3', '\x2', '\x2', '\x2', 
		'\xA7B', '\xA85', '\x3', '\x2', '\x2', '\x2', '\xA7C', '\xA7D', '\x5', 
		'\b', '\x5', '\x2', '\xA7D', '\xA7E', '\a', '\x1A3', '\x2', '\x2', '\xA7E', 
		'\xA7F', '\x5', '\x34', '\x1B', '\x2', '\xA7F', '\xA86', '\x3', '\x2', 
		'\x2', '\x2', '\xA80', '\xA83', '\x5', '\x34', '\x1B', '\x2', '\xA81', 
		'\xA82', '\a', '\x1B7', '\x2', '\x2', '\xA82', '\xA84', '\x5', '\b', '\x5', 
		'\x2', '\xA83', '\xA81', '\x3', '\x2', '\x2', '\x2', '\xA83', '\xA84', 
		'\x3', '\x2', '\x2', '\x2', '\xA84', '\xA86', '\x3', '\x2', '\x2', '\x2', 
		'\xA85', '\xA7C', '\x3', '\x2', '\x2', '\x2', '\xA85', '\xA80', '\x3', 
		'\x2', '\x2', '\x2', '\xA85', '\xA86', '\x3', '\x2', '\x2', '\x2', '\xA86', 
		'\xADD', '\x3', '\x2', '\x2', '\x2', '\xA87', '\xADD', '\a', '\x1F', '\x2', 
		'\x2', '\xA88', '\xA89', '\a', '\x84', '\x2', '\x2', '\xA89', '\xADD', 
		'\a', '\x267', '\x2', '\x2', '\xA8A', '\xA8C', '\a', '\x39', '\x2', '\x2', 
		'\xA8B', '\xA8D', '\a', '\xB4', '\x2', '\x2', '\xA8C', '\xA8B', '\x3', 
		'\x2', '\x2', '\x2', '\xA8C', '\xA8D', '\x3', '\x2', '\x2', '\x2', '\xA8D', 
		'\xA90', '\x3', '\x2', '\x2', '\x2', '\xA8E', '\xA91', '\x5', '\b', '\x5', 
		'\x2', '\xA8F', '\xA91', '\a', '\x170', '\x2', '\x2', '\xA90', '\xA8E', 
		'\x3', '\x2', '\x2', '\x2', '\xA90', '\xA8F', '\x3', '\x2', '\x2', '\x2', 
		'\xA91', '\xADD', '\x3', '\x2', '\x2', '\x2', '\xA92', '\xA96', '\a', 
		'\xC7', '\x2', '\x2', '\xA93', '\xA94', '\a', '\x24B', '\x2', '\x2', '\xA94', 
		'\xA95', '\a', '\x16F', '\x2', '\x2', '\xA95', '\xA97', '\a', '\x24C', 
		'\x2', '\x2', '\xA96', '\xA93', '\x3', '\x2', '\x2', '\x2', '\xA96', '\xA97', 
		'\x3', '\x2', '\x2', '\x2', '\xA97', '\xA98', '\x3', '\x2', '\x2', '\x2', 
		'\xA98', '\xA9A', '\t', '+', '\x2', '\x2', '\xA99', '\xA9B', '\a', '\x15C', 
		'\x2', '\x2', '\xA9A', '\xA99', '\x3', '\x2', '\x2', '\x2', '\xA9A', '\xA9B', 
		'\x3', '\x2', '\x2', '\x2', '\xA9B', '\xA9C', '\x3', '\x2', '\x2', '\x2', 
		'\xA9C', '\xADD', '\x5', '\x34', '\x1B', '\x2', '\xA9D', '\xAA9', '\a', 
		'\xCE', '\x2', '\x2', '\xA9E', '\xA9F', '\x5', '\b', '\x5', '\x2', '\xA9F', 
		'\xAA0', '\a', '\x253', '\x2', '\x2', '\xAA0', '\xAA2', '\x3', '\x2', 
		'\x2', '\x2', '\xAA1', '\xA9E', '\x3', '\x2', '\x2', '\x2', '\xAA1', '\xAA2', 
		'\x3', '\x2', '\x2', '\x2', '\xAA2', '\xAA3', '\x3', '\x2', '\x2', '\x2', 
		'\xAA3', '\xAAA', '\x5', '\b', '\x5', '\x2', '\xAA4', '\xAA5', '\a', '\x148', 
		'\x2', '\x2', '\xAA5', '\xAAA', '\a', '\x126', '\x2', '\x2', '\xAA6', 
		'\xAA7', '\a', '\xE5', '\x2', '\x2', '\xAA7', '\xAAA', '\a', '\x159', 
		'\x2', '\x2', '\xAA8', '\xAAA', '\a', '\x170', '\x2', '\x2', '\xAA9', 
		'\xAA1', '\x3', '\x2', '\x2', '\x2', '\xAA9', '\xAA4', '\x3', '\x2', '\x2', 
		'\x2', '\xAA9', '\xAA6', '\x3', '\x2', '\x2', '\x2', '\xAA9', '\xAA8', 
		'\x3', '\x2', '\x2', '\x2', '\xAAA', '\xADD', '\x3', '\x2', '\x2', '\x2', 
		'\xAAB', '\xADD', '\x5', '\xB4', '[', '\x2', '\xAAC', '\xAAD', '\a', '\xC6', 
		'\x2', '\x2', '\xAAD', '\xAAE', '\a', '\x8C', '\x2', '\x2', '\xAAE', '\xAB0', 
		'\a', '\x11A', '\x2', '\x2', '\xAAF', '\xAB1', '\a', '\x15C', '\x2', '\x2', 
		'\xAB0', '\xAAF', '\x3', '\x2', '\x2', '\x2', '\xAB0', '\xAB1', '\x3', 
		'\x2', '\x2', '\x2', '\xAB1', '\xAB2', '\x3', '\x2', '\x2', '\x2', '\xAB2', 
		'\xAB8', '\x5', '\x34', '\x1B', '\x2', '\xAB3', '\xAB5', '\a', '\x1BC', 
		'\x2', '\x2', '\xAB4', '\xAB6', '\a', '\x98', '\x2', '\x2', '\xAB5', '\xAB4', 
		'\x3', '\x2', '\x2', '\x2', '\xAB5', '\xAB6', '\x3', '\x2', '\x2', '\x2', 
		'\xAB6', '\xAB7', '\x3', '\x2', '\x2', '\x2', '\xAB7', '\xAB9', '\a', 
		'\x36', '\x2', '\x2', '\xAB8', '\xAB3', '\x3', '\x2', '\x2', '\x2', '\xAB8', 
		'\xAB9', '\x3', '\x2', '\x2', '\x2', '\xAB9', '\xADD', '\x3', '\x2', '\x2', 
		'\x2', '\xABA', '\xABB', '\a', '\xB4', '\x2', '\x2', '\xABB', '\xAC7', 
		'\x5', '\b', '\x5', '\x2', '\xABC', '\xABD', '\a', '\x24B', '\x2', '\x2', 
		'\xABD', '\xAC2', '\x5', 'H', '%', '\x2', '\xABE', '\xABF', '\a', '\x245', 
		'\x2', '\x2', '\xABF', '\xAC1', '\x5', 'H', '%', '\x2', '\xAC0', '\xABE', 
		'\x3', '\x2', '\x2', '\x2', '\xAC1', '\xAC4', '\x3', '\x2', '\x2', '\x2', 
		'\xAC2', '\xAC0', '\x3', '\x2', '\x2', '\x2', '\xAC2', '\xAC3', '\x3', 
		'\x2', '\x2', '\x2', '\xAC3', '\xAC5', '\x3', '\x2', '\x2', '\x2', '\xAC4', 
		'\xAC2', '\x3', '\x2', '\x2', '\x2', '\xAC5', '\xAC6', '\a', '\x24C', 
		'\x2', '\x2', '\xAC6', '\xAC8', '\x3', '\x2', '\x2', '\x2', '\xAC7', '\xABC', 
		'\x3', '\x2', '\x2', '\x2', '\xAC7', '\xAC8', '\x3', '\x2', '\x2', '\x2', 
		'\xAC8', '\xAC9', '\x3', '\x2', '\x2', '\x2', '\xAC9', '\xACA', '\a', 
		'\x176', '\x2', '\x2', '\xACA', '\xACB', '\x5', '\xFE', '\x80', '\x2', 
		'\xACB', '\xADD', '\x3', '\x2', '\x2', '\x2', '\xACC', '\xACD', '\a', 
		'\xC1', '\x2', '\x2', '\xACD', '\xACE', '\a', '\xA9', '\x2', '\x2', '\xACE', 
		'\xACF', '\a', '\x16', '\x2', '\x2', '\xACF', '\xAD4', '\x5', '\x10E', 
		'\x88', '\x2', '\xAD0', '\xAD1', '\a', '\x245', '\x2', '\x2', '\xAD1', 
		'\xAD3', '\x5', '\x10E', '\x88', '\x2', '\xAD2', '\xAD0', '\x3', '\x2', 
		'\x2', '\x2', '\xAD3', '\xAD6', '\x3', '\x2', '\x2', '\x2', '\xAD4', '\xAD2', 
		'\x3', '\x2', '\x2', '\x2', '\xAD4', '\xAD5', '\x3', '\x2', '\x2', '\x2', 
		'\xAD5', '\xAD7', '\x3', '\x2', '\x2', '\x2', '\xAD6', '\xAD4', '\x3', 
		'\x2', '\x2', '\x2', '\xAD7', '\xAD8', '\a', '\x1B1', '\x2', '\x2', '\xAD8', 
		'\xAD9', '\x5', '\x10E', '\x88', '\x2', '\xAD9', '\xADD', '\x3', '\x2', 
		'\x2', '\x2', '\xADA', '\xADD', '\x5', '\x108', '\x85', '\x2', '\xADB', 
		'\xADD', '\x5', '\xD6', 'l', '\x2', '\xADC', '\xA5E', '\x3', '\x2', '\x2', 
		'\x2', '\xADC', '\xA5F', '\x3', '\x2', '\x2', '\x2', '\xADC', '\xA61', 
		'\x3', '\x2', '\x2', '\x2', '\xADC', '\xA66', '\x3', '\x2', '\x2', '\x2', 
		'\xADC', '\xA78', '\x3', '\x2', '\x2', '\x2', '\xADC', '\xA87', '\x3', 
		'\x2', '\x2', '\x2', '\xADC', '\xA88', '\x3', '\x2', '\x2', '\x2', '\xADC', 
		'\xA8A', '\x3', '\x2', '\x2', '\x2', '\xADC', '\xA92', '\x3', '\x2', '\x2', 
		'\x2', '\xADC', '\xA9D', '\x3', '\x2', '\x2', '\x2', '\xADC', '\xAAB', 
		'\x3', '\x2', '\x2', '\x2', '\xADC', '\xAAC', '\x3', '\x2', '\x2', '\x2', 
		'\xADC', '\xABA', '\x3', '\x2', '\x2', '\x2', '\xADC', '\xACC', '\x3', 
		'\x2', '\x2', '\x2', '\xADC', '\xADA', '\x3', '\x2', '\x2', '\x2', '\xADC', 
		'\xADB', '\x3', '\x2', '\x2', '\x2', '\xADD', '\x107', '\x3', '\x2', '\x2', 
		'\x2', '\xADE', '\xAE1', '\x5', '\x10C', '\x87', '\x2', '\xADF', '\xAE1', 
		'\x5', '\x10A', '\x86', '\x2', '\xAE0', '\xADE', '\x3', '\x2', '\x2', 
		'\x2', '\xAE0', '\xADF', '\x3', '\x2', '\x2', '\x2', '\xAE1', '\x109', 
		'\x3', '\x2', '\x2', '\x2', '\xAE2', '\xAE3', '\a', '/', '\x2', '\x2', 
		'\xAE3', '\xAE4', '\x5', '\x118', '\x8D', '\x2', '\xAE4', '\xAEA', '\a', 
		'\x193', '\x2', '\x2', '\xAE5', '\xAE7', '\a', '\xBC', '\x2', '\x2', '\xAE6', 
		'\xAE5', '\x3', '\x2', '\x2', '\x2', '\xAE6', '\xAE7', '\x3', '\x2', '\x2', 
		'\x2', '\xAE7', '\xAE8', '\x3', '\x2', '\x2', '\x2', '\xAE8', '\xAEB', 
		'\a', '\x267', '\x2', '\x2', '\xAE9', '\xAEB', '\a', '\xF3', '\x2', '\x2', 
		'\xAEA', '\xAE6', '\x3', '\x2', '\x2', '\x2', '\xAEA', '\xAE9', '\x3', 
		'\x2', '\x2', '\x2', '\xAEB', '\xAF6', '\x3', '\x2', '\x2', '\x2', '\xAEC', 
		'\xAEE', '\a', '\x1BC', '\x2', '\x2', '\xAED', '\xAEC', '\x3', '\x2', 
		'\x2', '\x2', '\xAED', '\xAEE', '\x3', '\x2', '\x2', '\x2', '\xAEE', '\xAF4', 
		'\x3', '\x2', '\x2', '\x2', '\xAEF', '\xAF0', '\a', '\x24B', '\x2', '\x2', 
		'\xAF0', '\xAF1', '\x5', '\x110', '\x89', '\x2', '\xAF1', '\xAF2', '\a', 
		'\x24C', '\x2', '\x2', '\xAF2', '\xAF5', '\x3', '\x2', '\x2', '\x2', '\xAF3', 
		'\xAF5', '\x5', '\x110', '\x89', '\x2', '\xAF4', '\xAEF', '\x3', '\x2', 
		'\x2', '\x2', '\xAF4', '\xAF3', '\x3', '\x2', '\x2', '\x2', '\xAF5', '\xAF7', 
		'\x3', '\x2', '\x2', '\x2', '\xAF6', '\xAED', '\x3', '\x2', '\x2', '\x2', 
		'\xAF6', '\xAF7', '\x3', '\x2', '\x2', '\x2', '\xAF7', '\xAFA', '\x3', 
		'\x2', '\x2', '\x2', '\xAF8', '\xAF9', '\a', '\x1BA', '\x2', '\x2', '\xAF9', 
		'\xAFB', '\x5', '\x142', '\xA2', '\x2', '\xAFA', '\xAF8', '\x3', '\x2', 
		'\x2', '\x2', '\xAFA', '\xAFB', '\x3', '\x2', '\x2', '\x2', '\xAFB', '\x10B', 
		'\x3', '\x2', '\x2', '\x2', '\xAFC', '\xB07', '\a', '/', '\x2', '\x2', 
		'\xAFD', '\xB08', '\x5', '\x118', '\x8D', '\x2', '\xAFE', '\xB03', '\a', 
		'\x24B', '\x2', '\x2', '\xAFF', '\xB04', '\x5', '\x12', '\n', '\x2', '\xB00', 
		'\xB04', '\x5', '\x8E', 'H', '\x2', '\xB01', '\xB04', '\x5', '\x84', '\x43', 
		'\x2', '\xB02', '\xB04', '\x5', '\x82', '\x42', '\x2', '\xB03', '\xAFF', 
		'\x3', '\x2', '\x2', '\x2', '\xB03', '\xB00', '\x3', '\x2', '\x2', '\x2', 
		'\xB03', '\xB01', '\x3', '\x2', '\x2', '\x2', '\xB03', '\xB02', '\x3', 
		'\x2', '\x2', '\x2', '\xB04', '\xB05', '\x3', '\x2', '\x2', '\x2', '\xB05', 
		'\xB06', '\a', '\x24C', '\x2', '\x2', '\xB06', '\xB08', '\x3', '\x2', 
		'\x2', '\x2', '\xB07', '\xAFD', '\x3', '\x2', '\x2', '\x2', '\xB07', '\xAFE', 
		'\x3', '\x2', '\x2', '\x2', '\xB08', '\xB09', '\x3', '\x2', '\x2', '\x2', 
		'\xB09', '\xB0F', '\a', '\x1B1', '\x2', '\x2', '\xB0A', '\xB0C', '\a', 
		'\xBC', '\x2', '\x2', '\xB0B', '\xB0A', '\x3', '\x2', '\x2', '\x2', '\xB0B', 
		'\xB0C', '\x3', '\x2', '\x2', '\x2', '\xB0C', '\xB0D', '\x3', '\x2', '\x2', 
		'\x2', '\xB0D', '\xB10', '\a', '\x267', '\x2', '\x2', '\xB0E', '\xB10', 
		'\a', '\xF4', '\x2', '\x2', '\xB0F', '\xB0B', '\x3', '\x2', '\x2', '\x2', 
		'\xB0F', '\xB0E', '\x3', '\x2', '\x2', '\x2', '\xB10', '\xB1B', '\x3', 
		'\x2', '\x2', '\x2', '\xB11', '\xB13', '\a', '\x1BC', '\x2', '\x2', '\xB12', 
		'\xB11', '\x3', '\x2', '\x2', '\x2', '\xB12', '\xB13', '\x3', '\x2', '\x2', 
		'\x2', '\xB13', '\xB19', '\x3', '\x2', '\x2', '\x2', '\xB14', '\xB15', 
		'\a', '\x24B', '\x2', '\x2', '\xB15', '\xB16', '\x5', '\x110', '\x89', 
		'\x2', '\xB16', '\xB17', '\a', '\x24C', '\x2', '\x2', '\xB17', '\xB1A', 
		'\x3', '\x2', '\x2', '\x2', '\xB18', '\xB1A', '\x5', '\x110', '\x89', 
		'\x2', '\xB19', '\xB14', '\x3', '\x2', '\x2', '\x2', '\xB19', '\xB18', 
		'\x3', '\x2', '\x2', '\x2', '\xB1A', '\xB1C', '\x3', '\x2', '\x2', '\x2', 
		'\xB1B', '\xB12', '\x3', '\x2', '\x2', '\x2', '\xB1B', '\xB1C', '\x3', 
		'\x2', '\x2', '\x2', '\xB1C', '\x10D', '\x3', '\x2', '\x2', '\x2', '\xB1D', 
		'\xB21', '\x5', '\b', '\x5', '\x2', '\xB1E', '\xB21', '\a', '\x186', '\x2', 
		'\x2', '\xB1F', '\xB21', '\a', '\x1AC', '\x2', '\x2', '\xB20', '\xB1D', 
		'\x3', '\x2', '\x2', '\x2', '\xB20', '\xB1E', '\x3', '\x2', '\x2', '\x2', 
		'\xB20', '\xB1F', '\x3', '\x2', '\x2', '\x2', '\xB21', '\x10F', '\x3', 
		'\x2', '\x2', '\x2', '\xB22', '\xB29', '\x5', '\x112', '\x8A', '\x2', 
		'\xB23', '\xB25', '\a', '\x245', '\x2', '\x2', '\xB24', '\xB23', '\x3', 
		'\x2', '\x2', '\x2', '\xB24', '\xB25', '\x3', '\x2', '\x2', '\x2', '\xB25', 
		'\xB26', '\x3', '\x2', '\x2', '\x2', '\xB26', '\xB28', '\x5', '\x112', 
		'\x8A', '\x2', '\xB27', '\xB24', '\x3', '\x2', '\x2', '\x2', '\xB28', 
		'\xB2B', '\x3', '\x2', '\x2', '\x2', '\xB29', '\xB27', '\x3', '\x2', '\x2', 
		'\x2', '\xB29', '\xB2A', '\x3', '\x2', '\x2', '\x2', '\xB2A', '\x111', 
		'\x3', '\x2', '\x2', '\x2', '\xB2B', '\xB29', '\x3', '\x2', '\x2', '\x2', 
		'\xB2C', '\xB2E', '\a', '\x1D5', '\x2', '\x2', '\xB2D', '\xB2C', '\x3', 
		'\x2', '\x2', '\x2', '\xB2D', '\xB2E', '\x3', '\x2', '\x2', '\x2', '\xB2E', 
		'\xB2F', '\x3', '\x2', '\x2', '\x2', '\xB2F', '\xB69', '\t', ',', '\x2', 
		'\x2', '\xB30', '\xB32', '\a', '\xA0', '\x2', '\x2', '\xB31', '\xB33', 
		'\x5', '\x114', '\x8B', '\x2', '\xB32', '\xB31', '\x3', '\x2', '\x2', 
		'\x2', '\xB32', '\xB33', '\x3', '\x2', '\x2', '\x2', '\xB33', '\xB69', 
		'\x3', '\x2', '\x2', '\x2', '\xB34', '\xB36', '\a', '\x15F', '\x2', '\x2', 
		'\xB35', '\xB37', '\x5', '\x114', '\x8B', '\x2', '\xB36', '\xB35', '\x3', 
		'\x2', '\x2', '\x2', '\xB36', '\xB37', '\x3', '\x2', '\x2', '\x2', '\xB37', 
		'\xB69', '\x3', '\x2', '\x2', '\x2', '\xB38', '\xB3A', '\a', '?', '\x2', 
		'\x2', '\xB39', '\xB3B', '\a', '\x176', '\x2', '\x2', '\xB3A', '\xB39', 
		'\x3', '\x2', '\x2', '\x2', '\xB3A', '\xB3B', '\x3', '\x2', '\x2', '\x2', 
		'\xB3B', '\xB3C', '\x3', '\x2', '\x2', '\x2', '\xB3C', '\xB69', '\a', 
		'\x267', '\x2', '\x2', '\xB3D', '\xB3F', '\a', '\x1A1', '\x2', '\x2', 
		'\xB3E', '\xB40', '\a', '\x176', '\x2', '\x2', '\xB3F', '\xB3E', '\x3', 
		'\x2', '\x2', '\x2', '\xB3F', '\xB40', '\x3', '\x2', '\x2', '\x2', '\xB40', 
		'\xB41', '\x3', '\x2', '\x2', '\x2', '\xB41', '\xB69', '\a', '\x267', 
		'\x2', '\x2', '\xB42', '\xB44', '\a', '\x65', '\x2', '\x2', '\xB43', '\xB45', 
		'\x5', '\x114', '\x8B', '\x2', '\xB44', '\xB43', '\x3', '\x2', '\x2', 
		'\x2', '\xB44', '\xB45', '\x3', '\x2', '\x2', '\x2', '\xB45', '\xB69', 
		'\x3', '\x2', '\x2', '\x2', '\xB46', '\xB47', '\a', '\xBE', '\x2', '\x2', 
		'\xB47', '\xB69', '\a', '\x267', '\x2', '\x2', '\xB48', '\xB49', '\a', 
		'O', '\x2', '\x2', '\xB49', '\xB69', '\a', '\x267', '\x2', '\x2', '\xB4A', 
		'\xB4B', '\a', '\\', '\x2', '\x2', '\xB4B', '\xB4E', '\a', '\xBE', '\x2', 
		'\x2', '\xB4C', '\xB4F', '\a', '\x24F', '\x2', '\x2', '\xB4D', '\xB4F', 
		'\x5', '\xE4', 's', '\x2', '\xB4E', '\xB4C', '\x3', '\x2', '\x2', '\x2', 
		'\xB4E', '\xB4D', '\x3', '\x2', '\x2', '\x2', '\xB4F', '\xB69', '\x3', 
		'\x2', '\x2', '\x2', '\xB50', '\xB56', '\a', '\x1D4', '\x2', '\x2', '\xB51', 
		'\xB57', '\a', '\x24F', '\x2', '\x2', '\xB52', '\xB53', '\a', '\x24B', 
		'\x2', '\x2', '\xB53', '\xB54', '\x5', '\xE4', 's', '\x2', '\xB54', '\xB55', 
		'\a', '\x24C', '\x2', '\x2', '\xB55', '\xB57', '\x3', '\x2', '\x2', '\x2', 
		'\xB56', '\xB51', '\x3', '\x2', '\x2', '\x2', '\xB56', '\xB52', '\x3', 
		'\x2', '\x2', '\x2', '\xB57', '\xB69', '\x3', '\x2', '\x2', '\x2', '\xB58', 
		'\xB59', '\a', '\\', '\x2', '\x2', '\xB59', '\xB5A', '\a', '\x1A0', '\x2', 
		'\x2', '\xB5A', '\xB5B', '\a', '\x1A1', '\x2', '\x2', '\xB5B', '\xB69', 
		'\x5', '\xE4', 's', '\x2', '\xB5C', '\xB5D', '\a', '\x1D2', '\x2', '\x2', 
		'\xB5D', '\xB5E', '\a', '\x24B', '\x2', '\x2', '\xB5E', '\xB5F', '\x5', 
		'\xE4', 's', '\x2', '\xB5F', '\xB60', '\a', '\x24C', '\x2', '\x2', '\xB60', 
		'\xB69', '\x3', '\x2', '\x2', '\x2', '\xB61', '\xB62', '\a', '\x1D3', 
		'\x2', '\x2', '\xB62', '\xB63', '\a', '\x24B', '\x2', '\x2', '\xB63', 
		'\xB64', '\x5', '\xE4', 's', '\x2', '\xB64', '\xB65', '\a', '\x24C', '\x2', 
		'\x2', '\xB65', '\xB69', '\x3', '\x2', '\x2', '\x2', '\xB66', '\xB67', 
		'\a', 'L', '\x2', '\x2', '\xB67', '\xB69', '\a', '\x267', '\x2', '\x2', 
		'\xB68', '\xB2D', '\x3', '\x2', '\x2', '\x2', '\xB68', '\xB30', '\x3', 
		'\x2', '\x2', '\x2', '\xB68', '\xB34', '\x3', '\x2', '\x2', '\x2', '\xB68', 
		'\xB38', '\x3', '\x2', '\x2', '\x2', '\xB68', '\xB3D', '\x3', '\x2', '\x2', 
		'\x2', '\xB68', '\xB42', '\x3', '\x2', '\x2', '\x2', '\xB68', '\xB46', 
		'\x3', '\x2', '\x2', '\x2', '\xB68', '\xB48', '\x3', '\x2', '\x2', '\x2', 
		'\xB68', '\xB4A', '\x3', '\x2', '\x2', '\x2', '\xB68', '\xB50', '\x3', 
		'\x2', '\x2', '\x2', '\xB68', '\xB58', '\x3', '\x2', '\x2', '\x2', '\xB68', 
		'\xB5C', '\x3', '\x2', '\x2', '\x2', '\xB68', '\xB61', '\x3', '\x2', '\x2', 
		'\x2', '\xB68', '\xB66', '\x3', '\x2', '\x2', '\x2', '\xB69', '\x113', 
		'\x3', '\x2', '\x2', '\x2', '\xB6A', '\xB6B', '\t', '-', '\x2', '\x2', 
		'\xB6B', '\x115', '\x3', '\x2', '\x2', '\x2', '\xB6C', '\xB71', '\x5', 
		'\x118', '\x8D', '\x2', '\xB6D', '\xB6E', '\a', '\x245', '\x2', '\x2', 
		'\xB6E', '\xB70', '\x5', '\x118', '\x8D', '\x2', '\xB6F', '\xB6D', '\x3', 
		'\x2', '\x2', '\x2', '\xB70', '\xB73', '\x3', '\x2', '\x2', '\x2', '\xB71', 
		'\xB6F', '\x3', '\x2', '\x2', '\x2', '\xB71', '\xB72', '\x3', '\x2', '\x2', 
		'\x2', '\xB72', '\x117', '\x3', '\x2', '\x2', '\x2', '\xB73', '\xB71', 
		'\x3', '\x2', '\x2', '\x2', '\xB74', '\xB80', '\x5', '\x34', '\x1B', '\x2', 
		'\xB75', '\xB76', '\a', '\x24B', '\x2', '\x2', '\xB76', '\xB7B', '\x5', 
		'\b', '\x5', '\x2', '\xB77', '\xB78', '\a', '\x245', '\x2', '\x2', '\xB78', 
		'\xB7A', '\x5', '\b', '\x5', '\x2', '\xB79', '\xB77', '\x3', '\x2', '\x2', 
		'\x2', '\xB7A', '\xB7D', '\x3', '\x2', '\x2', '\x2', '\xB7B', '\xB79', 
		'\x3', '\x2', '\x2', '\x2', '\xB7B', '\xB7C', '\x3', '\x2', '\x2', '\x2', 
		'\xB7C', '\xB7E', '\x3', '\x2', '\x2', '\x2', '\xB7D', '\xB7B', '\x3', 
		'\x2', '\x2', '\x2', '\xB7E', '\xB7F', '\a', '\x24C', '\x2', '\x2', '\xB7F', 
		'\xB81', '\x3', '\x2', '\x2', '\x2', '\xB80', '\xB75', '\x3', '\x2', '\x2', 
		'\x2', '\xB80', '\xB81', '\x3', '\x2', '\x2', '\x2', '\xB81', '\x119', 
		'\x3', '\x2', '\x2', '\x2', '\xB82', '\xB88', '\a', '\x18B', '\x2', '\x2', 
		'\xB83', '\xB86', '\a', '~', '\x2', '\x2', '\xB84', '\xB87', '\x5', '\b', 
		'\x5', '\x2', '\xB85', '\xB87', '\x5', 'h', '\x35', '\x2', '\xB86', '\xB84', 
		'\x3', '\x2', '\x2', '\x2', '\xB86', '\xB85', '\x3', '\x2', '\x2', '\x2', 
		'\xB87', '\xB89', '\x3', '\x2', '\x2', '\x2', '\xB88', '\xB83', '\x3', 
		'\x2', '\x2', '\x2', '\xB88', '\xB89', '\x3', '\x2', '\x2', '\x2', '\xB89', 
		'\xB8A', '\x3', '\x2', '\x2', '\x2', '\xB8A', '\xB93', '\x5', 'h', '\x35', 
		'\x2', '\xB8B', '\xB8C', '\a', '\x18B', '\x2', '\x2', '\xB8C', '\xB8D', 
		'\x5', 'h', '\x35', '\x2', '\xB8D', '\xB90', '\a', '~', '\x2', '\x2', 
		'\xB8E', '\xB91', '\x5', '\b', '\x5', '\x2', '\xB8F', '\xB91', '\x5', 
		'h', '\x35', '\x2', '\xB90', '\xB8E', '\x3', '\x2', '\x2', '\x2', '\xB90', 
		'\xB8F', '\x3', '\x2', '\x2', '\x2', '\xB91', '\xB93', '\x3', '\x2', '\x2', 
		'\x2', '\xB92', '\xB82', '\x3', '\x2', '\x2', '\x2', '\xB92', '\xB8B', 
		'\x3', '\x2', '\x2', '\x2', '\xB93', '\x11B', '\x3', '\x2', '\x2', '\x2', 
		'\xB94', '\xB96', '\t', '.', '\x2', '\x2', '\xB95', '\xB97', '\x5', '\xD4', 
		'k', '\x2', '\xB96', '\xB95', '\x3', '\x2', '\x2', '\x2', '\xB96', '\xB97', 
		'\x3', '\x2', '\x2', '\x2', '\xB97', '\x11D', '\x3', '\x2', '\x2', '\x2', 
		'\xB98', '\xB99', '\a', '\x1B7', '\x2', '\x2', '\xB99', '\xB9E', '\x5', 
		'\x142', '\xA2', '\x2', '\xB9A', '\xB9B', '\a', '\x245', '\x2', '\x2', 
		'\xB9B', '\xB9D', '\x5', '\x142', '\xA2', '\x2', '\xB9C', '\xB9A', '\x3', 
		'\x2', '\x2', '\x2', '\xB9D', '\xBA0', '\x3', '\x2', '\x2', '\x2', '\xB9E', 
		'\xB9C', '\x3', '\x2', '\x2', '\x2', '\xB9E', '\xB9F', '\x3', '\x2', '\x2', 
		'\x2', '\xB9F', '\x11F', '\x3', '\x2', '\x2', '\x2', '\xBA0', '\xB9E', 
		'\x3', '\x2', '\x2', '\x2', '\xBA1', '\xBA2', '\x5', '\xAC', 'W', '\x2', 
		'\xBA2', '\xBA5', '\t', '\x17', '\x2', '\x2', '\xBA3', '\xBA6', '\x5', 
		'\x122', '\x92', '\x2', '\xBA4', '\xBA6', '\x5', '\xAE', 'X', '\x2', '\xBA5', 
		'\xBA3', '\x3', '\x2', '\x2', '\x2', '\xBA5', '\xBA4', '\x3', '\x2', '\x2', 
		'\x2', '\xBA6', '\x121', '\x3', '\x2', '\x2', '\x2', '\xBA7', '\xBA9', 
		'\x5', '~', '@', '\x2', '\xBA8', '\xBA7', '\x3', '\x2', '\x2', '\x2', 
		'\xBA8', '\xBA9', '\x3', '\x2', '\x2', '\x2', '\xBA9', '\xBAA', '\x3', 
		'\x2', '\x2', '\x2', '\xBAA', '\xBAE', '\x5', '\x124', '\x93', '\x2', 
		'\xBAB', '\xBAD', '\x5', '\x9A', 'N', '\x2', '\xBAC', '\xBAB', '\x3', 
		'\x2', '\x2', '\x2', '\xBAD', '\xBB0', '\x3', '\x2', '\x2', '\x2', '\xBAE', 
		'\xBAC', '\x3', '\x2', '\x2', '\x2', '\xBAE', '\xBAF', '\x3', '\x2', '\x2', 
		'\x2', '\xBAF', '\x123', '\x3', '\x2', '\x2', '\x2', '\xBB0', '\xBAE', 
		'\x3', '\x2', '\x2', '\x2', '\xBB1', '\xBB2', '\x5', '\x14', '\v', '\x2', 
		'\xBB2', '\xBB4', '\t', '\x4', '\x2', '\x2', '\xBB3', '\xBB5', '\x5', 
		'|', '?', '\x2', '\xBB4', '\xBB3', '\x3', '\x2', '\x2', '\x2', '\xBB4', 
		'\xBB5', '\x3', '\x2', '\x2', '\x2', '\xBB5', '\xBBB', '\x3', '\x2', '\x2', 
		'\x2', '\xBB6', '\xBBC', '\x5', '\x16', '\f', '\x2', '\xBB7', '\xBB8', 
		'\a', '\x24B', '\x2', '\x2', '\xBB8', '\xBB9', '\x5', '\x12', '\n', '\x2', 
		'\xBB9', '\xBBA', '\a', '\x24C', '\x2', '\x2', '\xBBA', '\xBBC', '\x3', 
		'\x2', '\x2', '\x2', '\xBBB', '\xBB6', '\x3', '\x2', '\x2', '\x2', '\xBBB', 
		'\xBB7', '\x3', '\x2', '\x2', '\x2', '\xBBC', '\xBBF', '\x3', '\x2', '\x2', 
		'\x2', '\xBBD', '\xBBF', '\x5', '\x16', '\f', '\x2', '\xBBE', '\xBB1', 
		'\x3', '\x2', '\x2', '\x2', '\xBBE', '\xBBD', '\x3', '\x2', '\x2', '\x2', 
		'\xBBF', '\x125', '\x3', '\x2', '\x2', '\x2', '\xBC0', '\xBC1', '\b', 
		'\x94', '\x1', '\x2', '\xBC1', '\xBC2', '\a', '\x24B', '\x2', '\x2', '\xBC2', 
		'\xBC3', '\x5', '\x142', '\xA2', '\x2', '\xBC3', '\xBC5', '\a', '\x24C', 
		'\x2', '\x2', '\xBC4', '\xBC6', '\x5', '\x8A', '\x46', '\x2', '\xBC5', 
		'\xBC4', '\x3', '\x2', '\x2', '\x2', '\xBC5', '\xBC6', '\x3', '\x2', '\x2', 
		'\x2', '\xBC6', '\xBD8', '\x3', '\x2', '\x2', '\x2', '\xBC7', '\xBC8', 
		'\a', '\x24B', '\x2', '\x2', '\xBC8', '\xBCB', '\x5', '\x142', '\xA2', 
		'\x2', '\xBC9', '\xBCA', '\a', '\x245', '\x2', '\x2', '\xBCA', '\xBCC', 
		'\x5', '\x142', '\xA2', '\x2', '\xBCB', '\xBC9', '\x3', '\x2', '\x2', 
		'\x2', '\xBCC', '\xBCD', '\x3', '\x2', '\x2', '\x2', '\xBCD', '\xBCB', 
		'\x3', '\x2', '\x2', '\x2', '\xBCD', '\xBCE', '\x3', '\x2', '\x2', '\x2', 
		'\xBCE', '\xBCF', '\x3', '\x2', '\x2', '\x2', '\xBCF', '\xBD0', '\a', 
		'\x24C', '\x2', '\x2', '\xBD0', '\xBD8', '\x3', '\x2', '\x2', '\x2', '\xBD1', 
		'\xBD2', '\t', '&', '\x2', '\x2', '\xBD2', '\xBD8', '\x5', '\x126', '\x94', 
		'\xF', '\xBD3', '\xBD4', '\x5', '\x128', '\x95', '\x2', '\xBD4', '\xBD5', 
		'\x5', '\x126', '\x94', '\n', '\xBD5', '\xBD8', '\x3', '\x2', '\x2', '\x2', 
		'\xBD6', '\xBD8', '\x5', '\x12A', '\x96', '\x2', '\xBD7', '\xBC0', '\x3', 
		'\x2', '\x2', '\x2', '\xBD7', '\xBC7', '\x3', '\x2', '\x2', '\x2', '\xBD7', 
		'\xBD1', '\x3', '\x2', '\x2', '\x2', '\xBD7', '\xBD3', '\x3', '\x2', '\x2', 
		'\x2', '\xBD7', '\xBD6', '\x3', '\x2', '\x2', '\x2', '\xBD8', '\xC0E', 
		'\x3', '\x2', '\x2', '\x2', '\xBD9', '\xBDA', '\f', '\xE', '\x2', '\x2', 
		'\xBDA', '\xBDB', '\a', '\x252', '\x2', '\x2', '\xBDB', '\xC0D', '\x5', 
		'\x126', '\x94', '\xF', '\xBDC', '\xBDD', '\f', '\r', '\x2', '\x2', '\xBDD', 
		'\xBDE', '\t', '/', '\x2', '\x2', '\xBDE', '\xC0D', '\x5', '\x126', '\x94', 
		'\xE', '\xBDF', '\xBE0', '\f', '\f', '\x2', '\x2', '\xBE0', '\xBE1', '\t', 
		'&', '\x2', '\x2', '\xBE1', '\xC0D', '\x5', '\x126', '\x94', '\r', '\xBE2', 
		'\xBE3', '\f', '\v', '\x2', '\x2', '\xBE3', '\xBE4', '\x5', '\x128', '\x95', 
		'\x2', '\xBE4', '\xBE5', '\x5', '\x126', '\x94', '\f', '\xBE5', '\xC0D', 
		'\x3', '\x2', '\x2', '\x2', '\xBE6', '\xBE7', '\f', '\b', '\x2', '\x2', 
		'\xBE7', '\xBE8', '\t', '\x30', '\x2', '\x2', '\xBE8', '\xC0D', '\x5', 
		'\x126', '\x94', '\t', '\xBE9', '\xBEA', '\f', '\a', '\x2', '\x2', '\xBEA', 
		'\xBEC', '\a', '\x163', '\x2', '\x2', '\xBEB', '\xBED', '\a', '\x1A0', 
		'\x2', '\x2', '\xBEC', '\xBEB', '\x3', '\x2', '\x2', '\x2', '\xBEC', '\xBED', 
		'\x3', '\x2', '\x2', '\x2', '\xBED', '\xBEE', '\x3', '\x2', '\x2', '\x2', 
		'\xBEE', '\xBEF', '\a', '\x18A', '\x2', '\x2', '\xBEF', '\xBF0', '\a', 
		'\x193', '\x2', '\x2', '\xBF0', '\xC0D', '\x5', '\x126', '\x94', '\b', 
		'\xBF1', '\xBF2', '\f', '\x12', '\x2', '\x2', '\xBF2', '\xBF3', '\a', 
		'\x241', '\x2', '\x2', '\xBF3', '\xC0D', '\x5', 'H', '%', '\x2', '\xBF4', 
		'\xBF5', '\f', '\t', '\x2', '\x2', '\xBF5', '\xC0D', '\x5', '\x128', '\x95', 
		'\x2', '\xBF6', '\xBF7', '\f', '\x6', '\x2', '\x2', '\xBF7', '\xBF9', 
		'\a', '\x163', '\x2', '\x2', '\xBF8', '\xBFA', '\a', '\x1A0', '\x2', '\x2', 
		'\xBF9', '\xBF8', '\x3', '\x2', '\x2', '\x2', '\xBF9', '\xBFA', '\x3', 
		'\x2', '\x2', '\x2', '\xBFA', '\xBFB', '\x3', '\x2', '\x2', '\x2', '\xBFB', 
		'\xC0D', '\a', '\x46', '\x2', '\x2', '\xBFC', '\xBFD', '\f', '\x5', '\x2', 
		'\x2', '\xBFD', '\xBFF', '\a', '\x163', '\x2', '\x2', '\xBFE', '\xC00', 
		'\a', '\x1A0', '\x2', '\x2', '\xBFF', '\xBFE', '\x3', '\x2', '\x2', '\x2', 
		'\xBFF', '\xC00', '\x3', '\x2', '\x2', '\x2', '\xC00', '\xC01', '\x3', 
		'\x2', '\x2', '\x2', '\xC01', '\xC0D', '\a', '\x10E', '\x2', '\x2', '\xC02', 
		'\xC03', '\f', '\x4', '\x2', '\x2', '\xC03', '\xC05', '\a', '\x163', '\x2', 
		'\x2', '\xC04', '\xC06', '\a', '\x1A0', '\x2', '\x2', '\xC05', '\xC04', 
		'\x3', '\x2', '\x2', '\x2', '\xC05', '\xC06', '\x3', '\x2', '\x2', '\x2', 
		'\xC06', '\xC07', '\x3', '\x2', '\x2', '\x2', '\xC07', '\xC08', '\a', 
		'\x9E', '\x2', '\x2', '\xC08', '\xC09', '\a', '\x24B', '\x2', '\x2', '\xC09', 
		'\xC0A', '\x5', '\x140', '\xA1', '\x2', '\xC0A', '\xC0B', '\a', '\x24C', 
		'\x2', '\x2', '\xC0B', '\xC0D', '\x3', '\x2', '\x2', '\x2', '\xC0C', '\xBD9', 
		'\x3', '\x2', '\x2', '\x2', '\xC0C', '\xBDC', '\x3', '\x2', '\x2', '\x2', 
		'\xC0C', '\xBDF', '\x3', '\x2', '\x2', '\x2', '\xC0C', '\xBE2', '\x3', 
		'\x2', '\x2', '\x2', '\xC0C', '\xBE6', '\x3', '\x2', '\x2', '\x2', '\xC0C', 
		'\xBE9', '\x3', '\x2', '\x2', '\x2', '\xC0C', '\xBF1', '\x3', '\x2', '\x2', 
		'\x2', '\xC0C', '\xBF4', '\x3', '\x2', '\x2', '\x2', '\xC0C', '\xBF6', 
		'\x3', '\x2', '\x2', '\x2', '\xC0C', '\xBFC', '\x3', '\x2', '\x2', '\x2', 
		'\xC0C', '\xC02', '\x3', '\x2', '\x2', '\x2', '\xC0D', '\xC10', '\x3', 
		'\x2', '\x2', '\x2', '\xC0E', '\xC0C', '\x3', '\x2', '\x2', '\x2', '\xC0E', 
		'\xC0F', '\x3', '\x2', '\x2', '\x2', '\xC0F', '\x127', '\x3', '\x2', '\x2', 
		'\x2', '\xC10', '\xC0E', '\x3', '\x2', '\x2', '\x2', '\xC11', '\xC1A', 
		'\x5', ',', '\x17', '\x2', '\xC12', '\xC13', '\a', '\xA2', '\x2', '\x2', 
		'\xC13', '\xC14', '\a', '\x24B', '\x2', '\x2', '\xC14', '\xC15', '\x5', 
		'\b', '\x5', '\x2', '\xC15', '\xC16', '\a', '\x253', '\x2', '\x2', '\xC16', 
		'\xC17', '\x5', '*', '\x16', '\x2', '\xC17', '\xC18', '\a', '\x24C', '\x2', 
		'\x2', '\xC18', '\xC1A', '\x3', '\x2', '\x2', '\x2', '\xC19', '\xC11', 
		'\x3', '\x2', '\x2', '\x2', '\xC19', '\xC12', '\x3', '\x2', '\x2', '\x2', 
		'\xC1A', '\x129', '\x3', '\x2', '\x2', '\x2', '\xC1B', '\xC2E', '\x5', 
		'\x13C', '\x9F', '\x2', '\xC1C', '\xC1D', '\a', '\x24B', '\x2', '\x2', 
		'\xC1D', '\xC1E', '\x5', '\x122', '\x92', '\x2', '\xC1E', '\xC20', '\a', 
		'\x24C', '\x2', '\x2', '\xC1F', '\xC21', '\x5', '\x8A', '\x46', '\x2', 
		'\xC20', '\xC1F', '\x3', '\x2', '\x2', '\x2', '\xC20', '\xC21', '\x3', 
		'\x2', '\x2', '\x2', '\xC21', '\xC2E', '\x3', '\x2', '\x2', '\x2', '\xC22', 
		'\xC2E', '\x5', '\x13A', '\x9E', '\x2', '\xC23', '\xC2E', '\a', '\x1A1', 
		'\x2', '\x2', '\xC24', '\xC2E', '\a', '\x24F', '\x2', '\x2', '\xC25', 
		'\xC2E', '\x5', '\x138', '\x9D', '\x2', '\xC26', '\xC27', '\a', '\x130', 
		'\x2', '\x2', '\xC27', '\xC2E', '\x5', 'r', ':', '\x2', '\xC28', '\xC2E', 
		'\x5', 'X', '-', '\x2', '\xC29', '\xC2E', '\x5', '\x134', '\x9B', '\x2', 
		'\xC2A', '\xC2E', '\x5', '\x130', '\x99', '\x2', '\xC2B', '\xC2E', '\x5', 
		'\x12E', '\x98', '\x2', '\xC2C', '\xC2E', '\x5', '\x12C', '\x97', '\x2', 
		'\xC2D', '\xC1B', '\x3', '\x2', '\x2', '\x2', '\xC2D', '\xC1C', '\x3', 
		'\x2', '\x2', '\x2', '\xC2D', '\xC22', '\x3', '\x2', '\x2', '\x2', '\xC2D', 
		'\xC23', '\x3', '\x2', '\x2', '\x2', '\xC2D', '\xC24', '\x3', '\x2', '\x2', 
		'\x2', '\xC2D', '\xC25', '\x3', '\x2', '\x2', '\x2', '\xC2D', '\xC26', 
		'\x3', '\x2', '\x2', '\x2', '\xC2D', '\xC28', '\x3', '\x2', '\x2', '\x2', 
		'\xC2D', '\xC29', '\x3', '\x2', '\x2', '\x2', '\xC2D', '\xC2A', '\x3', 
		'\x2', '\x2', '\x2', '\xC2D', '\xC2B', '\x3', '\x2', '\x2', '\x2', '\xC2D', 
		'\xC2C', '\x3', '\x2', '\x2', '\x2', '\xC2E', '\x12B', '\x3', '\x2', '\x2', 
		'\x2', '\xC2F', '\xC30', '\a', '\x24B', '\x2', '\x2', '\xC30', '\xC31', 
		'\x5', '\x142', '\xA2', '\x2', '\xC31', '\xC32', '\a', '\x245', '\x2', 
		'\x2', '\xC32', '\xC33', '\x5', '\x142', '\xA2', '\x2', '\xC33', '\xC34', 
		'\a', '\x24C', '\x2', '\x2', '\xC34', '\xC35', '\a', '\x16B', '\x2', '\x2', 
		'\xC35', '\xC36', '\a', '\x24B', '\x2', '\x2', '\xC36', '\xC37', '\x5', 
		'\x142', '\xA2', '\x2', '\xC37', '\xC38', '\a', '\x245', '\x2', '\x2', 
		'\xC38', '\xC39', '\x5', '\x142', '\xA2', '\x2', '\xC39', '\xC3A', '\a', 
		'\x24C', '\x2', '\x2', '\xC3A', '\x12D', '\x3', '\x2', '\x2', '\x2', '\xC3B', 
		'\xC3C', '\x5', 'H', '%', '\x2', '\xC3C', '\xC3D', '\x5', 'h', '\x35', 
		'\x2', '\xC3D', '\xC45', '\x3', '\x2', '\x2', '\x2', '\xC3E', '\xC3F', 
		'\a', '\x138', '\x2', '\x2', '\xC3F', '\xC40', '\x5', 'h', '\x35', '\x2', 
		'\xC40', '\xC42', '\x5', 'R', '*', '\x2', '\xC41', '\xC43', '\x5', 'T', 
		'+', '\x2', '\xC42', '\xC41', '\x3', '\x2', '\x2', '\x2', '\xC42', '\xC43', 
		'\x3', '\x2', '\x2', '\x2', '\xC43', '\xC45', '\x3', '\x2', '\x2', '\x2', 
		'\xC44', '\xC3B', '\x3', '\x2', '\x2', '\x2', '\xC44', '\xC3E', '\x3', 
		'\x2', '\x2', '\x2', '\xC45', '\x12F', '\x3', '\x2', '\x2', '\x2', '\xC46', 
		'\xC49', '\a', '\x175', '\x2', '\x2', '\xC47', '\xC4A', '\x5', '\x132', 
		'\x9A', '\x2', '\xC48', '\xC4A', '\x5', 'r', ':', '\x2', '\xC49', '\xC47', 
		'\x3', '\x2', '\x2', '\x2', '\xC49', '\xC48', '\x3', '\x2', '\x2', '\x2', 
		'\xC4A', '\x131', '\x3', '\x2', '\x2', '\x2', '\xC4B', '\xC5A', '\a', 
		'\x257', '\x2', '\x2', '\xC4C', '\xC4F', '\x5', '\x142', '\xA2', '\x2', 
		'\xC4D', '\xC4F', '\x5', '\x132', '\x9A', '\x2', '\xC4E', '\xC4C', '\x3', 
		'\x2', '\x2', '\x2', '\xC4E', '\xC4D', '\x3', '\x2', '\x2', '\x2', '\xC4F', 
		'\xC57', '\x3', '\x2', '\x2', '\x2', '\xC50', '\xC53', '\a', '\x245', 
		'\x2', '\x2', '\xC51', '\xC54', '\x5', '\x142', '\xA2', '\x2', '\xC52', 
		'\xC54', '\x5', '\x132', '\x9A', '\x2', '\xC53', '\xC51', '\x3', '\x2', 
		'\x2', '\x2', '\xC53', '\xC52', '\x3', '\x2', '\x2', '\x2', '\xC54', '\xC56', 
		'\x3', '\x2', '\x2', '\x2', '\xC55', '\xC50', '\x3', '\x2', '\x2', '\x2', 
		'\xC56', '\xC59', '\x3', '\x2', '\x2', '\x2', '\xC57', '\xC55', '\x3', 
		'\x2', '\x2', '\x2', '\xC57', '\xC58', '\x3', '\x2', '\x2', '\x2', '\xC58', 
		'\xC5B', '\x3', '\x2', '\x2', '\x2', '\xC59', '\xC57', '\x3', '\x2', '\x2', 
		'\x2', '\xC5A', '\xC4E', '\x3', '\x2', '\x2', '\x2', '\xC5A', '\xC5B', 
		'\x3', '\x2', '\x2', '\x2', '\xC5B', '\xC5C', '\x3', '\x2', '\x2', '\x2', 
		'\xC5C', '\xC5D', '\a', '\x258', '\x2', '\x2', '\xC5D', '\x133', '\x3', 
		'\x2', '\x2', '\x2', '\xC5E', '\xC61', '\x5', '\b', '\x5', '\x2', '\xC5F', 
		'\xC61', '\x5', '\x136', '\x9C', '\x2', '\xC60', '\xC5E', '\x3', '\x2', 
		'\x2', '\x2', '\xC60', '\xC5F', '\x3', '\x2', '\x2', '\x2', '\xC61', '\xC63', 
		'\x3', '\x2', '\x2', '\x2', '\xC62', '\xC64', '\x5', '\x8A', '\x46', '\x2', 
		'\xC63', '\xC62', '\x3', '\x2', '\x2', '\x2', '\xC63', '\xC64', '\x3', 
		'\x2', '\x2', '\x2', '\xC64', '\x135', '\x3', '\x2', '\x2', '\x2', '\xC65', 
		'\xC66', '\a', '\x264', '\x2', '\x2', '\xC66', '\x137', '\x3', '\x2', 
		'\x2', '\x2', '\xC67', '\xC68', '\t', '\x31', '\x2', '\x2', '\xC68', '\xC6B', 
		'\a', '\x24B', '\x2', '\x2', '\xC69', '\xC6C', '\x5', '\x142', '\xA2', 
		'\x2', '\xC6A', '\xC6C', '\x5', '\x122', '\x92', '\x2', '\xC6B', '\xC69', 
		'\x3', '\x2', '\x2', '\x2', '\xC6B', '\xC6A', '\x3', '\x2', '\x2', '\x2', 
		'\xC6C', '\xC6D', '\x3', '\x2', '\x2', '\x2', '\xC6D', '\xC6E', '\a', 
		'\x24C', '\x2', '\x2', '\xC6E', '\x139', '\x3', '\x2', '\x2', '\x2', '\xC6F', 
		'\xC71', '\a', '\x17A', '\x2', '\x2', '\xC70', '\xC72', '\x5', '\x142', 
		'\xA2', '\x2', '\xC71', '\xC70', '\x3', '\x2', '\x2', '\x2', '\xC71', 
		'\xC72', '\x3', '\x2', '\x2', '\x2', '\xC72', '\xC78', '\x3', '\x2', '\x2', 
		'\x2', '\xC73', '\xC74', '\a', '\x1B9', '\x2', '\x2', '\xC74', '\xC75', 
		'\x5', '\x142', '\xA2', '\x2', '\xC75', '\xC76', '\a', '\x1B0', '\x2', 
		'\x2', '\xC76', '\xC77', '\x5', '\x142', '\xA2', '\x2', '\xC77', '\xC79', 
		'\x3', '\x2', '\x2', '\x2', '\xC78', '\xC73', '\x3', '\x2', '\x2', '\x2', 
		'\xC79', '\xC7A', '\x3', '\x2', '\x2', '\x2', '\xC7A', '\xC78', '\x3', 
		'\x2', '\x2', '\x2', '\xC7A', '\xC7B', '\x3', '\x2', '\x2', '\x2', '\xC7B', 
		'\xC7E', '\x3', '\x2', '\x2', '\x2', '\xC7C', '\xC7D', '\a', '\x18C', 
		'\x2', '\x2', '\xC7D', '\xC7F', '\x5', '\x142', '\xA2', '\x2', '\xC7E', 
		'\xC7C', '\x3', '\x2', '\x2', '\x2', '\xC7E', '\xC7F', '\x3', '\x2', '\x2', 
		'\x2', '\xC7F', '\xC80', '\x3', '\x2', '\x2', '\x2', '\xC80', '\xC81', 
		'\a', '\x18D', '\x2', '\x2', '\xC81', '\x13B', '\x3', '\x2', '\x2', '\x2', 
		'\xC82', '\xC86', '\x5', '\x13E', '\xA0', '\x2', '\xC83', '\xC86', '\x5', 
		'h', '\x35', '\x2', '\xC84', '\xC86', '\x5', '\x114', '\x8B', '\x2', '\xC85', 
		'\xC82', '\x3', '\x2', '\x2', '\x2', '\xC85', '\xC83', '\x3', '\x2', '\x2', 
		'\x2', '\xC85', '\xC84', '\x3', '\x2', '\x2', '\x2', '\xC86', '\x13D', 
		'\x3', '\x2', '\x2', '\x2', '\xC87', '\xC88', '\t', '\x32', '\x2', '\x2', 
		'\xC88', '\x13F', '\x3', '\x2', '\x2', '\x2', '\xC89', '\xC8E', '\x5', 
		'H', '%', '\x2', '\xC8A', '\xC8B', '\a', '\x245', '\x2', '\x2', '\xC8B', 
		'\xC8D', '\x5', 'H', '%', '\x2', '\xC8C', '\xC8A', '\x3', '\x2', '\x2', 
		'\x2', '\xC8D', '\xC90', '\x3', '\x2', '\x2', '\x2', '\xC8E', '\xC8C', 
		'\x3', '\x2', '\x2', '\x2', '\xC8E', '\xC8F', '\x3', '\x2', '\x2', '\x2', 
		'\xC8F', '\x141', '\x3', '\x2', '\x2', '\x2', '\xC90', '\xC8E', '\x3', 
		'\x2', '\x2', '\x2', '\xC91', '\xC92', '\b', '\xA2', '\x1', '\x2', '\xC92', 
		'\xC93', '\a', '\x24B', '\x2', '\x2', '\xC93', '\xC94', '\x5', '\x142', 
		'\xA2', '\x2', '\xC94', '\xC96', '\a', '\x24C', '\x2', '\x2', '\xC95', 
		'\xC97', '\x5', '\x8A', '\x46', '\x2', '\xC96', '\xC95', '\x3', '\x2', 
		'\x2', '\x2', '\xC96', '\xC97', '\x3', '\x2', '\x2', '\x2', '\xC97', '\xCAB', 
		'\x3', '\x2', '\x2', '\x2', '\xC98', '\xC99', '\a', '\x24B', '\x2', '\x2', 
		'\xC99', '\xC9C', '\x5', '\x142', '\xA2', '\x2', '\xC9A', '\xC9B', '\a', 
		'\x245', '\x2', '\x2', '\xC9B', '\xC9D', '\x5', '\x142', '\xA2', '\x2', 
		'\xC9C', '\xC9A', '\x3', '\x2', '\x2', '\x2', '\xC9D', '\xC9E', '\x3', 
		'\x2', '\x2', '\x2', '\xC9E', '\xC9C', '\x3', '\x2', '\x2', '\x2', '\xC9E', 
		'\xC9F', '\x3', '\x2', '\x2', '\x2', '\xC9F', '\xCA0', '\x3', '\x2', '\x2', 
		'\x2', '\xCA0', '\xCA1', '\a', '\x24C', '\x2', '\x2', '\xCA1', '\xCAB', 
		'\x3', '\x2', '\x2', '\x2', '\xCA2', '\xCA3', '\t', '&', '\x2', '\x2', 
		'\xCA3', '\xCAB', '\x5', '\x142', '\xA2', '\x1A', '\xCA4', '\xCA5', '\x5', 
		'\x128', '\x95', '\x2', '\xCA5', '\xCA6', '\x5', '\x142', '\xA2', '\x14', 
		'\xCA6', '\xCAB', '\x3', '\x2', '\x2', '\x2', '\xCA7', '\xCA8', '\a', 
		'\x1A0', '\x2', '\x2', '\xCA8', '\xCAB', '\x5', '\x142', '\xA2', '\x6', 
		'\xCA9', '\xCAB', '\x5', '\x12A', '\x96', '\x2', '\xCAA', '\xC91', '\x3', 
		'\x2', '\x2', '\x2', '\xCAA', '\xC98', '\x3', '\x2', '\x2', '\x2', '\xCAA', 
		'\xCA2', '\x3', '\x2', '\x2', '\x2', '\xCAA', '\xCA4', '\x3', '\x2', '\x2', 
		'\x2', '\xCAA', '\xCA7', '\x3', '\x2', '\x2', '\x2', '\xCAA', '\xCA9', 
		'\x3', '\x2', '\x2', '\x2', '\xCAB', '\xD33', '\x3', '\x2', '\x2', '\x2', 
		'\xCAC', '\xCAD', '\f', '\x19', '\x2', '\x2', '\xCAD', '\xCAE', '\a', 
		'\x10', '\x2', '\x2', '\xCAE', '\xCAF', '\a', '\x148', '\x2', '\x2', '\xCAF', 
		'\xCB0', '\a', '\x126', '\x2', '\x2', '\xCB0', '\xD32', '\x5', '\x142', 
		'\xA2', '\x1A', '\xCB1', '\xCB2', '\f', '\x18', '\x2', '\x2', '\xCB2', 
		'\xCB3', '\a', '\x252', '\x2', '\x2', '\xCB3', '\xD32', '\x5', '\x142', 
		'\xA2', '\x19', '\xCB4', '\xCB5', '\f', '\x17', '\x2', '\x2', '\xCB5', 
		'\xCB6', '\t', '/', '\x2', '\x2', '\xCB6', '\xD32', '\x5', '\x142', '\xA2', 
		'\x18', '\xCB7', '\xCB8', '\f', '\x16', '\x2', '\x2', '\xCB8', '\xCB9', 
		'\t', '&', '\x2', '\x2', '\xCB9', '\xD32', '\x5', '\x142', '\xA2', '\x17', 
		'\xCBA', '\xCBB', '\f', '\x15', '\x2', '\x2', '\xCBB', '\xCBC', '\x5', 
		'\x128', '\x95', '\x2', '\xCBC', '\xCBD', '\x5', '\x142', '\xA2', '\x16', 
		'\xCBD', '\xD32', '\x3', '\x2', '\x2', '\x2', '\xCBE', '\xCC0', '\f', 
		'\x11', '\x2', '\x2', '\xCBF', '\xCC1', '\a', '\x1A0', '\x2', '\x2', '\xCC0', 
		'\xCBF', '\x3', '\x2', '\x2', '\x2', '\xCC0', '\xCC1', '\x3', '\x2', '\x2', 
		'\x2', '\xCC1', '\xCC2', '\x3', '\x2', '\x2', '\x2', '\xCC2', '\xCC4', 
		'\a', '\x127', '\x2', '\x2', '\xCC3', '\xCC5', '\t', '\x33', '\x2', '\x2', 
		'\xCC4', '\xCC3', '\x3', '\x2', '\x2', '\x2', '\xCC4', '\xCC5', '\x3', 
		'\x2', '\x2', '\x2', '\xCC5', '\xCC6', '\x3', '\x2', '\x2', '\x2', '\xCC6', 
		'\xCC7', '\x5', '\x126', '\x94', '\x2', '\xCC7', '\xCC8', '\a', '\x173', 
		'\x2', '\x2', '\xCC8', '\xCC9', '\x5', '\x142', '\xA2', '\x12', '\xCC9', 
		'\xD32', '\x3', '\x2', '\x2', '\x2', '\xCCA', '\xCCC', '\f', '\x10', '\x2', 
		'\x2', '\xCCB', '\xCCD', '\a', '\x1A0', '\x2', '\x2', '\xCCC', '\xCCB', 
		'\x3', '\x2', '\x2', '\x2', '\xCCC', '\xCCD', '\x3', '\x2', '\x2', '\x2', 
		'\xCCD', '\xCD2', '\x3', '\x2', '\x2', '\x2', '\xCCE', '\xCD3', '\a', 
		'\x167', '\x2', '\x2', '\xCCF', '\xCD3', '\a', '\x161', '\x2', '\x2', 
		'\xCD0', '\xCD1', '\a', '\x16D', '\x2', '\x2', '\xCD1', '\xCD3', '\a', 
		'\x1B1', '\x2', '\x2', '\xCD2', '\xCCE', '\x3', '\x2', '\x2', '\x2', '\xCD2', 
		'\xCCF', '\x3', '\x2', '\x2', '\x2', '\xCD2', '\xCD0', '\x3', '\x2', '\x2', 
		'\x2', '\xCD3', '\xCD4', '\x3', '\x2', '\x2', '\x2', '\xCD4', '\xD32', 
		'\x5', '\x142', '\xA2', '\x11', '\xCD5', '\xCD7', '\f', '\xF', '\x2', 
		'\x2', '\xCD6', '\xCD8', '\a', '\x1A0', '\x2', '\x2', '\xCD7', '\xCD6', 
		'\x3', '\x2', '\x2', '\x2', '\xCD7', '\xCD8', '\x3', '\x2', '\x2', '\x2', 
		'\xCD8', '\xCDD', '\x3', '\x2', '\x2', '\x2', '\xCD9', '\xCDE', '\a', 
		'\x167', '\x2', '\x2', '\xCDA', '\xCDE', '\a', '\x161', '\x2', '\x2', 
		'\xCDB', '\xCDC', '\a', '\x16D', '\x2', '\x2', '\xCDC', '\xCDE', '\a', 
		'\x1B1', '\x2', '\x2', '\xCDD', '\xCD9', '\x3', '\x2', '\x2', '\x2', '\xCDD', 
		'\xCDA', '\x3', '\x2', '\x2', '\x2', '\xCDD', '\xCDB', '\x3', '\x2', '\x2', 
		'\x2', '\xCDE', '\xCDF', '\x3', '\x2', '\x2', '\x2', '\xCDF', '\xCE0', 
		'\x5', '\x142', '\xA2', '\x2', '\xCE0', '\xCE1', '\a', 'O', '\x2', '\x2', 
		'\xCE1', '\xCE2', '\x5', '\x142', '\xA2', '\x10', '\xCE2', '\xD32', '\x3', 
		'\x2', '\x2', '\x2', '\xCE3', '\xCE4', '\f', '\xE', '\x2', '\x2', '\xCE4', 
		'\xCE5', '\t', '\x30', '\x2', '\x2', '\xCE5', '\xD32', '\x5', '\x142', 
		'\xA2', '\xF', '\xCE6', '\xCE7', '\f', '\f', '\x2', '\x2', '\xCE7', '\xCE9', 
		'\a', '\x163', '\x2', '\x2', '\xCE8', '\xCEA', '\a', '\x1A0', '\x2', '\x2', 
		'\xCE9', '\xCE8', '\x3', '\x2', '\x2', '\x2', '\xCE9', '\xCEA', '\x3', 
		'\x2', '\x2', '\x2', '\xCEA', '\xCEB', '\x3', '\x2', '\x2', '\x2', '\xCEB', 
		'\xCEC', '\a', '\x18A', '\x2', '\x2', '\xCEC', '\xCED', '\a', '\x193', 
		'\x2', '\x2', '\xCED', '\xD32', '\x5', '\x142', '\xA2', '\r', '\xCEE', 
		'\xCEF', '\f', '\x5', '\x2', '\x2', '\xCEF', '\xCF0', '\a', '\x173', '\x2', 
		'\x2', '\xCF0', '\xD32', '\x5', '\x142', '\xA2', '\x6', '\xCF1', '\xCF2', 
		'\f', '\x4', '\x2', '\x2', '\xCF2', '\xCF3', '\a', '\x1A5', '\x2', '\x2', 
		'\xCF3', '\xD32', '\x5', '\x142', '\xA2', '\x5', '\xCF4', '\xCF5', '\f', 
		'\x1E', '\x2', '\x2', '\xCF5', '\xCF6', '\a', '\x241', '\x2', '\x2', '\xCF6', 
		'\xD32', '\x5', 'H', '%', '\x2', '\xCF7', '\xCF8', '\f', '\x1B', '\x2', 
		'\x2', '\xCF8', '\xD32', '\x5', '\x9E', 'P', '\x2', '\xCF9', '\xCFA', 
		'\f', '\x13', '\x2', '\x2', '\xCFA', '\xD32', '\x5', '\x128', '\x95', 
		'\x2', '\xCFB', '\xCFD', '\f', '\x12', '\x2', '\x2', '\xCFC', '\xCFE', 
		'\a', '\x1A0', '\x2', '\x2', '\xCFD', '\xCFC', '\x3', '\x2', '\x2', '\x2', 
		'\xCFD', '\xCFE', '\x3', '\x2', '\x2', '\x2', '\xCFE', '\xCFF', '\x3', 
		'\x2', '\x2', '\x2', '\xCFF', '\xD00', '\a', '\x197', '\x2', '\x2', '\xD00', 
		'\xD0A', '\a', '\x24B', '\x2', '\x2', '\xD01', '\xD0B', '\x5', '\x122', 
		'\x92', '\x2', '\xD02', '\xD07', '\x5', '\x142', '\xA2', '\x2', '\xD03', 
		'\xD04', '\a', '\x245', '\x2', '\x2', '\xD04', '\xD06', '\x5', '\x142', 
		'\xA2', '\x2', '\xD05', '\xD03', '\x3', '\x2', '\x2', '\x2', '\xD06', 
		'\xD09', '\x3', '\x2', '\x2', '\x2', '\xD07', '\xD05', '\x3', '\x2', '\x2', 
		'\x2', '\xD07', '\xD08', '\x3', '\x2', '\x2', '\x2', '\xD08', '\xD0B', 
		'\x3', '\x2', '\x2', '\x2', '\xD09', '\xD07', '\x3', '\x2', '\x2', '\x2', 
		'\xD0A', '\xD01', '\x3', '\x2', '\x2', '\x2', '\xD0A', '\xD02', '\x3', 
		'\x2', '\x2', '\x2', '\xD0B', '\xD0C', '\x3', '\x2', '\x2', '\x2', '\xD0C', 
		'\xD0D', '\a', '\x24C', '\x2', '\x2', '\xD0D', '\xD32', '\x3', '\x2', 
		'\x2', '\x2', '\xD0E', '\xD0F', '\f', '\r', '\x2', '\x2', '\xD0F', '\xD11', 
		'\a', '\x163', '\x2', '\x2', '\xD10', '\xD12', '\a', '\x1A0', '\x2', '\x2', 
		'\xD11', '\xD10', '\x3', '\x2', '\x2', '\x2', '\xD11', '\xD12', '\x3', 
		'\x2', '\x2', '\x2', '\xD12', '\xD15', '\x3', '\x2', '\x2', '\x2', '\xD13', 
		'\xD16', '\x5', '\x114', '\x8B', '\x2', '\xD14', '\xD16', '\a', '\x1A1', 
		'\x2', '\x2', '\xD15', '\xD13', '\x3', '\x2', '\x2', '\x2', '\xD15', '\xD14', 
		'\x3', '\x2', '\x2', '\x2', '\xD16', '\xD32', '\x3', '\x2', '\x2', '\x2', 
		'\xD17', '\xD18', '\f', '\v', '\x2', '\x2', '\xD18', '\xD1A', '\a', '\x163', 
		'\x2', '\x2', '\xD19', '\xD1B', '\a', '\x1A0', '\x2', '\x2', '\xD1A', 
		'\xD19', '\x3', '\x2', '\x2', '\x2', '\xD1A', '\xD1B', '\x3', '\x2', '\x2', 
		'\x2', '\xD1B', '\xD1C', '\x3', '\x2', '\x2', '\x2', '\xD1C', '\xD32', 
		'\a', '\x46', '\x2', '\x2', '\xD1D', '\xD1E', '\f', '\n', '\x2', '\x2', 
		'\xD1E', '\xD20', '\a', '\x163', '\x2', '\x2', '\xD1F', '\xD21', '\a', 
		'\x1A0', '\x2', '\x2', '\xD20', '\xD1F', '\x3', '\x2', '\x2', '\x2', '\xD20', 
		'\xD21', '\x3', '\x2', '\x2', '\x2', '\xD21', '\xD22', '\x3', '\x2', '\x2', 
		'\x2', '\xD22', '\xD32', '\a', '\x10E', '\x2', '\x2', '\xD23', '\xD24', 
		'\f', '\t', '\x2', '\x2', '\xD24', '\xD26', '\a', '\x163', '\x2', '\x2', 
		'\xD25', '\xD27', '\a', '\x1A0', '\x2', '\x2', '\xD26', '\xD25', '\x3', 
		'\x2', '\x2', '\x2', '\xD26', '\xD27', '\x3', '\x2', '\x2', '\x2', '\xD27', 
		'\xD28', '\x3', '\x2', '\x2', '\x2', '\xD28', '\xD29', '\a', '\x9E', '\x2', 
		'\x2', '\xD29', '\xD2A', '\a', '\x24B', '\x2', '\x2', '\xD2A', '\xD2B', 
		'\x5', '\x140', '\xA1', '\x2', '\xD2B', '\xD2C', '\a', '\x24C', '\x2', 
		'\x2', '\xD2C', '\xD32', '\x3', '\x2', '\x2', '\x2', '\xD2D', '\xD2E', 
		'\f', '\b', '\x2', '\x2', '\xD2E', '\xD32', '\a', '\x164', '\x2', '\x2', 
		'\xD2F', '\xD30', '\f', '\a', '\x2', '\x2', '\xD30', '\xD32', '\a', '\x169', 
		'\x2', '\x2', '\xD31', '\xCAC', '\x3', '\x2', '\x2', '\x2', '\xD31', '\xCB1', 
		'\x3', '\x2', '\x2', '\x2', '\xD31', '\xCB4', '\x3', '\x2', '\x2', '\x2', 
		'\xD31', '\xCB7', '\x3', '\x2', '\x2', '\x2', '\xD31', '\xCBA', '\x3', 
		'\x2', '\x2', '\x2', '\xD31', '\xCBE', '\x3', '\x2', '\x2', '\x2', '\xD31', 
		'\xCCA', '\x3', '\x2', '\x2', '\x2', '\xD31', '\xCD5', '\x3', '\x2', '\x2', 
		'\x2', '\xD31', '\xCE3', '\x3', '\x2', '\x2', '\x2', '\xD31', '\xCE6', 
		'\x3', '\x2', '\x2', '\x2', '\xD31', '\xCEE', '\x3', '\x2', '\x2', '\x2', 
		'\xD31', '\xCF1', '\x3', '\x2', '\x2', '\x2', '\xD31', '\xCF4', '\x3', 
		'\x2', '\x2', '\x2', '\xD31', '\xCF7', '\x3', '\x2', '\x2', '\x2', '\xD31', 
		'\xCF9', '\x3', '\x2', '\x2', '\x2', '\xD31', '\xCFB', '\x3', '\x2', '\x2', 
		'\x2', '\xD31', '\xD0E', '\x3', '\x2', '\x2', '\x2', '\xD31', '\xD17', 
		'\x3', '\x2', '\x2', '\x2', '\xD31', '\xD1D', '\x3', '\x2', '\x2', '\x2', 
		'\xD31', '\xD23', '\x3', '\x2', '\x2', '\x2', '\xD31', '\xD2D', '\x3', 
		'\x2', '\x2', '\x2', '\xD31', '\xD2F', '\x3', '\x2', '\x2', '\x2', '\xD32', 
		'\xD35', '\x3', '\x2', '\x2', '\x2', '\xD33', '\xD31', '\x3', '\x2', '\x2', 
		'\x2', '\xD33', '\xD34', '\x3', '\x2', '\x2', '\x2', '\xD34', '\x143', 
		'\x3', '\x2', '\x2', '\x2', '\xD35', '\xD33', '\x3', '\x2', '\x2', '\x2', 
		'\xD36', '\xD37', '\t', '\x34', '\x2', '\x2', '\xD37', '\x145', '\x3', 
		'\x2', '\x2', '\x2', '\xD38', '\xD39', '\t', '\x35', '\x2', '\x2', '\xD39', 
		'\x147', '\x3', '\x2', '\x2', '\x2', '\xD3A', '\xD3B', '\t', '\x36', '\x2', 
		'\x2', '\xD3B', '\x149', '\x3', '\x2', '\x2', '\x2', '\xD3C', '\xD3D', 
		'\t', '\x37', '\x2', '\x2', '\xD3D', '\x14B', '\x3', '\x2', '\x2', '\x2', 
		'\xD3E', '\xD3F', '\t', '\x38', '\x2', '\x2', '\xD3F', '\x14D', '\x3', 
		'\x2', '\x2', '\x2', '\x201', '\x150', '\x155', '\x158', '\x15D', '\x160', 
		'\x163', '\x168', '\x16D', '\x177', '\x17D', '\x185', '\x189', '\x18D', 
		'\x191', '\x197', '\x19A', '\x19D', '\x1A4', '\x1A8', '\x1AB', '\x1B1', 
		'\x1BA', '\x1BF', '\x1C4', '\x1D0', '\x1D5', '\x1D7', '\x1DA', '\x1DD', 
		'\x1E5', '\x1E8', '\x1EC', '\x1EF', '\x1F3', '\x200', '\x203', '\x207', 
		'\x20B', '\x20E', '\x212', '\x215', '\x218', '\x21B', '\x226', '\x22F', 
		'\x231', '\x238', '\x243', '\x248', '\x24B', '\x24E', '\x257', '\x261', 
		'\x270', '\x27A', '\x280', '\x285', '\x289', '\x295', '\x29D', '\x29F', 
		'\x2A6', '\x2AD', '\x2B3', '\x2BE', '\x2C8', '\x2CE', '\x2D5', '\x2D8', 
		'\x2E3', '\x2E5', '\x2ED', '\x2EF', '\x2FA', '\x2FC', '\x303', '\x305', 
		'\x309', '\x30D', '\x310', '\x31A', '\x320', '\x322', '\x325', '\x32B', 
		'\x330', '\x335', '\x33E', '\x344', '\x346', '\x349', '\x351', '\x357', 
		'\x35B', '\x361', '\x364', '\x36D', '\x372', '\x374', '\x376', '\x381', 
		'\x387', '\x38C', '\x391', '\x393', '\x397', '\x39E', '\x3A1', '\x3A6', 
		'\x3AA', '\x3B0', '\x3B6', '\x3B9', '\x3BC', '\x3C0', '\x3C3', '\x3C7', 
		'\x3CA', '\x3CE', '\x3D4', '\x3D9', '\x3DD', '\x3E2', '\x3E6', '\x3EF', 
		'\x3F4', '\x3F6', '\x3FD', '\x402', '\x41F', '\x429', '\x430', '\x437', 
		'\x43B', '\x43D', '\x446', '\x449', '\x44E', '\x450', '\x458', '\x464', 
		'\x46A', '\x46E', '\x473', '\x479', '\x483', '\x489', '\x48D', '\x498', 
		'\x4A4', '\x4AC', '\x4AE', '\x4B8', '\x4BD', '\x4DD', '\x4E3', '\x4E9', 
		'\x4EE', '\x4F6', '\x4FB', '\x501', '\x505', '\x508', '\x50B', '\x50F', 
		'\x514', '\x51B', '\x520', '\x522', '\x52D', '\x532', '\x536', '\x54A', 
		'\x554', '\x559', '\x55D', '\x561', '\x565', '\x567', '\x56F', '\x57C', 
		'\x586', '\x58B', '\x594', '\x5A0', '\x5A3', '\x5A6', '\x5AF', '\x5B4', 
		'\x5C7', '\x5CB', '\x5D4', '\x5D9', '\x5DD', '\x5E0', '\x5E7', '\x5EE', 
		'\x5F5', '\x5FF', '\x604', '\x608', '\x60B', '\x612', '\x617', '\x61C', 
		'\x620', '\x623', '\x626', '\x62E', '\x631', '\x638', '\x63A', '\x63E', 
		'\x641', '\x645', '\x649', '\x64C', '\x64F', '\x657', '\x660', '\x663', 
		'\x66A', '\x66C', '\x670', '\x676', '\x67E', '\x684', '\x689', '\x68E', 
		'\x692', '\x697', '\x699', '\x69D', '\x6A2', '\x6A7', '\x6AC', '\x6B6', 
		'\x6BA', '\x6BD', '\x6C0', '\x6C7', '\x6CC', '\x6CF', '\x6D4', '\x6D9', 
		'\x6DC', '\x6E0', '\x6EC', '\x6F1', '\x6F3', '\x6F7', '\x6FC', '\x70B', 
		'\x714', '\x719', '\x71E', '\x722', '\x72C', '\x734', '\x737', '\x73C', 
		'\x73E', '\x748', '\x757', '\x761', '\x765', '\x769', '\x774', '\x77A', 
		'\x780', '\x788', '\x78C', '\x794', '\x79C', '\x7A7', '\x7AC', '\x7AE', 
		'\x7B7', '\x7BA', '\x7BE', '\x7C1', '\x7C5', '\x7D2', '\x7D5', '\x7D9', 
		'\x7DC', '\x7E1', '\x7EA', '\x7F2', '\x7F9', '\x7FB', '\x7FF', '\x802', 
		'\x80A', '\x80F', '\x81A', '\x81C', '\x81F', '\x823', '\x827', '\x82B', 
		'\x82F', '\x832', '\x835', '\x838', '\x83E', '\x842', '\x845', '\x84C', 
		'\x857', '\x85F', '\x868', '\x873', '\x876', '\x879', '\x87C', '\x880', 
		'\x884', '\x888', '\x88C', '\x88F', '\x894', '\x898', '\x89B', '\x8A3', 
		'\x8AA', '\x8B7', '\x8BC', '\x8C1', '\x8C4', '\x8C7', '\x8CA', '\x8CF', 
		'\x8D6', '\x8DA', '\x8E2', '\x8ED', '\x8F2', '\x8FF', '\x904', '\x90B', 
		'\x913', '\x91B', '\x91F', '\x925', '\x928', '\x92F', '\x933', '\x937', 
		'\x939', '\x941', '\x948', '\x94F', '\x95B', '\x960', '\x966', '\x96C', 
		'\x971', '\x97A', '\x980', '\x983', '\x986', '\x98A', '\x991', '\x998', 
		'\x99B', '\x9A6', '\x9A9', '\x9AC', '\x9B0', '\x9B5', '\x9B8', '\x9BD', 
		'\x9C7', '\x9CC', '\x9D0', '\x9D3', '\x9D7', '\x9DB', '\x9DE', '\x9E3', 
		'\x9EA', '\x9F0', '\x9F4', '\x9F6', '\x9F9', '\xA01', '\xA08', '\xA0B', 
		'\xA0E', '\xA12', '\xA16', '\xA1A', '\xA1F', '\xA25', '\xA27', '\xA34', 
		'\xA41', '\xA47', '\xA4B', '\xA52', '\xA57', '\xA5A', '\xA64', '\xA6D', 
		'\xA73', '\xA76', '\xA7A', '\xA83', '\xA85', '\xA8C', '\xA90', '\xA96', 
		'\xA9A', '\xAA1', '\xAA9', '\xAB0', '\xAB5', '\xAB8', '\xAC2', '\xAC7', 
		'\xAD4', '\xADC', '\xAE0', '\xAE6', '\xAEA', '\xAED', '\xAF4', '\xAF6', 
		'\xAFA', '\xB03', '\xB07', '\xB0B', '\xB0F', '\xB12', '\xB19', '\xB1B', 
		'\xB20', '\xB24', '\xB29', '\xB2D', '\xB32', '\xB36', '\xB3A', '\xB3F', 
		'\xB44', '\xB4E', '\xB56', '\xB68', '\xB71', '\xB7B', '\xB80', '\xB86', 
		'\xB88', '\xB90', '\xB92', '\xB96', '\xB9E', '\xBA5', '\xBA8', '\xBAE', 
		'\xBB4', '\xBBB', '\xBBE', '\xBC5', '\xBCD', '\xBD7', '\xBEC', '\xBF9', 
		'\xBFF', '\xC05', '\xC0C', '\xC0E', '\xC19', '\xC20', '\xC2D', '\xC42', 
		'\xC44', '\xC49', '\xC4E', '\xC53', '\xC57', '\xC5A', '\xC60', '\xC63', 
		'\xC6B', '\xC71', '\xC7A', '\xC7E', '\xC85', '\xC8E', '\xC96', '\xC9E', 
		'\xCAA', '\xCC0', '\xCC4', '\xCCC', '\xCD2', '\xCD7', '\xCDD', '\xCE9', 
		'\xCFD', '\xD07', '\xD0A', '\xD11', '\xD15', '\xD1A', '\xD20', '\xD26', 
		'\xD31', '\xD33',
	};

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN);


}
